[
    {
        "filename": "Artificial Neural Network Control for Temperature Regulation in a Chemical Reactor Using Python.md",
        "content": "```\nimport numpy as np\nimport pandas as pd\n\n\ndata = pd.read_csv('reactor_temperature_data.csv')\ninputs = data[['coolant_flow', 'heating_power']].values\noutputs = data['temperature'].values\n\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\n\nmodel = Sequential()\nmodel.add(Dense(32, input_dim=2, activation='relu'))  # \u8f93\u5165\u5c42\nmodel.add(Dense(64, activation='relu'))              # \u9690\u85cf\u5c42\nmodel.add(Dense(1, activation='linear'))             # \u8f93\u51fa\u5c42\nmodel.compile(loss='mean_squared_error', optimizer='adam')\nmodel.fit(inputs, outputs, epochs=100, batch_size=10)\ndef reactor_simulation(temp_target, model, initial_conditions):\n    temp_current = initial_conditions[0]\n    coolant_flow = initial_conditions[1]\n    heating_power = initial_conditions[2]\n    \n \n    for _ in range(100):  # \u5047\u8bbe100\u4e2a\u65f6\u95f4\u6b65\n        predicted_heating = model.predict(np.array([[coolant_flow, heating_power]]))\n        \n       \n        if temp_current < temp_target:\n            cooling_adjustment = -0.1 * (temp_target - temp_current)\n            heating_adjustment = predicted_heating[0][0] + 0.1 * (temp_target - temp_current)\n        else:\n            cooling_adjustment = 0.1 * (temp_current - temp_target)\n            heating_adjustment = predicted_heating[0][0] - 0.1 * (temp_current - temp_target)\n        \n        coolant_flow += cooling_adjustment\n        heating_power += heating_adjustment\n        \n \n        temp_current += (predicted_heating[0][0] - temp_current) * 0.1\n        \n        print(f\"Current Temperature: {temp_current}, Target: {temp_target}\")\n```\n",
        "description": "Markdown file from Artificial Neural Network Control for Temperature Regulation in a Chemical Reactor Using Python.md",
        "path": "Reference Solutions/Advanced Process Control/Artificial Neural Network Control for Temperature Regulation in a Chemical Reactor Using Python.md"
    },
    {
        "filename": "Fuzzy Logic Control for Chemical Reactor Optimization Using Python.md",
        "content": "```\nimport numpy as np\nimport skfuzzy as fuzz\nfrom skfuzzy import control as ctrl\n\n# Create the antecedent (input) and consequent (output) objects\ntemperature_error = ctrl.Antecedent(np.arange(-50, 50, 1), 'temperature_error')\nheater_output = ctrl.Consequent(np.arange(0, 100, 1), 'heater_output')\n\n# Auto-membership function population is possible with .automf(3, 5, or 7)\ntemperature_error.automf(3)\n\n# Custom membership functions can be built interactively with a familiar,\n# Pythonic API\nheater_output['low'] = fuzz.trimf(heater_output.universe, [0, 0, 50])\nheater_output['medium'] = fuzz.trimf(heater_output.universe, [0, 50, 100])\nheater_output['high'] = fuzz.trimf(heater_output.universe, [50, 100, 100])\n\n# Define rules based on our fuzzy logic system\nrule1 = ctrl.Rule(temperature_error['bad'], heater_output['high'])\nrule2 = ctrl.Rule(temperature_error['good'], heater_output['low'])\nrule3 = ctrl.Rule(temperature_error['average'], heater_output['medium'])\n\n# Create a control system\nheating_ctrl = ctrl.ControlSystem([rule1, rule2, rule3])\n\n# Create a controller object based on the system\nheating = ctrl.ControlSystemSimulation(heating_ctrl)\ndef simulate_reactor(initial_temp, target_temp, steps=100):\n    current_temp = initial_temp\n    temperatures = []\n    for _ in range(steps):\n        # Calculate the error\n        error = target_temp - current_temp\n        heating.temperature_error = error\n        \n        # Crunch the numbers\n        heating.compute()\n        \n        # Apply the output of the fuzzy controller to adjust the temperature\n        current_temp += heating.output['heater_output'] / 100.0 - (target_temp - current_temp) * 0.01\n        temperatures.append(current_temp)\n    \n    return temperatures\n\n# Example usage\ntemperatures = simulate_reactor(initial_temp=200, target_temp=250, steps=100)\nprint(temperatures)\nimport matplotlib.pyplot as plt\n\nplt.figure()\nplt.plot(range(100), temperatures, 'b', label='Temperature')\nplt.xlabel('Time (steps)')\nplt.ylabel('Temperature')\nplt.title('Fuzzy Logic Controlled Temperature Over Time')\nplt.legend(loc='best')\nplt.grid(True)\nplt.show()\n```\n",
        "description": "Markdown file from Fuzzy Logic Control for Chemical Reactor Optimization Using Python.md",
        "path": "Reference Solutions/Advanced Process Control/Fuzzy Logic Control for Chemical Reactor Optimization Using Python.md"
    },
    {
        "filename": "MATLAB Distillation Column Modeling and Control.md",
        "content": "\n% Define constants and parameters\nnumTrays = 10; % Number of trays\nfeedRate = 100; % Feed flow rate (arbitrary units)\nrefluxRatio = 2; % Reflux ratio\nboilUpRate = 2; % Boil-up ratio\n\n% Initialize states (temperature at each tray)\nx0 = 300 * ones(numTrays, 1); % Initial temperatures (in Kelvin)\n\n% Define system matrices for a simple first-order model\nA = eye(numTrays) * (1 - 1/numTrays) + diag(ones(1, numTrays-1), 1) * (1/numTrays);\nB = zeros(numTrays, 1);\nB(1) = 1;\n\n% System model\nTs = 0.1; % Sampling time\nsys = c2d(ss(A, B, eye(numTrays), zeros(numTrays, 1)), Ts);\n% Define MPC parameters\nmpcHorizon = 10; % Prediction horizon\ncontrolHorizon = 2; % Control horizon\nm = mpc(sys, Ts, mpcHorizon, controlHorizon);\n\n% Set weights on outputs and manipulated variables\nm.Weights.OutputVariables = 1;\nm.Weights.ManipulatedVariables = 0.1;\n\n% Define constraints\nm.MV = struct('Min', 0, 'Max', 200);\nm.OV = struct('Min', 300, 'Max', 400);\n\n% Initial condition of the plant\nx = x0;\n\n% Reference trajectory\nr = 350 * ones(m.Model.N, 1); % Reference temperature\n% Simulation loop\nN = 100; % Number of simulation steps\ny = zeros(N, numTrays);\nu = zeros(N, 1);\n\nfor t = 0:N-1\n    % Update the measured output\n    y(t+1,:) = x';\n    \n    % Compute the MPC action\n    u(t+1) = mpcmove(m, x, y(t+1,:), r);\n    \n    % Update the state\n    x = sys.A * x + sys.B * u(t+1);\nend\n",
        "description": "Markdown file from MATLAB Distillation Column Modeling and Control.md",
        "path": "Reference Solutions/Advanced Process Control/MATLAB Distillation Column Modeling and Control.md"
    },
    {
        "filename": "Model Predictive Control for Aircraft Trajectory Using MATLAB.md",
        "content": "```\n% Constants and parameters\ng = 9.81; % Gravity (m/s^2)\nmass = 70000; % Mass of the aircraft (kg)\nrho = 1.225; % Air density (kg/m^3)\nS = 150; % Wing surface area (m^2)\nCd0 = 0.02; % Zero-lift drag coefficient\nClAlpha = 0.1; % Lift curve slope (N/(rad*m^2))\n\n% Initial conditions\nh0 = 10000; % Initial altitude (m)\nv0 = 250; % Initial airspeed (m/s)\nx0 = [h0; v0]; % State vector [altitude, airspeed]\n\n% Time step\nTs = 1; % Sample time (seconds)\n\n% System matrices for linearized dynamics\nA = [0 1; ...\n     0 -(rho*S*ClAlpha*v0)/(mass*g)];\nB = [0; ...\n     (rho*S*v0)/(mass*g)];\n\n% Discretize the system\nsys = c2d(ss(A, B, eye(2), zeros(2,1)), Ts);\n% MPC parameters\npredictionHorizon = 20; % Prediction horizon (steps)\ncontrolHorizon = 3; % Control horizon (steps)\n\n% Create MPC controller\nmpcController = mpc(sys, Ts, predictionHorizon, controlHorizon);\n\n% Set weights on outputs and manipulated variables\nmpcController.Weights.OutputVariables = [1 1]; % Weight on altitude and airspeed\nmpcController.Weights.ManipulatedVariables = [0.1]; % Weight on thrust change\n\n% Define constraints\nmpcController.MV = struct('Min', 0, 'Max', 1); % Thrust limits (0 to 1)\nmpcController.OV = struct('Min', [8000; 200], 'Max', [12000; 300]); % Altitude and speed limits\n\n% Initial condition\nx = x0;\n\n% Reference trajectory\nrefTraj = [12000; 280]; % Desired altitude and airspeed\n% Simulation parameters\nNsim = 100; % Number of simulation steps\nY = zeros(Nsim, 2); % Store outputs\nU = zeros(Nsim, 1); % Store inputs\n\nfor t = 0:Nsim-1\n    % Update the measured output\n    Y(t+1,:) = x';\n    \n    % Compute the MPC action\n    U(t+1) = mpcmove(mpcController, x, Y(t+1,:), refTraj);\n    \n    % Simulate the system\n    x = sys.A * x + sys.B * U(t+1);\nend\n```\n",
        "description": "Markdown file from Model Predictive Control for Aircraft Trajectory Using MATLAB.md",
        "path": "Reference Solutions/Advanced Process Control/Model Predictive Control for Aircraft Trajectory Using MATLAB.md"
    },
    {
        "filename": "Model Predictive Control for Continuous Cellulose Fiber Production Using Python.md",
        "content": "```\nimport numpy as np\nfrom scipy.linalg import expm\n\n# Constants\nfeed_rate = 50  # Tons per hour\nbuffer_tank_capacity = 1000  # Cubic meters (assuming 1 ton = 1 cubic meter for simplicity)\nbatch_process_time = 2  # Hours (batch process delay)\n\n# Simulation parameters\ntime_step = 0.1  # Hours (simulation time step)\ntotal_time = 24  # Hours (total simulation time)\nnum_steps = int(total_time / time_step)\n\n# Initial conditions\nmaterial_in_tank = np.zeros(int(batch_process_time / time_step))  # Material in the buffer tank\nmaterial_in_tank[-1] = buffer_tank_capacity / 2  # Initial fill level\n\n# Demand profile (fluctuating demand)\ndemand_profile = np.sin(np.linspace(0, 2 * np.pi, num_steps)) * 20 + 30  # Tons per hour\n\nimport cvxpy as cp\n\n# MPC parameters\nprediction_horizon = 20  # Prediction horizon in steps\ncontrol_horizon = 5  # Control horizon in steps\n\n# States and controls\nstate = cp.Variable((len(material_in_tank), prediction_horizon))\ncontrol = cp.Variable((1, prediction_horizon))\n\n# Constraints\nconstraints = [\n    state[:, 0] == material_in_tank,  # Initial condition\n    state >= 0,  # Non-negativity constraint\n    state <= buffer_tank_capacity  # Maximum capacity constraint\n]\n\n# Objective: Minimize deviation from desired level\ndesired_level = buffer_tank_capacity * 0.8  # Desired level in the tank\nobjective = cp.Minimize(cp.sum((state[-1, :] - desired_level)**2))\n\n# Dynamic model\nfor t in range(prediction_horizon - 1):\n    constraints += [state[:, t+1] == state[:, t] + time_step * feed_rate - time_step * demand_profile[t]]\n\n# Solve the optimization problem\nprob = cp.Problem(objective, constraints)\nresults = []\n\nfor t in range(num_steps):\n    prob.solve()\n    results.append(state.value)\n    material_in_tank = state.value[:, 0]\n    material_in_tank = np.roll(material_in_tank, -1)\n    material_in_tank[-1] = material_in_tank[-2] + time_step * feed_rate - time_step * demand_profile[t]\n```\n",
        "description": "Markdown file from Model Predictive Control for Continuous Cellulose Fiber Production Using Python.md",
        "path": "Reference Solutions/Advanced Process Control/Model Predictive Control for Continuous Cellulose Fiber Production Using Python.md"
    },
    {
        "filename": "Model Predictive Control for HVAC System Optimization Using C++.md",
        "content": "```\n#include <iostream>\n#include <vector>\n\n// Simplified HVAC system model\nclass HVACModel {\npublic:\n    HVACModel(double initTemp, double initHumid, double extTemp, double occLevel)\n        : temp(initTemp), humidity(initHumid), externalTemp(extTemp), occupancyLevel(occLevel) {}\n\n    // Update the state of the HVAC system\n    void update(double heatPower, double coolPower, double humidPower, double dehumidPower) {\n        // Simplified dynamics model\n        temp += heatPower - coolPower + externalTemp * 0.1;\n        humidity += humidPower - dehumidPower + occupancyLevel * 0.05;\n    }\n\n    // Get current state\n    std::pair<double, double> getState() const {\n        return std::make_pair(temp, humidity);\n    }\n\nprivate:\n    double temp;          // Current temperature\n    double humidity;      // Current humidity\n    double externalTemp;  // External temperature\n    double occupancyLevel;// Occupancy level\n};\n#include <Eigen/Dense> // For matrix operations\n#include <unsupported/Eigen/MatrixFunctions> // For exponential matrix\n\nusing namespace Eigen;\n\nclass MPC {\npublic:\n    MPC(const MatrixXd& A, const MatrixXd& B, int predictionHorizon, int controlHorizon)\n        : A(A), B(B), N(predictionHorizon), M(controlHorizon) {}\n\n    // Solve the MPC problem\n    VectorXd solveMPC(const VectorXd& x, const VectorXd& r) {\n        // Simplified QP formulation\n        // This is a placeholder for the actual QP solver call\n        // In practice, you'd use a library like qpOASES or OSQP\n        VectorXd u(N); // Placeholder solution\n        return u;\n    }\n\nprivate:\n    MatrixXd A, B; // System matrices\n    int N, M;      // Prediction and control horizons\n};\nint main() {\n    // Initial conditions\n    double initTemp = 22.0; // Initial temperature in degrees Celsius\n    double initHumid = 50.0; // Initial humidity in percentage\n    double extTemp = 25.0; // External temperature\n    double occLevel = 0.5; // Occupancy level\n\n    // Create HVAC model\n    HVACModel hvac(initTemp, initHumid, extTemp, occLevel);\n\n    // Define system matrices (simplified)\n    MatrixXd A(2, 2);\n    A << 1.0, 0.0,\n         0.0, 1.0;\n    MatrixXd B(2, 4);\n    B << 1.0, -1.0, 0.0, 0.0,\n         0.0, 0.0, 1.0, -1.0;\n\n    // Create MPC controller\n    MPC mpc(A, B, 10, 3);\n\n    // Simulation parameters\n    int numSteps = 100; // Number of simulation steps\n    double dt = 0.1; // Time step\n\n    // Simulation loop\n    for (int t = 0; t < numSteps; ++t) {\n        // Get current state\n        auto state = hvac.getState();\n        VectorXd x(2);\n        x << state.first, state.second;\n\n        // Reference values (desired temperature and humidity)\n        VectorXd r(2);\n        r << 23.0, 45.0;\n\n        // Solve MPC\n        VectorXd u = mpc.solveMPC(x, r);\n\n        // Update HVAC system\n        hvac.update(u(0), u(1), u(2), u(3));\n\n        // Print current state\n        std::cout << \"Step: \" << t << \", Temp: \" << state.first << \", Humidity: \" << state.second << std::endl;\n    }\n\n    return 0;\n}\n```\n",
        "description": "Markdown file from Model Predictive Control for HVAC System Optimization Using C++.md",
        "path": "Reference Solutions/Advanced Process Control/Model Predictive Control for HVAC System Optimization Using C++.md"
    },
    {
        "filename": "Model Predictive Control for Optimizing Robot Movement Using Python.md",
        "content": "```\nimport numpy as np\nfrom scipy.optimize import minimize\nimport cvxpy as cp\n\n# Robot dynamics model (unicycle model)\ndef robot_dynamics(x, u, dt):\n    \"\"\"\n    Simple unicycle dynamics model.\n    x = [x_pos, y_pos, theta]\n    u = [v, omega]\n    \"\"\"\n    x_next = np.copy(x)\n    x_next[0] += u[0] * np.cos(x[2]) * dt\n    x_next[1] += u[0] * np.sin(x[2]) * dt\n    x_next[2] += u[1] * dt\n    return x_next\n# Define the objective function\ndef objective_function(u, *args):\n    x, goal, dt, Q, R = args\n    x_traj = np.copy(x)\n    cost = 0.0\n    for i in range(len(u)//2):\n        x_traj = robot_dynamics(x_traj, u[i*2:i*2+2], dt)\n        cost += (Q @ (x_traj[:2] - goal[:2])) @ (x_traj[:2] - goal[:2])\n        cost += R @ u[i*2:i*2+2] @ u[i*2:i*2+2].T\n    return cost\n\n# Define the MPC problem using CVXPY\ndef mpc_controller(x, goal, obstacles, dt, N, Q, R, v_max, omega_max):\n    # Variables\n    u = cp.Variable((2, N))\n    x_pred = cp.Parameter((3, N+1))\n    x_pred.value = np.tile(x, (N+1, 1)).T\n    \n    # Constraints\n    constraints = []\n    for t in range(N):\n        x_pred[:, t+1] = robot_dynamics(x_pred[:, t], u[:, t], dt)\n        constraints += [cp.norm_inf(u[:, t]) <= v_max,\n                        cp.norm_inf(u[:, t][1]) <= omega_max]\n        # Add obstacle avoidance constraints\n        for obs in obstacles:\n            constraints += [cp.square(x_pred[0, t+1] - obs[0]) + \n                            cp.square(x_pred[1, t+1] - obs[1]) >= obs[2]**2]\n    \n    # Objective\n    obj = cp.Minimize(Q @ cp.sum_squares(x_pred[:2, :] - goal) + R @ cp.sum_squares(u))\n    \n    # Problem definition\n    prob = cp.Problem(obj, constraints)\n    \n    # Solve the optimization problem\n    prob.solve(solver=cp.OSQP)\n    \n    return u.value[:, 0]\n# Simulation parameters\ndt = 0.1  # Time step\nN = 20  # Prediction horizon\nQ = np.eye(2)  # State cost matrix\nR = np.eye(2)  # Input cost matrix\nv_max = 1.0  # Max velocity\nomega_max = np.pi / 4  # Max angular velocity\n\n# Initial conditions\nx_init = np.array([0.0, 0.0, 0.0])  # [x, y, theta]\ngoal = np.array([5.0, 5.0])  # Goal position\nobstacles = [(2.5, 2.5, 0.5)]  # Obstacle positions and radii\n\n# Simulation loop\nx = x_init\ntrajectory = [x[:2]]\nfor t in range(100):\n    # Apply MPC controller\n    u_opt = mpc_controller(x, goal, obstacles, dt, N, Q, R, v_max, omega_max)\n    \n    # Update the state\n    x = robot_dynamics(x, u_opt, dt)\n    \n    # Save the state for plotting\n    trajectory.append(x[:2])\n    \n    # Check if goal reached\n    if np.linalg.norm(x[:2] - goal) < 0.1:\n        break\n\n# Print the trajectory\nprint(\"Trajectory:\", trajectory)\n```\n",
        "description": "Markdown file from Model Predictive Control for Optimizing Robot Movement Using Python.md",
        "path": "Reference Solutions/Advanced Process Control/Model Predictive Control for Optimizing Robot Movement Using Python.md"
    },
    {
        "filename": "Model Predictive Control for Turbine Optimization in a Thermal Power Plant Using Python.md",
        "content": "```\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport cvxpy as cp\n\n# Define the turbine dynamics\ndef turbine_dynamics(t, state, u):\n    # State variables: [temperature, pressure]\n    T, P = state\n    # Control input: steam flow rate\n    F = u\n    # Parameters\n    alpha = 0.01  # Heat transfer coefficient\n    beta = 0.001  # Pressure change coefficient\n    dTdt = alpha * F - 0.05 * (T - 300)  # Heat transfer equation\n    dPdt = beta * F - 0.005 * P  # Pressure change equation\n    return [dTdt, dPdt]\n\n# Initial conditions\nT0 = 400  # Initial temperature in Kelvin\nP0 = 100  # Initial pressure in bar\nstate0 = [T0, P0]\n# MPC parameters\nN = 10  # Prediction horizon\ndt = 1  # Time step in seconds\nQ = np.diag([1, 1])  # State cost matrix\nR = 1  # Control cost matrix\n\n# Define MPC problem\ndef mpc_controller(T, P, T_ref, P_ref):\n    # States and controls\n    T_pred = cp.Variable(N)\n    P_pred = cp.Variable(N)\n    F = cp.Variable(N)  # Control input (steam flow rate)\n\n    # Initial conditions\n    T_pred[0] = T\n    P_pred[0] = P\n\n    # Constraints\n    constraints = [0 <= F, F <= 1000]  # Steam flow rate limits\n\n    # Dynamics constraints\n    for k in range(N-1):\n        sol = solve_ivp(lambda t, y: turbine_dynamics(t, y, F[k]), [k*dt, (k+1)*dt], [T_pred[k], P_pred[k]])\n        T_pred[k+1] = sol.y[0][-1]\n        P_pred[k+1] = sol.y[1][-1]\n        constraints += [sol.y[0][-1] >= 300, sol.y[0][-1] <= 600]  # Temperature limits\n        constraints += [sol.y[1][-1] >= 50, sol.y[1][-1] <= 150]  # Pressure limits\n\n    # Objective function\n    obj = cp.sum(Q @ cp.vstack((T_pred - T_ref, P_pred - P_ref))**2) + R * cp.sum(F**2)\n\n    # Problem definition\n    prob = cp.Problem(cp.Minimize(obj), constraints)\n\n    # Solve the optimization problem\n    prob.solve()\n\n    # Return the first control input\n    return F.value[0]\n# Simulation parameters\ntotal_time = 100  # Total simulation time in seconds\nload_changes = [0, 50, 20, 70]  # Load changes at different times\nload_times = [0, 20, 50, 80]  # Times when load changes occur\n\n# Simulation loop\ntimes = np.arange(0, total_time, dt)\nT_history = np.zeros_like(times)\nP_history = np.zeros_like(times)\nF_history = np.zeros_like(times)\nT_ref = 450  # Reference temperature\nP_ref = 120  # Reference pressure\n\nfor i, t in enumerate(times):\n    # Determine current load\n    if t >= load_times[0]:\n        T_ref = load_changes[0]\n    if t >= load_times[1]:\n        T_ref = load_changes[1]\n    if t >= load_times[2]:\n        T_ref = load_changes[2]\n    if t >= load_times[3]:\n        T_ref = load_changes[3]\n    \n    # Apply MPC controller\n    F = mpc_controller(T0, P0, T_ref, P_ref)\n    \n    # Update the state using the dynamics model\n    sol = solve_ivp(lambda t, y: turbine_dynamics(t, y, F), [t, t+dt], [T0, P0])\n    T0, P0 = sol.y[:, -1]\n    \n    # Save the state and control input for plotting\n    T_history[i] = T0\n    P_history[i] = P0\n    F_history[i] = F\n\n# Plot the results\nimport matplotlib.pyplot as plt\n\nplt.figure()\nplt.subplot(2, 1, 1)\nplt.plot(times, T_history, label=\"Temperature\")\nplt.plot(times, np.full_like(times, T_ref), '--', label=\"Reference Temperature\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Temperature (K)\")\nplt.legend()\n\nplt.subplot(2, 1, 2)\nplt.plot(times, F_history, label=\"Steam Flow Rate\")\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Flow Rate\")\nplt.legend()\n\nplt.tight_layout()\nplt.show()\n```\n",
        "description": "Markdown file from Model Predictive Control for Turbine Optimization in a Thermal Power Plant Using Python.md",
        "path": "Reference Solutions/Advanced Process Control/Model Predictive Control for Turbine Optimization in a Thermal Power Plant Using Python.md"
    },
    {
        "filename": "Model Predictive Control for Wind Farm Optimization Using C++.md",
        "content": "```\n#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Define the wind turbine dynamics\nstruct WindTurbine {\n    double wind_speed; // Current wind speed\n    double pitch_angle; // Current pitch angle of the blades\n    double power_output; // Current power output\n\n    // Constructor\n    WindTurbine(double ws, double pa, double po) : wind_speed(ws), pitch_angle(pa), power_output(po) {}\n\n    // Update the turbine based on new wind speed and pitch angle\n    void update(double new_ws, double new_pa) {\n        wind_speed = new_ws;\n        pitch_angle = new_pa;\n        // Simplified power output calculation\n        power_output = std::max(0.0, std::min(1000.0, 500.0 * wind_speed * wind_speed * std::sin(pitch_angle)));\n    }\n};\n\n// Wind farm dynamics model\nclass WindFarm {\npublic:\n    std::vector<WindTurbine> turbines; // List of turbines\n\n    // Constructor\n    WindFarm(std::vector<double> ws, std::vector<double> pa, std::vector<double> po) {\n        for (size_t i = 0; i < ws.size(); ++i) {\n            turbines.emplace_back(ws[i], pa[i], po[i]);\n        }\n    }\n\n    // Update all turbines based on new wind speeds and pitch angles\n    void update(const std::vector<double>& new_ws, const std::vector<double>& new_pa) {\n        for (size_t i = 0; i < turbines.size(); ++i) {\n            turbines[i].update(new_ws[i], new_pa[i]);\n        }\n    }\n\n    // Get the total power output of the wind farm\n    double getTotalPowerOutput() const {\n        double total_power = 0.0;\n        for (const auto& turbine : turbines) {\n            total_power += turbine.power_output;\n        }\n        return total_power;\n    }\n};\n#include <Eigen/Dense>\nusing Eigen::VectorXd;\n\n// MPC solver function\nVectorXd solveMPC(const WindFarm& wind_farm, const std::vector<double>& wind_forecast, int prediction_horizon, int control_horizon) {\n    // Initialize the pitch angles vector\n    VectorXd pitch_angles(wind_farm.turbines.size());\n    pitch_angles.setZero();\n\n    // TODO: Implement the MPC optimization logic here\n    // This is a placeholder for the actual MPC solver\n\n    return pitch_angles;\n}\n\n// Update the wind farm based on MPC solution\nvoid updateWindFarm(WindFarm& wind_farm, const VectorXd& pitch_angles) {\n    for (size_t i = 0; i < wind_farm.turbines.size(); ++i) {\n        wind_farm.turbines[i].pitch_angle = pitch_angles(i);\n    }\n}\n\n// Simulation loop\nvoid simulateWindFarm(WindFarm& wind_farm, const std::vector<std::vector<double>>& wind_forecasts, int prediction_horizon, int control_horizon) {\n    int num_steps = static_cast<int>(wind_forecasts.size());\n\n    for (int t = 0; t < num_steps; ++t) {\n        // Get the forecasted wind speeds for the current time step\n        const auto& forecast = wind_forecasts[t];\n\n        // Solve the MPC problem\n        VectorXd pitch_angles = solveMPC(wind_farm, forecast, prediction_horizon, control_horizon);\n\n        // Update the wind farm with the new pitch angles\n        updateWindFarm(wind_farm, pitch_angles);\n\n        // Simulate the wind farm dynamics for one time step\n        wind_farm.update(forecast, pitch_angles);\n\n        // Output the total power output for the current time step\n        std::cout << \"Time step: \" << t << \", Total power output: \" << wind_farm.getTotalPowerOutput() << std::endl;\n    }\n}\n#include <vector>\n\nint main() {\n    // Initialize wind farm with initial conditions\n    std::vector<double> initial_wind_speeds = {10.0, 12.0, 8.0}; // Wind speeds for each turbine\n    std::vector<double> initial_pitch_angles = {0.0, 0.0, 0.0}; // Initial pitch angles\n    std::vector<double> initial_power_outputs = {0.0, 0.0, 0.0}; // Initial power outputs\n\n    WindFarm wind_farm(initial_wind_speeds, initial_pitch_angles, initial_power_outputs);\n\n    // Wind speed forecasts for each time step\n    std::vector<std::vector<double>> wind_forecasts = {\n        {10.0, 12.0, 8.0},\n        {11.0, 13.0, 9.0},\n        {12.0, 14.0, 10.0},\n        // More forecasts...\n    };\n\n    // MPC parameters\n    int prediction_horizon = 10; // Prediction horizon\n    int control_horizon = 5; // Control horizon\n\n    // Run the simulation\n    simulateWindFarm(wind_farm, wind_forecasts, prediction_horizon, control_horizon);\n\n    return 0;\n}\n```\n",
        "description": "Markdown file from Model Predictive Control for Wind Farm Optimization Using C++.md",
        "path": "Reference Solutions/Advanced Process Control/Model Predictive Control for Wind Farm Optimization Using C++.md"
    },
    {
        "filename": "Statistical Process Control for Steel Manufacturing Using Python.md",
        "content": "```\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom statsmodels.stats.weightstats import zconfint\n\nnp.random.seed(42)\n\n# Generate synthetic data\ndata_points = 100\ntensile_strength = np.random.normal(loc=500, scale=50, size=data_points)  # Tensile strength in MPa\nthickness = np.random.normal(loc=1.5, scale=0.1, size=data_points)  # Thickness in mm\nsurface_finish = np.random.normal(loc=0.5, scale=0.05, size=data_points)  # Surface finish in \u03bcm\n\n# Introduce some out-of-control conditions\ntensile_strength[20:30] += 100  # Increase tensile strength for samples 20 to 30\nthickness[50:60] -= 0.3  # Decrease thickness for samples 50 to 60\nsurface_finish[70:80] += 0.2  # Increase surface finish for samples 70 to 80\n\n# Combine into a DataFrame\ndf = pd.DataFrame({\n    'Tensile_Strength': tensile_strength,\n    'Thickness': thickness,\n    'Surface_Finish': surface_finish\n})\ndef create_control_chart(data, title, unit='units'):\n    mean = data.mean()\n    std_dev = data.std(ddof=0)  # Population standard deviation\n    upper_control_limit = mean + 3 * std_dev\n    lower_control_limit = mean - 3 * std_dev\n\n    plt.figure(figsize=(10, 6))\n    plt.plot(data.index, data.values, 'b-', label='Data')\n    plt.axhline(y=mean, color='r', linestyle='--', label='Mean')\n    plt.axhline(y=upper_control_limit, color='g', linestyle='--', label='UCL')\n    plt.axhline(y=lower_control_limit, color='g', linestyle='--', label='LCL')\n    plt.title(title)\n    plt.xlabel('Sample Index')\n    plt.ylabel(f'{unit}')\n    plt.legend()\n    plt.show()\n\n    return mean, upper_control_limit, lower_control_limit\n\n# Create control charts\ncreate_control_chart(df['Tensile_Strength'], 'Control Chart for Tensile Strength', 'MPa')\ncreate_control_chart(df['Thickness'], 'Control Chart for Thickness', 'mm')\ncreate_control_chart(df['Surface_Finish'], 'Control Chart for Surface Finish', '\u03bcm')\ndef check_out_of_control(data, mean, upper_control_limit, lower_control_limit):\n    is_out_of_control = (data > upper_control_limit) | (data < lower_control_limit)\n    return is_out_of_control\n\n# Check for out-of-control conditions\ntensile_strength_ucl, tensile_strength_lcl = create_control_chart(df['Tensile_Strength'], 'Control Chart for Tensile Strength', 'MPa')[:2]\nthickness_ucl, thickness_lcl = create_control_chart(df['Thickness'], 'Control Chart for Thickness', 'mm')[:2]\nsurface_finish_ucl, surface_finish_lcl = create_control_chart(df['Surface_Finish'], 'Control Chart for Surface Finish', '\u03bcm')[:2]\n\nout_of_control_tensile = check_out_of_control(df['Tensile_Strength'], tensile_strength_ucl, tensile_strength_lcl)\nout_of_control_thickness = check_out_of_control(df['Thickness'], thickness_ucl, thickness_lcl)\nout_of_control_surface = check_out_of_control(df['Surface_Finish'], surface_finish_ucl, surface_finish_lcl)\n\n# Alert when out-of-control conditions are detected\nif out_of_control_tensile.any():\n    print(\"ALERT: Tensile strength is out of control.\")\nif out_of_control_thickness.any():\n    print(\"ALERT: Thickness is out of control.\")\nif out_of_control_surface.any():\n    print(\"ALERT: Surface finish is out of control.\")\ndef suggest_corrective_action(out_of_control, metric_name):\n    if out_of_control.any():\n        print(f\"RECOMMENDATION FOR {metric_name}:\")\n        if out_of_control[20:30].all():  # Example assumption for tensile strength\n            print(\"Adjust the alloy composition to improve tensile strength.\")\n        elif out_of_control[50:60].all():  # Example assumption for thickness\n            print(\"Check the rolling mill settings to correct thickness issues.\")\n        elif out_of_control[70:80].all():  # Example assumption for surface finish\n            print(\"Inspect the polishing equipment to reduce surface roughness.\")\n\nsuggest_corrective_action(out_of_control_tensile, 'Tensile Strength')\nsuggest_corrective_action(out_of_control_thickness, 'Thickness')\nsuggest_corrective_action(out_of_control_surface, 'Surface Finish')\n```\n",
        "description": "Markdown file from Statistical Process Control for Steel Manufacturing Using Python.md",
        "path": "Reference Solutions/Advanced Process Control/Statistical Process Control for Steel Manufacturing Using Python.md"
    },
    {
        "filename": "CANOpen PDO Registration Using 61131-3 Structured Text.md",
        "content": "```\nFUNCTION_BLOCK CAN_REGISTER_COBID\nVAR_INPUT\n    REGISTER : BOOL; (* TRUE to register, FALSE to unregister *)\n    COBID : USINT; (* CAN identifier *)\nVAR_OUTPUT\n    REGISTERED : BOOL;\n    ERROR : BOOL;\nVAR\n    BUFFER : ARRAY [0..100] OF BYTE := {100{0}}; (* Example buffer size *)\n    BUFFER_SIZE : USINT := 0;\n    BUFFER_INDEX : USINT := 0;\n    REGISTERED_IDS : ARRAY [0..100] OF USINT := {100{0}}; (* Track registered COBIDs *)\n    REGISTERED_COUNT : USINT := 0;\nEND_VAR\n\n(* Register COBID *)\nIF REGISTER THEN\n    IF COBID <> 0 THEN\n        (* Check if COBID is already registered *)\n        FOR i := 0 TO REGISTERED_COUNT LOOP\n            IF REGISTERED_IDS[i] = COBID THEN\n                REGISTERED := TRUE;\n                EXIT;\n            END_IF\n        END_FOR\n        \n        (* Register new COBID *)\n        IF REGISTERED_COUNT < 100 THEN\n            REGISTERED_IDS[REGISTERED_COUNT] := COBID;\n            REGISTERED_COUNT := REGISTERED_COUNT + 1;\n            REGISTERED := TRUE;\n        ELSE\n            ERROR := TRUE;\n        END_IF\n    ELSE\n        ERROR := TRUE; (* Invalid COBID value *)\n    END_IF\nELSIF NOT REGISTER THEN\n    IF COBID = 0 THEN\n        (* Clear all registered COBIDs and buffer *)\n        REGISTERED_COUNT := 0;\n        BUFFER_INDEX := 0;\n        BUFFER_SIZE := 0;\n        BUFFER := {100{0}};\n        REGISTERED := TRUE;\n    ELSE\n        (* Unregister COBID *)\n        FOR i := 0 TO REGISTERED_COUNT LOOP\n            IF REGISTERED_IDS[i] = COBID THEN\n                REGISTERED_IDS[i] := 0;\n                REGISTERED := TRUE;\n                EXIT;\n            END_IF\n        END_FOR\n    END_IF\nEND_IF\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from CANOpen PDO Registration Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/CANOpen PDO Registration Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Communication Monitoring for OPC UA, Modbus, and Profinet Using IEC 61131-3 Structured Text.md",
        "content": "```\nFUNCTION_BLOCK COMM_MONITOR\nVAR_INPUT\n    COMM_TYPE : COMM_TYPE_ENUM;\n    ALARM_TRIGGERED : BOOL;\n    LOG_ENTRY : STRING;\nVAR_OUTPUT\n    IS_CONNECTED : BOOL;\n    ERROR_OCCURRED : BOOL;\n    ERROR_CODE : INT;\nVAR\n    LAST_CONNECTION_CHECK : TIME;\n    CHECK_INTERVAL : TIME := T#1S; (* Adjust interval as needed *)\n    AUDIT_TRAIL : ARRAY [0..100] OF STRUCT TIMESTAMP : TIME; STATUS : BOOL; ERROR : STRING; END_STRUCT;\n    AUDIT_TRAIL_INDEX : INT := 0;\nEND_VAR\n\n(* Poll Connection *)\nIF T#1S > T#0S AND T#1S > LAST_CONNECTION_CHECK THEN\n    LAST_CONNECTION_CHECK := T#1S;\n    CASE COMM_TYPE OF\n        OPC_UA:\n            IS_CONNECTED := CHECK_OPC_UA_CONNECTION();\n            IF NOT IS_CONNECTED THEN ERROR_OCCURRED := TRUE; ERROR_CODE := GET_OPC_UA_ERROR_CODE(); END_IF\n        MODBUS:\n            IS_CONNECTED := CHECK_MODBUS_CONNECTION();\n            IF NOT IS_CONNECTED THEN ERROR_OCCURRED := TRUE; ERROR_CODE := GET_MODBUS_ERROR_CODE(); END_IF\n        PROFINET:\n            IS_CONNECTED := CHECK_PROFINET_CONNECTION();\n            IF NOT IS_CONNECTED THEN ERROR_OCCURRED := TRUE; ERROR_CODE := GET_PROFINET_ERROR_CODE(); END_IF\n    END_CASE\n    \n    (* Log Status *)\n    AUDIT_TRAIL[AUDIT_TRAIL_INDEX].TIMESTAMP := T#1S;\n    AUDIT_TRAIL[AUDIT_TRAIL_INDEX].STATUS := IS_CONNECTED;\n    AUDIT_TRAIL[AUDIT_TRAIL_INDEX].ERROR := LOG_ENTRY;\n    AUDIT_TRAIL_INDEX := (AUDIT_TRAIL_INDEX + 1) MOD 101; (* Circular buffer *)\nEND_IF\n\n(* Trigger Alarm *)\nIF ERROR_OCCURRED AND NOT ALARM_TRIGGERED THEN\n    ALARM_TRIGGERED := TRUE;\n    (* Send alarm notification *)\nEND_IF\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Communication Monitoring for OPC UA, Modbus, and Profinet Using IEC 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/Communication Monitoring for OPC UA, Modbus, and Profinet Using IEC 61131-3 Structured Text.md"
    },
    {
        "filename": "EtherCAT State Machine Control Using IEC 61131-3 Structured Text.md",
        "content": "```\nPROGRAM EtherCATStateMachineControl\nVAR\n    // Timer variables\n    TimerInitPreop : TON; // Timer from INIT to PREOP\n    TimerPreopSafeop : TON; // Timer from PREOP to SAFEOP\n    TimerSafeopOp : TON; // Timer from SAFEOP to OP\n    \n    // State variables\n    CurrentState : ('INIT', 'PREOP', 'SAFEOP', 'OP');\n    \n    // Flags for state transitions\n    TransitionInitToPreop : BOOL := FALSE;\n    TransitionPreopToSafeop : BOOL := FALSE;\n    TransitionSafeopToOp : BOOL := FALSE;\n    \n    // Error handling\n    ErrorOccurred : BOOL := FALSE;\nBEGIN\n    // Initial state\n    CurrentState := 'INIT';\n    \n    // Handle state transitions\n    CASE CurrentState OF\n        'INIT':\n            TimerInitPreop(IN := TRUE, PT := T#5s);\n            IF TimerInitPreOp.Q THEN\n                TransitionInitToPreop := TRUE;\n            END_IF\n            \n        'PREOP':\n            TimerPreopSafeop(IN := TRUE, PT := T#5s);\n            IF TimerPreopSafeop.Q THEN\n                TransitionPreopToSafeop := TRUE;\n            END_IF\n            \n        'SAFEOP':\n            TimerSafeopOp(IN := TRUE, PT := T#5s);\n            IF TimerSafeopOp.Q THEN\n                TransitionSafeopToOp := TRUE;\n            END_IF\n            \n        'OP':\n            // In OP state, no further transition planned\n            // Implement operational logic here\n    END_CASE\n    \n    // Transition logic\n    IF TransitionInitToPreop THEN\n        CurrentState := 'PREOP';\n        TransitionInitToPreop := FALSE;\n    END_IF\n    \n    IF TransitionPreopToSafeop THEN\n        CurrentState := 'SAFEOP';\n        TransitionPreopToSafeop := FALSE;\n    END_IF\n    \n    IF TransitionSafeopToOp THEN\n        CurrentState := 'OP';\n        TransitionSafeopToOp := FALSE;\n    END_IF\n    \n    // Error handling\n    IF ErrorOccurred THEN\n        // Implement error recovery or logging here\n    END_IF\n    \nEND_PROGRAM\n```\n",
        "description": "Markdown file from EtherCAT State Machine Control Using IEC 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/EtherCAT State Machine Control Using IEC 61131-3 Structured Text.md"
    },
    {
        "filename": "Ethernet PowerLink Diagnostics Using IEC 61131-3 Structured Text.md",
        "content": "```\nFUNCTION_BLOCK ETH_POWERLINK_DIAGNOSTICS\nVAR_INPUT\n    MN_ADDRESS : UINT;\n    NODE_ID : UINT;\nVAR_OUTPUT\n    COMMUNICATION_STATUS : BOOL;\n    ERROR_CODE : UINT;\n    HEALTH_STATUS : BOOL;\n    DIAGNOSTIC_INFO : STRING;\nVAR\n    DIAGNOSTIC_REQUEST : BOOL := FALSE;\n    DIAGNOSTIC_RESPONSE_RECEIVED : BOOL := FALSE;\n    DIAGNOSTIC_RESPONSE : STRUCT\n        COMMUNICATION_STATUS : BOOL;\n        ERROR_CODE : UINT;\n        HEALTH_STATUS : BOOL;\n        INFO : STRING;\n    END_STRUCT;\n    ERROR_LOG : ARRAY [0..100] OF STRUCT TIME : TIME; ERROR_CODE : UINT; MESSAGE : STRING; END_STRUCT;\n    DIAGNOSTIC_INTERVAL : TIME := T#5s;\n    TIMER : TON;\nEND_VAR\n\n// Initialize timer for periodic diagnostics\nTIMER(IN := TRUE, PT := DIAGNOSTIC_INTERVAL);\n\n// Request diagnostics every DIAGNOSTIC_INTERVAL\nIF TIMER.Q THEN\n    DIAGNOSTIC_REQUEST := TRUE;\n    TIMER(IN := FALSE); // Reset timer after request\nEND_IF\n\n// Send diagnostic request to MN\nIF DIAGNOSTIC_REQUEST THEN\n    SEND_DIAGNOSTIC_REQUEST(MN_ADDRESS, NODE_ID);\n    DIAGNOSTIC_REQUEST := FALSE;\nEND_IF\n\n// Receive diagnostic response from MN\nIF DIAGNOSTIC_RESPONSE_RECEIVED THEN\n    COMMUNICATION_STATUS := DIAGNOSTIC_RESPONSE.COMMUNICATION_STATUS;\n    ERROR_CODE := DIAGNOSTIC_RESPONSE.ERROR_CODE;\n    HEALTH_STATUS := DIAGNOSTIC_RESPONSE.HEALTH_STATUS;\n    DIAGNOSTIC_INFO := DIAGNOSTIC_RESPONSE.INFO;\n    \n    // Log error if present\n    IF ERROR_CODE > 0 THEN\n        ERROR_LOG[0].TIME := T#NOW;\n        ERROR_LOG[0].ERROR_CODE := ERROR_CODE;\n        ERROR_LOG[0].MESSAGE := DIAGNOSTIC_INFO;\n        \n        // Shift older logs\n        FOR i := 99 Downto 1 LOOP\n            ERROR_LOG[i] := ERROR_LOG[i-1];\n        END_FOR\n    END_IF\n    \n    DIAGNOSTIC_RESPONSE_RECEIVED := FALSE;\nEND_IF\n\n// Reset timer if communication fails\nIF NOT COMMUNICATION_STATUS THEN\n    TIMER(IN := TRUE);\nEND_IF\n\n// Example pseudo-functions for demonstration\nPROCEDURE SEND_DIAGNOSTIC_REQUEST(MN_ADDR : UINT; NODE_ID : UINT)\n    // Actual implementation depends on the PowerLink library used\n    // This function sends a request to the MN to get diagnostics from the specified node\nEND_PROC\n\nPROCEDURE RECEIVE_DIAGNOSTIC_RESPONSE(DIAG_RESP : REFERENCE TO STRUCT)\n    // Actual implementation depends on the PowerLink library used\n    // This function receives the diagnostic response from the MN and populates the DIAG_RESP structure\n    DIAG_RESP.COMMUNICATION_STATUS := TRUE;\n    DIAG_RESP.ERROR_CODE := 0;\n    DIAG_RESP.HEALTH_STATUS := TRUE;\n    DIAG_RESP.INFO := \"Node is healthy.\";\nEND_PROC\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Ethernet PowerLink Diagnostics Using IEC 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/Ethernet PowerLink Diagnostics Using IEC 61131-3 Structured Text.md"
    },
    {
        "filename": "IO-Link Data Acquisition Using 61131-3 Structured Text.md",
        "content": "```\nFUNCTION_BLOCK IO_LINK_DATA_ACQUISITION\nVAR_INPUT\n    MASTER_ADDRESS : UINT;\n    DEVICE_ADDRESSES : ARRAY [0..4] OF UINT;\nVAR_OUTPUT\n    VALUES : ARRAY [0..4] OF ANY;\n    READ_STATUS : ARRAY [0..4] OF BOOLEAN;\n    ERROR_OCCURRED : BOOLEAN;\nVAR\n    READ_REQUESTS : ARRAY [0..4] OF BOOLEAN := {5{FALSE}};\n    READ_RESPONSES : ARRAY [0..4] OF BOOLEAN := {5{FALSE}};\n    COMMUNICATION_TIMEOUT : TIME := T#5s; // Timeout for waiting for a response\n    COMMUNICATION_INTERVAL : TIME := T#1s; // Interval for retry attempts\n    TIMER : TON;\nEND_VAR\n\n// Initialize timers\nFOR i := 0 TO 4 LOOP\n    TIMER[i].IN := TRUE;\n    TIMER[i].PT := COMMUNICATION_TIMEOUT;\nEND_FOR\n\n// Send read requests and handle responses\nFOR i := 0 TO 4 LOOP\n    IF NOT READ_REQUESTS[i] THEN\n        SEND_IO_LINK_READ_REQUEST(MASTER_ADDRESS, DEVICE_ADDRESSES[i]);\n        READ_REQUESTS[i] := TRUE;\n        TIMER[i].IN := TRUE; // Start timer for response\n    END_IF\n    \n    // Check if response is received or timed out\n    IF TIMER[i].Q THEN\n        // Check if response has been received\n        IF NOT READ_RESPONSES[i] THEN\n            ERROR_OCCURRED := TRUE;\n            READ_STATUS[i] := FALSE;\n        ELSE\n            VALUES[i] := RECEIVE_IO_LINK_READ_RESPONSE(MASTER_ADDRESS, DEVICE_ADDRESSES[i]);\n            READ_STATUS[i] := TRUE;\n            ERROR_OCCURRED := FALSE;\n        END_IF\n        READ_REQUESTS[i] := FALSE;\n        READ_RESPONSES[i] := FALSE;\n    END_IF\nEND_FOR\n\n// Example pseudo-functions for demonstration\nPROCEDURE SEND_IO_LINK_READ_REQUEST(MASTER_ADDR : UINT; DEVICE_ADDR : UINT)\n    // Actual implementation depends on the IO-Link library used\n    // This function sends a read request to the IO-Link master for the specified device\nEND_PROC\n\nPROCEDURE RECEIVE_IO_LINK_READ_RESPONSE(MASTER_ADDR : UINT; DEVICE_ADDR : UINT)\n    // Actual implementation depends on the IO-Link library used\n    // This function receives the read response from the IO-Link master for the specified device\n    RETURN : ANY;\nEND_PROC\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from IO-Link Data Acquisition Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/IO-Link Data Acquisition Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Modbus Server for Parallel Client Connections using 61131-3 Structured Text.md",
        "content": "```\nFUNCTION_BLOCK MODBUS_SERVER\nVAR_INPUT\n    MAX_CONNECTIONS : UINT := 10;\n    MODBUS_SERVER_IP : STRING := \"YOUR_IP_ADDRESS\";\n    MODBUS_SERVER_PORT : UINT := 502;\nVAR_OUTPUT\n    CONNECTIONS_ACTIVE : ARRAY [0..9] OF BOOLEAN;\n    ERROR_OCCURRED : BOOLEAN;\n    LOG : ARRAY [0..100] OF STRING;\nVAR\n    CONNECTIONS : ARRAY [0..9] OF STRUCT\n        CLIENT_IP : STRING;\n        FUNCTION_CODE : UINT;\n        DATA : ANY;\n        RESPONSE_READY : BOOLEAN;\n    END_STRUCT;\n    COILS : ARRAY [0..1023] OF BOOLEAN;\n    DISCRETE_INPUTS : ARRAY [0..1023] OF BOOLEAN;\n    HOLDING_REGISTERS : ARRAY [0..32767] OF UINT;\n    INPUT_REGISTERS : ARRAY [0..32767] OF UINT;\n    BUFFER : BYTE_STRING;\n    BUFFER_SIZE : UINT;\n    BUFFER_POS : UINT;\n    SOCKET : ANY; // Placeholder for socket object\nEND_VAR\n\n// Initialize server socket\nSOCKET := INIT_MODBUS_SERVER(MODBUS_SERVER_IP, MODBUS_SERVER_PORT);\n\n// Main loop to handle connections\nWHILE TRUE DO\n    FOR i := 0 TO MAX_CONNECTIONS - 1 DO\n        IF NOT CONNECTIONS_ACTIVE[i] THEN\n            // Accept a new connection\n            CONNECTIONS[i].CLIENT_IP := ACCEPT_CONNECTION(SOCKET);\n            CONNECTIONS_ACTIVE[i] := TRUE;\n        END_IF\n        \n        IF CONNECTIONS_ACTIVE[i] THEN\n            BUFFER_SIZE := RECEIVE_DATA(SOCKET, BUFFER);\n            BUFFER_POS := 0;\n            \n            // Parse request and get function code\n            CONNECTIONS[i].FUNCTION_CODE := PARSE_FUNCTION_CODE(BUFFER, BUFFER_POS);\n            \n            // Execute Modbus function based on function code\n            CASE CONNECTIONS[i].FUNCTION_CODE OF\n                0x01: // Read Coils\n                    EXECUTE_READ_COILS(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x02: // Read Discrete Inputs\n                    EXECUTE_READ_DISCRETE_INPUTS(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x03: // Read Holding Registers\n                    EXECUTE_READ_HOLDING_REGISTERS(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x04: // Read Input Registers\n                    EXECUTE_READ_INPUT_REGISTERS(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x05: // Write Single Coil\n                    EXECUTE_WRITE_SINGLE_COIL(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x06: // Write Single Register\n                    EXECUTE_WRITE_SINGLE_REGISTER(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x0F: // Write Multiple Coils\n                    EXECUTE_WRITE_MULTIPLE_COILS(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x10: // Write Multiple Registers\n                    EXECUTE_WRITE_MULTIPLE_REGISTERS(CONNECTIONS[i], BUFFER, BUFFER_POS);\n                0x17: // Read/Write Multiple Registers\n                    EXECUTE_READ_WRITE_MULTIPLE_REGISTERS(CONNECTIONS[i], BUFFER, BUFFER_POS);\n            END_CASE\n            \n            // Send response if ready\n            IF CONNECTIONS[i].RESPONSE_READY THEN\n                SEND_RESPONSE(SOCKET, CONNECTIONS[i].DATA);\n                CONNECTIONS_ACTIVE[i] := FALSE;\n            END_IF\n        END_IF\n    END_FOR\nEND_WHILE\n\n// Example pseudo-functions for demonstration\nPROCEDURE INIT_MODBUS_SERVER(IP : STRING; PORT : UINT)\n    // Initializes the server with the given IP and port\nEND_PROC\n\nPROCEDURE ACCEPT_CONNECTION(SOCKET : ANY) : STRING\n    // Accepts a new connection and returns the client IP\n    RETURN \"CLIENT_IP\";\nEND_PROC\n\nPROCEDURE RECEIVE_DATA(SOCKET : ANY; BUFFER : REFERENCE TO BYTE_STRING) : UINT\n    // Receives data from the client and stores it in BUFFER\n    RETURN BUFFER_SIZE;\nEND_PROC\n\nPROCEDURE PARSE_FUNCTION_CODE(BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT) : UINT\n    // Parses the function code from the buffer\n    RETURN FUNCTION_CODE;\nEND_PROC\n\nPROCEDURE EXECUTE_READ_COILS(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Read Coils function\nEND_PROC\n\nPROCEDURE EXECUTE_READ_DISCRETE_INPUTS(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Read Discrete Inputs function\nEND_PROC\n\nPROCEDURE EXECUTE_READ_HOLDING_REGISTERS(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Read Holding Registers function\nEND_PROC\n\nPROCEDURE EXECUTE_READ_INPUT_REGISTERS(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Read Input Registers function\nEND_PROC\n\nPROCEDURE EXECUTE_WRITE_SINGLE_COIL(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Write Single Coil function\nEND_PROC\n\nPROCEDURE EXECUTE_WRITE_SINGLE_REGISTER(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Write Single Register function\nEND_PROC\n\nPROCEDURE EXECUTE_WRITE_MULTIPLE_COILS(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Write Multiple Coils function\nEND_PROC\n\nPROCEDURE EXECUTE_WRITE_MULTIPLE_REGISTERS(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Write Multiple Registers function\nEND_PROC\n\nPROCEDURE EXECUTE_READ_WRITE_MULTIPLE_REGISTERS(CONNECTION : REFERENCE TO STRUCT; BUFFER : BYTE_STRING; BUFFER_POS : REFERENCE TO UINT)\n    // Executes the Read/Write Multiple Registers function\nEND_PROC\n\nPROCEDURE SEND_RESPONSE(SOCKET : ANY; RESPONSE : ANY)\n    // Sends the response back to the client\nEND_PROC\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Modbus Server for Parallel Client Connections using 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/Modbus Server for Parallel Client Connections using 61131-3 Structured Text.md"
    },
    {
        "filename": "OPC UA Client Implementation Using C and IEC 61131-3 Structured Text.md",
        "content": "```\n#include <open62541/client_high_level_common.h>\n#include <open62541/client_config_default.h>\n#include <open62541/client_subscriptions.h>\n#include <open62541/client_async_operations.h>\n#include <string.h>\n\n#define SERVER_URL_MAX_LENGTH 255\n\nUA_StatusCode connectToServer(const char *serverUrl, UA_Client *client) {\n    UA_ClientConfig_setDefault(UA_Client_getConfig(client));\n    UA_Client_setEndpointUrl(client, serverUrl);\n    return UA_Client_connect(client);\n}\n\nvoid disconnectFromServer(UA_Client *client) {\n    UA_Client_disconnect(client);\n}\n\nint main() {\n    const char *serverUrl = \"opc.tcp://localhost:4840/freeopcua/server/\";\n    UA_Client client;\n    UA_Client_init(&client);\n\n    if (connectToServer(serverUrl, &client) == UA_STATUSCODE_GOOD) {\n        // Perform operations here...\n        // For example, read a variable or browse nodes\n        // UA_Client_readValue(...)\n\n        // Disconnect when done\n        disconnectFromServer(&client);\n    } else {\n        printf(\"Failed to connect to server.\\n\");\n    }\n\n    UA_Client_delete(&client);\n    return 0;\n}\n```\n```\nFUNCTION_BLOCK OPC_UA_CLIENT\nVAR_INPUT\n    Execute : BOOL;\n    ServerUrl : STRING(255);\n    Timeout : TIME;\nVAR_OUTPUT\n    Done : BOOL;\n    Busy : BOOL;\n    Error : BOOL;\n    ErrorID : DWORD;\nVAR\n    CClient : ANY; // Placeholder for the C client object\n    OperationResult : UINT;\nEND_VAR\n\n// Initialize client only once\nIF NOT CClient.INITIALIZED THEN\n    CClient.INIT(ServerUrl);\n    CClient.INITIALIZED := TRUE;\nEND_IF\n\nIF Execute THEN\n    // Execute the operation (e.g., read variable)\n    OperationResult := CClient.EXECUTE(OperationType, VariablePath);\n    \n    IF OperationResult = UA_STATUSCODE_GOOD THEN\n        Done := TRUE;\n        Busy := FALSE;\n        Error := FALSE;\n    ELSE\n        Done := FALSE;\n        Busy := FALSE;\n        Error := TRUE;\n        ErrorID := OperationResult;\n    END_IF\nELSE\n    Done := FALSE;\n    Busy := TRUE;\n    Error := FALSE;\nEND_IF\n\n// Example pseudo-functions for demonstration\nPROCEDURE CClient_INIT(ServerURL : STRING(255))\n    // Initializes the C client with the given server URL\n    // This is a placeholder for the actual initialization logic\nEND_PROC\n\nPROCEDURE CClient_EXECUTE(OperationType : UINT; VariablePath : STRING(255)) : UINT\n    // Executes the specified operation on the OPC UA server\n    // Returns the operation result\n    RETURN UA_STATUSCODE_GOOD;\nEND_PROC\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from OPC UA Client Implementation Using C and IEC 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/OPC UA Client Implementation Using C and IEC 61131-3 Structured Text.md"
    },
    {
        "filename": "OPC UA Subscription Creation Using Open62541 and IEC 61131-3 Structured Text.md",
        "content": "```\n#include <open62541/client_high_level_common.h>\n#include <open62541/client_subscription.h>\n#include <stdlib.h>\n\n// Function prototype for the callback to handle subscription data notifications\nstatic void subscription_data_notification_callback(UA_Client *client,\n                                                    const UA_DataNotification *notification,\n                                                    void *userContext);\n\n// Function to create a subscription\nUA_StatusCode createSubscription(UA_Client *client,\n                                 UA_UInt32 *subscriptionHdl,\n                                 UA_Byte priority,\n                                 UA_TimeDuration publishingInterval,\n                                 UA_UInt32 *revisedPublishingInterval,\n                                 UA_UInt32 maxNotificationsPerPublish,\n                                 UA_Double publishingEnabledStartDelay,\n                                 UA_Boolean keepAliveCount,\n                                 UA_Boolean maxKeepAliveCount,\n                                 UA_Boolean maxLifetimeCount,\n                                 UA_Boolean maxNodesPerRead,\n                                 UA_Boolean maxNodesPerHistoryRead,\n                                 UA_Boolean maxNotificationsPerCall,\n                                 UA_UInt32 *revisedMaxNotificationsPerPublish,\n                                 UA_Byte *revisedPriority) {\n    // Create subscription\n    UA_StatusCode retval = UA_Client_CreateSubscription(\n        client,\n        publishingInterval,\n        maxNotificationsPerPublish,\n        publishingEnabledStartDelay,\n        keepAliveCount,\n        maxKeepAliveCount,\n        maxLifetimeCount,\n        maxNodesPerRead,\n        maxNodesPerHistoryRead,\n        maxNotificationsPerCall,\n        subscriptionHdl,\n        revisedPublishingInterval,\n        revisedMaxNotificationsPerPublish,\n        revisedPriority,\n        subscription_data_notification_callback,\n        NULL); // User context is NULL in this example\n\n    return retval;\n}\n\n// Callback function for handling subscription data notifications\nstatic void subscription_data_notification_callback(UA_Client *client,\n                                                    const UA_DataNotification *notification,\n                                                    void *userContext) {\n    // Handle data notification here\n    // This is a placeholder for actual implementation\n    (void)client; // Suppress warning\n    (void)notification; // Suppress warning\n    (void)userContext; // Suppress warning\n}\n```\n```\nFUNCTION_BLOCK OPC_UA_SUBSCRIPTION_CREATION\nVAR_INPUT\n    Exec : BOOL;\n    ConnectionHandle : DWORD;\n    Priority : BYTE;\n    Timeout : TIME;\nVAR_OUTPUT\n    Done : BOOL;\n    Busy : BOOL;\n    Error : BOOL;\n    ErrorID : DWORD;\n    SubscriptionHdl : DWORD;\nVAR_IN_OUT\n    PublishingInterval : TIME;\nVAR\n    CClient : ANY; // Placeholder for the C client object\n    CConnectionHandle : POINTER TO ANY; // Pointer to the connection handle\n    CPriority : UINT;\n    CTimeout : UINT;\n    CPublishingInterval : UINT;\nEND_VAR\n\n// Initialize pointers and conversions\nCConnectionHandle := PTR_CONNECTION(ConnectionHandle);\nCPriority := Priority;\nCTimeout := TIMEOUT;\nCPublishingInterval := PUBLISHING_INTERVAL;\n\nIF Exec THEN\n    // Convert time to milliseconds for C library\n    CPublishingInterval := PublishingInterval / T#1ms;\n    \n    // Call the C function to create the subscription\n    ErrorID := CALL_C_FUNC(CreateSubscription,\n                           CConnectionHandle,\n                           CPriority,\n                           CPublishingInterval,\n                           SubscriptionHdl);\n    \n    // Check the result\n    IF ErrorID = 0 THEN\n        Done := TRUE;\n        Busy := FALSE;\n        Error := FALSE;\n    ELSE\n        Done := FALSE;\n        Busy := FALSE;\n        Error := TRUE;\n    END_IF\nELSE\n    Done := FALSE;\n    Busy := TRUE;\n    Error := FALSE;\nEND_IF\n\n// Example pseudo-function for demonstration\nPROCEDURE CALL_C_FUNC(FuncName : STRING; ConnHandle : POINTER TO ANY; Priority : UINT; Timeout : UINT; SubscriptionHdl : REFERENCE TO DWORD) : DWORD\n    // Calls the specified C function with the provided arguments and returns the error ID\n    RETURN 0; // Placeholder for the actual error ID\nEND_PROC\nEND_FUNCTION_BLOCK\n\nPROGRAM OPC_UA_CLIENT_PROGRAM\nVAR\n    ConnectionHandle : DWORD := 0x12345678; // Example connection handle\n    Priority : BYTE := 1; // Example priority level\n    Timeout : TIME := T#5s; // Example timeout\n    PublishingInterval : TIME := T#1000ms; // Initial publishing interval\n    Done : BOOL;\n    Busy : BOOL;\n    Error : BOOL;\n    ErrorID : DWORD;\n    SubscriptionHdl : DWORD;\nBEGIN\n    OPC_UA_SUBSCRIPTION_CREATION(Exec := TRUE,\n                                 ConnectionHandle,\n                                 Priority,\n                                 Timeout,\n                                 Done,\n                                 Busy,\n                                 Error,\n                                 ErrorID,\n                                 SubscriptionHdl,\n                                 PublishingInterval);\n    \n    // Use the outputs to control further actions\n    IF Done THEN\n        // Subscription created successfully\n        // Further processing goes here\n    ELSIF Error THEN\n        // Handle error condition\n        WRITE_LOG(ErrorID);\n    ELSE\n        // Busy state, wait for completion\n    END_IF\nEND\n```\n",
        "description": "Markdown file from OPC UA Subscription Creation Using Open62541 and IEC 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/OPC UA Subscription Creation Using Open62541 and IEC 61131-3 Structured Text.md"
    },
    {
        "filename": "Profibus DP Diagnostics Using 61131-3 Structured Text.md",
        "content": "```\nFUNCTION_BLOCK PROFIBUS_DP_DIAGNOSTICS\nVAR_INPUT\n    Execute : BOOL;\n    SlaveAddress : UINT;\nVAR_OUTPUT\n    DeviceStatus : UINT;\n    ErrorCode : UINT;\n    CommunicationHealth : UINT;\n    Busy : BOOL;\n    ErrorOccurred : BOOL;\n    ErrorMessage : STRING(255);\nVAR\n    BUS : ANY; // Placeholder for the Profibus DP bus object\n    DIAG_REQUEST : BYTE_STRING(8); // Diagnostic request data packet\n    DIAG_RESPONSE : BYTE_STRING(8); // Diagnostic response data packet\n    BUFFER_POS : UINT;\n    ERROR_CODE : UINT;\n    STATUS : UINT;\n    HEALTH : UINT;\nEND_VAR\n\n// Initialize Profibus DP communication\nIF NOT BUS.INITIALIZED THEN\n    BUS.INIT();\n    BUS.INITIALIZED := TRUE;\nEND_IF\n\n// Check if the function block is already busy\nIF Busy THEN\n    DeviceStatus := 0;\n    ErrorCode := 0;\n    CommunicationHealth := 0;\n    ErrorOccurred := TRUE;\n    ErrorMessage := \"Function block is busy.\";\n    RETURN;\nEND_IF\n\nIF Execute THEN\n    Busy := TRUE;\n    ErrorOccurred := FALSE;\n    ErrorMessage := \"\";\n    \n    // Prepare diagnostic request\n    DIAG_REQUEST[0] := $01; // Request Type: Read Diagnostic Info\n    DIAG_REQUEST[1] := SlaveAddress; // Slave Address\n    DIAG_REQUEST[2] := $00; // Sub-function (default for basic diagnostics)\n    \n    // Send diagnostic request\n    IF NOT BUS.SEND_DIAG_REQUEST(DIAG_REQUEST) THEN\n        Busy := FALSE;\n        ErrorOccurred := TRUE;\n        ErrorMessage := \"Failed to send diagnostic request.\";\n        RETURN;\n    END_IF\n    \n    // Receive diagnostic response\n    IF NOT BUS.RECV_DIAG_RESPONSE(DIAG_RESPONSE) THEN\n        Busy := FALSE;\n        ErrorOccurred := TRUE;\n        ErrorMessage := \"Failed to receive diagnostic response.\";\n        RETURN;\n    END_IF\n    \n    // Parse diagnostic response\n    BUFFER_POS := 0;\n    ERROR_CODE := PARSE_ERROR_CODE(DIAG_RESPONSE, BUFFER_POS);\n    STATUS := PARSE_DEVICE_STATUS(DIAG_RESPONSE, BUFFER_POS);\n    HEALTH := PARSE_COMMUNICATION_HEALTH(DIAG_RESPONSE, BUFFER_POS);\n    \n    // Set output values\n    DeviceStatus := STATUS;\n    ErrorCode := ERROR_CODE;\n    CommunicationHealth := HEALTH;\n    \n    Busy := FALSE;\nELSE\n    DeviceStatus := 0;\n    ErrorCode := 0;\n    CommunicationHealth := 0;\n    Busy := FALSE;\n    ErrorOccurred := FALSE;\n    ErrorMessage := \"\";\nEND_IF\n\n// Example pseudo-functions for demonstration\nPROCEDURE BUS_INIT()\n    // Initializes the Profibus DP bus\nEND_PROC\n\nPROCEDURE BUS_SEND_DIAG_REQUEST(Request : BYTE_STRING(8)) : BOOL\n    // Sends a diagnostic request and returns TRUE if successful\n    RETURN TRUE;\nEND_PROC\n\nPROCEDURE BUS_RECV_DIAG_RESPONSE(Response : REFERENCE TO BYTE_STRING(8)) : BOOL\n    // Receives a diagnostic response and returns TRUE if successful\n    RETURN TRUE;\nEND_PROC\n\nPROCEDURE PARSE_ERROR_CODE(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : UINT\n    // Parses the error code from the response\n    RETURN $00000000;\nEND_PROC\n\nPROCEDURE PARSE_DEVICE_STATUS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : UINT\n    // Parses the device status from the response\n    RETURN $00000000;\nEND_PROC\n\nPROCEDURE PARSE_COMMUNICATION_HEALTH(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : UINT\n    // Parses the communication health from the response\n    RETURN $00000000;\nEND_PROC\nEND_FUNCTION_BLOCK\n\nPROGRAM PROFIBUS_CONTROL_PROGRAM\nVAR\n    ExecuteDiagnostics : BOOL := TRUE;\n    SlaveAddress : UINT := 1; // Example slave address\n    DeviceStatus : UINT;\n    ErrorCode : UINT;\n    CommunicationHealth : UINT;\n    Busy : BOOL;\n    ErrorOccurred : BOOL;\n    ErrorMessage : STRING(255);\nBEGIN\n    PROFIBUS_DP_DIAGNOSTICS(Execute := ExecuteDiagnostics,\n                            SlaveAddress,\n                            DeviceStatus,\n                            ErrorCode,\n                            CommunicationHealth,\n                            Busy,\n                            ErrorOccurred,\n                            ErrorMessage);\n    \n    // Further processing based on diagnostic results\n    IF ErrorOccurred THEN\n        // Handle error\n        WRITE_LOG(ErrorMessage);\n    ELSE\n        // Process diagnostic data\n        IF DeviceStatus = $00000000 THEN\n            // Device is operating normally\n        ELSE\n            // Device has an issue, handle accordingly\n        END_IF\n    END_IF\nEND\n```\n",
        "description": "Markdown file from Profibus DP Diagnostics Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/Profibus DP Diagnostics Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Profibus DPV1 Diagnostics Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM PROFIBUS_DPV1_DIAGNOSTICS\nVAR\n    Execute : BOOL;\n    SlaveAddress : UINT;\n    DiagnosticData : ANY; // Container for diagnostic data\n    Busy : BOOL;\n    ErrorOccurred : BOOL;\n    ErrorMessage : STRING(255);\nVAR\n    BUS : ANY; // Placeholder for the Profibus DPV1 bus object\n    DIAG_REQUEST : BYTE_STRING(8); // Diagnostic request data packet\n    DIAG_RESPONSE : BYTE_STRING(8); // Diagnostic response data packet\n    BUFFER_POS : UINT;\n    DIAG_DATA_TYPE : UINT; // Diagnostic data type identifier\nEND_VAR\n\n// Initialize Profibus DPV1 communication\nIF NOT BUS.INITIALIZED THEN\n    BUS.INIT();\n    BUS.INITIALIZED := TRUE;\nEND_IF\n\n// Check if the function block is already busy\nIF Busy THEN\n    DiagnosticData := (ANY)NULL;\n    ErrorOccurred := TRUE;\n    ErrorMessage := \"Function block is busy.\";\n    RETURN;\nEND_IF\n\nIF Execute THEN\n    Busy := TRUE;\n    ErrorOccurred := FALSE;\n    ErrorMessage := \"\";\n    \n    // Prepare diagnostic request\n    DIAG_REQUEST[0] := $01; // Request Type: Read Diagnostic Info\n    DIAG_REQUEST[1] := SlaveAddress; // Slave Address\n    DIAG_REQUEST[2] := $00; // Sub-function (default for basic diagnostics)\n    \n    // Send diagnostic request\n    IF NOT BUS.SEND_DIAG_REQUEST(DIAG_REQUEST) THEN\n        Busy := FALSE;\n        ErrorOccurred := TRUE;\n        ErrorMessage := \"Failed to send diagnostic request.\";\n        RETURN;\n    END_IF\n    \n    // Receive diagnostic response\n    IF NOT BUS.RECV_DIAG_RESPONSE(DIAG_RESPONSE) THEN\n        Busy := FALSE;\n        ErrorOccurred := TRUE;\n        ErrorMessage := \"Failed to receive diagnostic response.\";\n        RETURN;\n    END_IF\n    \n    // Parse diagnostic response\n    BUFFER_POS := 0;\n    DIAG_DATA_TYPE := DIAG_RESPONSE[BUFFER_POS];\n    \n    CASE DIAG_DATA_TYPE OF\n        $01: // Communication Errors\n            DiagnosticData := PARSE_COMM_ERRORS(DIAG_RESPONSE, BUFFER_POS);\n        $02: // Device Status\n            DiagnosticData := PARSE_DEVICE_STATUS(DIAG_RESPONSE, BUFFER_POS);\n        $03: // Parameter Faults\n            DiagnosticData := PARSE_PARAM_FAULTS(DIAG_RESPONSE, BUFFER_POS);\n        $04: // Input Overload\n            DiagnosticData := PARSE_INPUT_OVERLOAD(DIAG_RESPONSE, BUFFER_POS);\n        $05: // Output Overload\n            DiagnosticData := PARSE_OUTPUT_OVERLOAD(DIAG_RESPONSE, BUFFER_POS);\n        $06: // Hardware Faults\n            DiagnosticData := PARSE_HARDWARE_FAULTS(DIAG_RESPONSE, BUFFER_POS);\n        $07: // Software Faults\n            DiagnosticData := PARSE_SOFTWARE_FAULTS(DIAG_RESPONSE, BUFFER_POS);\n        $08: // Configuration Errors\n            DiagnosticData := PARSE_CONFIG_ERRORS(DIAG_RESPONSE, BUFFER_POS);\n        $09: // Operational Errors\n            DiagnosticData := PARSE_OPERATIONAL_ERRORS(DIAG_RESPONSE, BUFFER_POS);\n        $0A: // Safety Related Errors\n            DiagnosticData := PARSE_SAFETY_ERRORS(DIAG_RESPONSE, BUFFER_POS);\n        ELSE\n            Busy := FALSE;\n            ErrorOccurred := TRUE;\n            ErrorMessage := \"Unknown diagnostic data type.\";\n            RETURN;\n    END_CASE\n    \n    Busy := FALSE;\nELSE\n    DiagnosticData := (ANY)NULL;\n    Busy := FALSE;\n    ErrorOccurred := FALSE;\n    ErrorMessage := \"\";\nEND_IF\n\n// Example pseudo-functions for demonstration\nPROCEDURE BUS_INIT()\n    // Initializes the Profibus DPV1 bus\nEND_PROC\n\nPROCEDURE BUS_SEND_DIAG_REQUEST(Request : BYTE_STRING(8)) : BOOL\n    // Sends a diagnostic request and returns TRUE if successful\n    RETURN TRUE;\nEND_PROC\n\nPROCEDURE BUS_RECV_DIAG_RESPONSE(Response : REFERENCE TO BYTE_STRING(8)) : BOOL\n    // Receives a diagnostic response and returns TRUE if successful\n    RETURN TRUE;\nEND_PROC\n\nPROCEDURE PARSE_COMM_ERRORS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses communication errors from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_DEVICE_STATUS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses device status from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_PARAM_FAULTS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses parameter faults from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_INPUT_OVERLOAD(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses input overload from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_OUTPUT_OVERLOAD(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses output overload from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_HARDWARE_FAULTS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses hardware faults from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_SOFTWARE_FAULTS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses software faults from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_CONFIG_ERRORS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses configuration errors from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_OPERATIONAL_ERRORS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses operational errors from the response\n    RETURN (ANY)NULL;\nEND_PROC\n\nPROCEDURE PARSE_SAFETY_ERRORS(Response : BYTE_STRING(8), BufferPos : REFERENCE TO UINT) : ANY\n    // Parses safety related errors from the response\n    RETURN (ANY)NULL;\nEND_PROC\nEND_PROGRAM\n\nPROGRAM CONTROL_PROGRAM\nVAR\n    ExecuteDiagnostics : BOOL := TRUE;\n    SlaveAddress : UINT := 1; // Example slave address\n    DiagnosticData : ANY;\n    Busy : BOOL;\n    ErrorOccurred : BOOL;\n    ErrorMessage : STRING(255);\nBEGIN\n    PROFIBUS_DPV1_DIAGNOSTICS(Execute := ExecuteDiagnostics,\n                              SlaveAddress,\n                              DiagnosticData,\n                              Busy,\n                              ErrorOccurred,\n                              ErrorMessage);\n    \n    // Further processing based on diagnostic results\n    IF ErrorOccurred THEN\n        // Handle error\n        WRITE_LOG(ErrorMessage);\n    ELSE\n        // Process diagnostic data\n        CASE DiagnosticData OF\n            COMM_ERRORS:\n                // Handle communication errors\n            DEVICE_STATUS:\n                // Handle device status\n            PARAM_FAULTS:\n                // Handle parameter faults\n            INPUT_OVERLOAD:\n                // Handle input overload\n            OUTPUT_OVERLOAD:\n                // Handle output overload\n            HARDWARE_FAULTS:\n                // Handle hardware faults\n            SOFTWARE_FAULTS:\n                // Handle software faults\n            CONFIG_ERRORS:\n                // Handle configuration errors\n            OPERATIONAL_ERRORS:\n                // Handle operational errors\n            SAFETY_ERRORS:\n                // Handle safety related errors\n            ELSE\n                // Unknown diagnostic data type\n                WRITE_LOG(\"Unknown diagnostic data type.\");\n        END_CASE\n    END_IF\nEND\n```\n",
        "description": "Markdown file from Profibus DPV1 Diagnostics Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/Diagnostics and Communication/Profibus DPV1 Diagnostics Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Extended Cause & Process Action Matrix.md",
        "content": "```\n| Causes (C)         | Emergency Shutdown (ESD) | Cool Down System Activation (CDS) | Pressure Relief Valve Opening (PRV) | Heating System Deactivation (HSD) | Alarm Activation (AA) |\n|---------------------|--------------------------|-----------------------------------|-------------------------------------|-----------------------------------|-----------------------|\n| C1: High Temperature (> T_max) | X                        | X                                 |                                      | X                          | X                     |\n| C2: Low Temperature (< T_min) |                          |                                   |                                      | X                          | X                     |\n| C3: High Pressure (> P_max)   | X                        |                                   | X                                  |                            | X                     |\n| C4: Low Pressure (< P_min)    |                          |                                   |                                     |                            | X                     |\n| C5: High Level (> L_max)      | X                        | X                                 |                                      |                            | X                     |\n| C6: Low Level (< L_min)       |                          |                                   |                                      |                            | X                     |\n| C7: Gas Leak Detected         | X                        |                                   | X                                  |                            | X                     |\n| C8: Power Failure             | X                        |                                   |                                     |                            | X                     |\n| C9: Control System Failure    | X                        |                                   |                                     |                            | X                     |\n```\n",
        "description": "Markdown file from Extended Cause & Process Action Matrix.md",
        "path": "Reference Solutions/Interlocks/Extended Cause & Process Action Matrix.md"
    },
    {
        "filename": "Interlock Cause & Effect Matrix.md",
        "content": "```\n| Causes (C)              | Close Feed Valve (CFV) | Start Emergency Cooling (SEC) | Open Pressure Relief Valve (OPRV) | Stop Heating (SH) | Trigger Alarm (TA) |\n|-------------------------|------------------------|-------------------------------|-----------------------------------|-------------------|-------------------|\n| C1: High Temperature (> T_max) |                      | X                             |                                    | X                 | X                |\n| C2: Low Temperature (< T_min) |                      |                               |                                    | X                 | X                |\n| C3: High Pressure (> P_max)  |                      |                               | X                                 |                   | X                |\n| C4: Low Pressure (< P_min)   |                      |                               |                                    |                   | X                |\n| C5: High Level (> L_max)     | X                     | X                             |                                    |                   | X                |\n| C6: Low Level (< L_min)      | X                     |                               |                                    |                   | X                |\n| C7: Gas Leak Detected        | X                     |                               | X                                 |                   | X                |\n| C8: Power Failure            | X                     |                               |                                    |                   | X                |\n| C9: Control System Failure   | X                     |                               |                                    |                   | X                |\n```\n",
        "description": "Markdown file from Interlock Cause & Effect Matrix.md",
        "path": "Reference Solutions/Interlocks/Interlock Cause & Effect Matrix.md"
    },
    {
        "filename": "Interlock Distillation Column.md",
        "content": "```\nPROGRAM DISTILLATION_COLUMN_INTERLOCKS\nVAR\n    // Inputs\n    PT_101: REAL; // Pressure Transmitter 101 reading\n    TT_101: REAL; // Temperature Transmitter 101 reading\n    LT_101: REAL; // Level Transmitter 101 reading\n    \n    // Outputs\n    FV_101: BOOL; // Feed Valve 101 status\n    PCV_101: BOOL; // Pressure Control Valve 101 status\n    TCV_101: BOOL; // Temperature Control Valve 101 status\n    PRV_101: BOOL; // Pressure Relief Valve 101 status\n    \n    // Constants\n    HIGH_PRESSURE_LIMIT: REAL := 120.0; // psi\n    LOW_PRESSURE_LIMIT: REAL := 50.0; // psi\n    HIGH_TEMP_LIMIT: REAL := 180.0; // \u00b0C\nBEGIN\n    // Pressure Interlocks\n    IF PT_101 > HIGH_PRESSURE_LIMIT THEN\n        PRV_101 := TRUE; // Open pressure relief valve\n    ELSE\n        PRV_101 := FALSE;\n    END_IF;\n    \n    IF PT_101 < LOW_PRESSURE_LIMIT THEN\n        FV_101 := FALSE; // Close feed valve\n    ELSE\n        FV_101 := TRUE;\n    END_IF;\n    \n    // Temperature Interlocks\n    IF TT_101 > HIGH_TEMP_LIMIT THEN\n        TCV_101 := FALSE; // Close temperature control valve\n    ELSE\n        TCV_101 := TRUE;\n    END_IF;\n    \n    // Additional logic for normal operation can be added here\nEND\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Interlock Distillation Column.md",
        "path": "Reference Solutions/Interlocks/Interlock Distillation Column.md"
    },
    {
        "filename": "Interlock Gas Turbine.md",
        "content": "```\n1.Overtemperature Interlock: Shutdown the turbine if the exhaust gas temperature exceeds a predefined limit (e.g., 650\u00b0C). This prevents thermal damage to turbine components such as blades, bearings, and seals.\n2.Overspeed Interlock: Trigger an emergency stop if the turbine rotor speed exceeds its maximum operating threshold (e.g., 105% of nominal speed). This ensures the protection of mechanical components from excessive centrifugal forces and potential structural failure.\n3.Overpressure Interlock: Open the pressure relief valve if the pressure in the combustion chamber exceeds safe levels (e.g., 30 bar). This action helps prevent damage or explosion caused by excessive pressure build-up.\n4.Low Lubrication Pressure Interlock: Stop the turbine if lubrication oil pressure falls below the safe operating limit (e.g., 1.5 bar). Insufficient lubrication can lead to excessive wear on bearings and rotors, potentially causing catastrophic failure.\n5.High Vibration Interlock: Shut down the turbine if excessive vibration is detected (e.g., vibration amplitude exceeds 10 mm/s). Excessive vibration can indicate issues such as misalignment, imbalance, or bearing wear, which could lead to severe damage if not addressed promptly.\n6.Flame Failure Interlock: Immediately stop fuel flow and trigger an alarm if the flame in the combustion chamber extinguishes. This prevents the accumulation of unburned fuel, which poses a significant explosion risk.\n7.Fuel Gas Pressure Low Interlock: Close the fuel valve and stop the turbine if the fuel gas pressure drops below the required minimum (e.g., 2 bar). Insufficient fuel pressure can result in poor combustion efficiency and potential damage to the turbine.\n8.Cooling Water Flow Interlock: Shutdown the turbine if cooling water flow falls below the minimum safe flow rate (e.g., 200 L/min). Proper cooling is essential to prevent overheating of critical components such as bearings and seals.\n9.Compressor Surge Interlock: Activate a bypass valve or reduce load if the compressor experiences a surge condition. A surge occurs when the airflow through the compressor reverses direction, which can cause significant damage to the compressor blades.\n10.Emergency Stop Interlock: Provide a manual emergency stop button that immediately shuts down the turbine and isolates fuel supply in case of any critical malfunction. This allows for rapid intervention in unexpected situations to prevent further damage or potential hazards.\n\n```\n",
        "description": "Markdown file from Interlock Gas Turbine.md",
        "path": "Reference Solutions/Interlocks/Interlock Gas Turbine.md"
    },
    {
        "filename": "Interlock Gas Wellhead.md",
        "content": "```\n1.Safety and Integrity: Emergency interlocks are designed to maintain the safety and integrity of the wellhead and associated equipment. By monitoring parameters such as pressure, temperature, and flow rates, these systems can detect anomalies and take corrective actions before they lead to more serious issues.\n2.Prevention of Catastrophic Failures: In subsea environments, where accessibility is limited and conditions are harsh, preventing catastrophic failures is paramount. High-pressure events, temperature excursions, and flow anomalies can all pose significant risks to the wellhead structure and the surrounding marine environment.\n3.Environmental Protection: In the event of a leak or other malfunction, the interlocks help prevent the release of hydrocarbons into the ocean, thus protecting marine life and ecosystems.\n4.Equipment Protection: By shutting down the system when critical parameters are exceeded, the interlocks help prevent damage to the wellhead itself and associated equipment, which can be costly to repair or replace.\n5.Regulatory Compliance: Many jurisdictions mandate the use of safety systems like emergency interlocks to comply with safety regulations and standards. These systems help operators meet legal requirements and demonstrate due diligence in managing operational risks.\n6.Operational Efficiency: While the primary purpose of emergency interlocks is safety, they also contribute to operational efficiency by enabling a rapid response to potential problems. This quick action can minimize downtime and reduce the likelihood of extended disruptions to production.\n```\n",
        "description": "Markdown file from Interlock Gas Wellhead.md",
        "path": "Reference Solutions/Interlocks/Interlock Gas Wellhead.md"
    },
    {
        "filename": "Interlock Overfill Protection.md",
        "content": "```\nPROGRAM OVERFILL_PROTECTION_SYSTEM\nVAR\n    // Inputs\n    LS_101: REAL; // Level Sensor Reading\n    VALVE_STATUS: BOOL; // Current Valve Status (OPEN = TRUE, CLOSED = FALSE)\n\n    // Outputs\n    INLET_VALVE: BOOL; // Inlet Valve Control Signal (CLOSE = TRUE)\n    EMERGENCY_STOP: BOOL; // Emergency Stop Status\n    SENSOR_FAULT: BOOL; // Sensor Fault Status\n    VALVE_FAULT: BOOL; // Valve Fault Status\n    \n    // Constants\n    HIGH_LEVEL_SETPOINT: REAL := 90.0; // Percentage of tank capacity\n    SAFE_THRESHOLD: REAL := 85.0; // Percentage of tank capacity\nBEGIN\n    // Initialize Emergency Stop Status and Fault Flags\n    EMERGENCY_STOP := FALSE;\n    SENSOR_FAULT := FALSE;\n    VALVE_FAULT := FALSE;\n\n    // Check for High Level Condition\n    IF LS_101 >= HIGH_LEVEL_SETPOINT THEN\n        EMERGENCY_STOP := TRUE;\n        INLET_VALVE := TRUE; // Close Inlet Valve\n    END_IF;\n\n    // Check for Level Below Safe Threshold\n    IF LS_101 <= SAFE_THRESHOLD THEN\n        EMERGENCY_STOP := FALSE;\n        INLET_VALVE := FALSE; // Open Inlet Valve\n    END_IF;\n\n    // Fail-Safe Mechanism Handling\n    // Assume SENSOR_FAULT is set externally if sensor readings are erratic or outside valid range\n    IF SENSOR_FAULT THEN\n        EMERGENCY_STOP := TRUE;\n        INLET_VALVE := TRUE; // Close Inlet Valve if sensor fails\n    END_IF;\n\n    // Assume VALVE_FAULT is set externally if valve does not respond to control signal\n    IF VALVE_FAULT THEN\n        EMERGENCY_STOP := TRUE;\n        INLET_VALVE := TRUE; // Force valve closed if valve malfunctions\n    END_IF;\n\n    // Manual Reset Logic (for demonstration purposes, assume manual reset via flag)\n    IF NOT EMERGENCY_STOP THEN\n        // Reset flags if the level is back to safe threshold and no faults are present\n        SENSOR_FAULT := FALSE;\n        VALVE_FAULT := FALSE;\n    END_IF;\nEND\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Interlock Overfill Protection.md",
        "path": "Reference Solutions/Interlocks/Interlock Overfill Protection.md"
    },
    {
        "filename": "Interlock Pressure Relief.md",
        "content": "```\nPROGRAM PRESSURE_RELIEF_SYSTEM\nVAR\n    // Inputs\n    PT_101: REAL; // Pressure Sensor Reading (psi)\n    RELIEF_VALVE_STATUS: BOOL; // Current Relief Valve Status (CLOSED = TRUE, OPEN = FALSE)\n    \n    // Outputs\n    RELIEF_VALVE: BOOL; // Relief Valve Control Signal (OPEN = TRUE)\n    EMERGENCY_STOP: BOOL; // Emergency Stop Status\n    SENSOR_FAULT: BOOL; // Sensor Fault Status\n    VALVE_FAULT: BOOL; // Valve Fault Status\n    \n    // Constants\n    HIGH_PRESSURE_LIMIT: REAL := 150.0; // psi\n    SAFE_THRESHOLD: REAL := 120.0; // psi\nBEGIN\n    // Initialize Emergency Stop Status and Fault Flags\n    EMERGENCY_STOP := FALSE;\n    SENSOR_FAULT := FALSE;\n    VALVE_FAULT := FALSE;\n\n    // Check for High Pressure Condition\n    IF PT_101 >= HIGH_PRESSURE_LIMIT THEN\n        EMERGENCY_STOP := TRUE;\n        RELIEF_VALVE := TRUE; // Open Relief Valve\n    END_IF;\n\n    // Check for Pressure Below Safe Threshold\n    IF PT_101 <= SAFE_THRESHOLD THEN\n        EMERGENCY_STOP := FALSE;\n        RELIEF_VALVE := FALSE; // Close Relief Valve\n    END_IF;\n\n    // Fail-Safe Mechanism Handling\n    // Assume SENSOR_FAULT is set externally if sensor readings are erratic or outside valid range\n    IF SENSOR_FAULT THEN\n        EMERGENCY_STOP := TRUE;\n        RELIEF_VALVE := TRUE; // Open Relief Valve if sensor fails\n    END_IF;\n\n    // Assume VALVE_FAULT is set externally if valve does not respond to control signal\n    IF VALVE_FAULT THEN\n        EMERGENCY_STOP := TRUE;\n        RELIEF_VALVE := TRUE; // Force valve open if valve malfunctions\n    END_IF;\n\n    // Manual Reset Logic (for demonstration purposes, assume manual reset via flag)\n    IF NOT EMERGENCY_STOP THEN\n        // Reset flags if the pressure is back to safe threshold and no faults are present\n        SENSOR_FAULT := FALSE;\n        VALVE_FAULT := FALSE;\n    END_IF;\nEND\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Interlock Pressure Relief.md",
        "path": "Reference Solutions/Interlocks/Interlock Pressure Relief.md"
    },
    {
        "filename": "Interlock Prilling Station.md",
        "content": "```\n1.High Temperature Interlock: Shutdown the process if the temperature in the prilling tower exceeds a safe limit (e.g., 100\u00b0C). This prevents thermal degradation of AN and reduces the risk of decomposition, which could lead to explosive reactions.\n2.Low Temperature Interlock: Alarm if the temperature drops below a minimum limit (e.g., 80\u00b0C). This ensures that the AN solution remains fluid enough to be sprayed properly and form uniform prills.\n3.High Pressure Interlock: Close the feed valve if the pressure in the prilling tower rises above a safe level (e.g., 5 bar). This prevents overpressurization, which could cause structural damage to the tower or equipment.\n4.Low Pressure Interlock: Alarm if the pressure drops below a minimum threshold (e.g., 2 bar). This indicates a possible blockage or failure in the supply lines, requiring immediate attention.\n5.High Solution Concentration Interlock: Shutdown the solution pump if the concentration of the AN solution becomes too high (e.g., >95%). This prevents the formation of solid blocks in the tower and ensures proper prilling.\n6.Low Solution Flow Rate Interlock: Shutdown the spray nozzles if the flow rate of the AN solution falls below a minimum level (e.g., 5 m\u00b3/h). This prevents the formation of large, irregular prills or clogging of the nozzles.\n7.High Humidity Interlock: Alarm if the humidity inside the prilling tower exceeds a safe limit (e.g., 70%). High humidity can affect the quality of the prills and increase the risk of agglomeration.\n8.Low Air Flow Interlock: Shutdown the air fans if the air flow rate through the prilling tower drops below a minimum threshold (e.g., 2000 m\u00b3/h). Adequate air flow is necessary to cool the prills and remove moisture.\n9.High Dust Concentration Interlock: Alarm if the dust concentration inside the prilling tower exceeds a safe limit (e.g., 5 mg/m\u00b3). High dust levels can indicate issues with the prilling process or equipment and pose inhalation risks to personnel.\n10.Emergency Stop Interlock: Provide a manual emergency stop button that immediately halts all process activities and isolates the system from the feedstock supply in the event of any critical malfunction.\n11.Vapor Detection Interlock: Shutdown the system if vapor detectors identify the presence of hazardous gases (e.g., nitrogen oxides). This prevents the risk of fire or explosion due to gas accumulation.\n12.Power Failure Interlock: Automatically engage a backup power source to maintain critical functions (e.g., air circulation, temperature control) during a power outage.\n```\n",
        "description": "Markdown file from Interlock Prilling Station.md",
        "path": "Reference Solutions/Interlocks/Interlock Prilling Station.md"
    },
    {
        "filename": "Interlock Safety Doors.md",
        "content": "```\nPROGRAM SAFETY_DOOR_INTERLOCKS\nVAR\n    // Inputs\n    DOOR_1_STATUS: BOOL; // Door 1 Status (CLOSED = TRUE)\n    DOOR_2_STATUS: BOOL; // Door 2 Status (CLOSED = TRUE)\n    DOOR_3_STATUS: BOOL; // Door 3 Status (CLOSED = TRUE)\n    \n    // Outputs\n    REACTOR_START: BOOL; // Reactor Start Permission (ALLOWED = TRUE)\n    EMERGENCY_SHUTDOWN: BOOL; // Emergency Shutdown Status\n    \n    // Flags\n    DOORS_CLOSED: BOOL; // All Doors Closed Flag\nBEGIN\n    // Check All Doors Status\n    DOORS_CLOSED := DOOR_1_STATUS AND DOOR_2_STATUS AND DOOR_3_STATUS;\n\n    // Allow Reactor Start Only When All Doors Are Closed\n    REACTOR_START := DOORS_CLOSED;\n\n    // Trigger Emergency Shutdown If Any Door Is Opened During Operation\n    IF NOT DOORS_CLOSED THEN\n        EMERGENCY_SHUTDOWN := TRUE;\n    ELSE\n        EMERGENCY_SHUTDOWN := FALSE;\n    END_IF;\n\n    // Additional Logic Can Be Added Here To Handle Other Aspects Of Reactor Operation\nEND\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Interlock Safety Doors.md",
        "path": "Reference Solutions/Interlocks/Interlock Safety Doors.md"
    },
    {
        "filename": "Motor Interlock Function Block Diagram.md",
        "content": "```\n+-----------------------+\n|                       |\n|  EquipmentRunning_1   |  --(input)---\n|                       |\n+-----------------------+\n           |\n           V\n+-----------------------+\n|                       |\n|  EquipmentRunning_2   |  --(input)---\n|                       |\n+-----------------------+\n           |\n           V\n+-----------------------+\n|                       |\n|      AND Gate         |  --(combined input)---\n|                       |\n+-----------------------+\n           |\n           V\n+-----------------------+\n|                       |\n|  NOT Gate (optional)  |  --(inverted combined input)---\n|                       |\n+-----------------------+\n           |\n           V\n+-----------------------+\n|                       |\n| MotorStartAllowed     |  --(output)---\n|                       |\n+-----------------------+\n```\n",
        "description": "Markdown file from Motor Interlock Function Block Diagram.md",
        "path": "Reference Solutions/Interlocks/Motor Interlock Function Block Diagram.md"
    },
    {
        "filename": "Eigenvalue.md",
        "content": "```\nFUNCTION_BLOCK ComputeEigenvalues\nVAR_INPUT\n    Matrix : ARRAY [1..10, 1..10] OF REAL; // 10x10 Matrix\nVAR_OUTPUT\n    Eigenvalues : ARRAY [1..10] OF REAL; // Eigenvalues\nVAR\n    Iterations : INT := 0; // Count iterations\n    MaxIterations : INT := 1000; // Maximum allowed iterations\n    Tolerance : REAL := 0.0001; // Convergence tolerance\n    Q : ARRAY [1..10, 1..10] OF REAL; // Orthogonal matrix Q\n    R : ARRAY [1..10, 1..10] OF REAL; // Upper triangular matrix R\nEND_VAR\n\n// Initial QR Decomposition\nFOR i := 1 TO 10 DO\n    FOR j := 1 TO 10 DO\n        Q[i,j] := 0;\n        R[i,j] := 0;\n    END_FOR\nEND_FOR\n\nFOR i := 1 TO 10 DO\n    Q[i,i] := 1;\nEND_FOR\n\n// QR Algorithm Loop\nWHILE Iterations < MaxIterations DO\n    // Perform QR Decomposition\n    QRDecomposition(Matrix, Q, R);\n    \n    // Reconstruct Matrix from Q and R\n    Matrix := MatMul(Q, R);\n    \n    // Check Diagonal for Convergence\n    BoolArray := ARRAY [1..10] OF BOOLEAN;\n    FOR i := 1 TO 9 DO\n        BoolArray[i] := ABS(R[i+1,i]) < Tolerance;\n    END_FOR\n    BoolArray[10] := TRUE; // Last element is always converged\n    \n    // If all diagonal elements are converged, break loop\n    IF ALL(BoolArray) THEN\n        Eigenvalues := ARRAY [1..10] OF REAL;\n        FOR i := 1 TO 10 DO\n            Eigenvalues[i] := R[i,i];\n        END_FOR\n        EXIT;\n    END_IF\n    \n    Iterations := Iterations + 1;\nEND_WHILE\n\n// If max iterations reached without convergence, set Eigenvalues to NaN\nIF Iterations >= MaxIterations THEN\n    FOR i := 1 TO 10 DO\n        Eigenvalues[i] := NaN;\n    END_FOR\nEND_IF\n\n// Helper Functions for QR Decomposition and Matrix Multiplication\nFUNCTION QRDecomposition(Matrix, Q, R : ARRAY [1..10, 1..10] OF REAL) : BOOL;\n    // Implementation of QR Decomposition Algorithm\nEND_FUNCTION\n\nFUNCTION MatMul(A, B : ARRAY [1..10, 1..10] OF REAL) : ARRAY [1..10, 1..10] OF REAL;\n    // Implementation of Matrix Multiplication\nEND_FUNCTION\n\n// Helper Function to Check if All Elements in Array are TRUE\nFUNCTION ALL(Array : ARRAY [1..10] OF BOOLEAN) : BOOLEAN;\n    // Implementation of Checking All Elements\nEND_FUNCTION\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Eigenvalue.md",
        "path": "Reference Solutions/Mathematical Functions/Eigenvalue.md"
    },
    {
        "filename": "Fast Fourier Transform.md",
        "content": "```\nFUNCTION_BLOCK FFT\nVAR_INPUT\n    InputSignal : ARRAY [0..1023] OF REAL; // Input signal (assumed to be 1024 points)\nVAR_OUTPUT\n    FFTResult : ARRAY [0..1023] OF COMPLEX; // FFT Result (1024 complex numbers)\nVAR\n    TempBuffer : ARRAY [0..1023] OF REAL;\n    Stage : INT := 0;\n    BitReverse : ARRAY [0..1023] OF INT;\n    N : INT := 1024; // Length of the input sequence\n    LogN : INT := 10; // Log base 2 of N (1024 is 2^10)\n    Radix2 : REAL := 2 * PI / N;\n    W : COMPLEX;\n    Wm : COMPLEX;\nEND_VAR\n\n// Bit reversal is not included for brevity\n\n// Main FFT computation loop\nWHILE Stage < LogN DO\n    // Calculate stride for this stage\n    Stride := POW(2, Stage);\n    HalfStride := Stride / 2;\n    \n    // Twiddle factor initialization\n    W := POLAR(1, -Radix2 * Stage);\n    \n    // Butterfly operations\n    FOR k := 0 TO N BY Stride DO\n        Wm := 1;\n        FOR m := 0 TO HalfStride - 1 DO\n            // Butterfly operation\n            EVEN := k + m;\n            ODD := EVEN + HalfStride;\n            Temp := FFTResult[EVEN];\n            FFTResult[EVEN] := Temp + Wm * FFTResult[ODD];\n            FFTResult[ODD] := Temp - Wm * FFTResult[ODD];\n            Wm := Wm * W;\n        END_FOR\n    END_FOR\n    \n    Stage := Stage + 1;\nEND_WHILE\n\n// Output the result\nFFTResult := FFTResult;\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Fast Fourier Transform.md",
        "path": "Reference Solutions/Mathematical Functions/Fast Fourier Transform.md"
    },
    {
        "filename": "Linear Interpolation.md",
        "content": "```\nFUNCTION_BLOCK LinearInterpolation\nVAR_INPUT\n    x : REAL; // The x value at which to interpolate\n    x1 : REAL; // The x-coordinate of the first point\n    y1 : REAL; // The y-coordinate of the first point\n    x2 : REAL; // The x-coordinate of the second point\n    y2 : REAL; // The y-coordinate of the second point\nVAR_OUTPUT\n    y : REAL; // The interpolated y value\nEND_VAR\n\n// Ensure the points are ordered such that x1 <= x <= x2\nIF x < x1 THEN\n    y := y1;\nELSIF x > x2 THEN\n    y := y2;\nELSE\n    // Linear interpolation formula: y = y1 + (y2 - y1) * (x - x1) / (x2 - x1)\n    y := y1 + ((y2 - y1) * (x - x1)) / (x2 - x1);\nEND_IF;\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Linear Interpolation.md",
        "path": "Reference Solutions/Mathematical Functions/Linear Interpolation.md"
    },
    {
        "filename": "Linear Programming.md",
        "content": "```\nFUNCTION_BLOCK SimplexSolver\nVAR_INPUT\n    A : ARRAY [1..10, 1..10] OF REAL; // Coefficients of the constraints\n    b : ARRAY [1..10] OF REAL; // Right-hand side of the constraints\n    c : ARRAY [1..10] OF REAL; // Coefficients of the objective function\nVAR_OUTPUT\n    solution : ARRAY [1..10] OF REAL; // Solution vector\n    optimal_value : REAL; // Optimal value of the objective function\nVAR\n    tableau : ARRAY [1..11, 1..11] OF REAL; // Simplex tableau\n    pivot_row : INT; // Index of the pivot row\n    pivot_column : INT; // Index of the pivot column\n    iterations : INT := 0; // Counter for iterations\n    max_iterations : INT := 1000; // Maximum allowed iterations\n    n : INT := 10; // Number of variables\n    m : INT := 10; // Number of constraints\nEND_VAR\n\n// Initialize the tableau with the augmented form of the LP problem\nFOR i := 1 TO m DO\n    FOR j := 1 TO n DO\n        tableau[i, j] := A[i, j];\n    END_FOR\n    tableau[i, n + i] := 1; // Identity matrix for slack variables\n    tableau[i, n + m + 1] := b[i]; // RHS\nEND_FOR\nFOR j := 1 TO n DO\n    tableau[m + 1, j] := -c[j]; // Objective function coefficients\nEND_FOR\n\n// Begin the Simplex algorithm\nWHILE iterations < max_iterations DO\n    pivot_column := FindPivotColumn(tableau); // Find the column with the most negative entry in the last row\n    \n    // If no negative entries are found, the solution is optimal\n    IF pivot_column = 0 THEN\n        optimal_value := tableau[m + 1, n + m + 1];\n        FOR j := 1 TO n DO\n            solution[j] := tableau[m + 1, j];\n        END_FOR\n        EXIT;\n    END_IF\n    \n    pivot_row := FindPivotRow(tableau, pivot_column); // Find the row with the smallest ratio\n    IF pivot_row = 0 THEN\n        // If no row satisfies the ratio test, the problem is unbounded\n        optimal_value := -INF;\n        EXIT;\n    END_IF\n    \n    // Pivot operation to update the tableau\n    PivotOperation(tableau, pivot_row, pivot_column);\n    \n    iterations := iterations + 1;\nEND_WHILE\n\noptimal_value := -INF; // Indicate failure if maximum iterations reached\nsolution := ANY; // Indicate failure\n\n// Helper functions for the Simplex algorithm\nFUNCTION FindPivotColumn(Tableau : ARRAY [1..11, 1..11] OF REAL) : INT;\n    // Implementation of finding the pivot column\nEND_FUNCTION\n\nFUNCTION FindPivotRow(Tableau : ARRAY [1..11, 1..11] OF REAL; PivotColumn : INT) : INT;\n    // Implementation of finding the pivot row\nEND_FUNCTION\n\nFUNCTION PivotOperation(Tableau : ARRAY [1..11, 1..11] OF REAL; PivotRow, PivotColumn : INT);\n    // Implementation of the pivot operation\nEND_FUNCTION\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Linear Programming.md",
        "path": "Reference Solutions/Mathematical Functions/Linear Programming.md"
    },
    {
        "filename": "Matrix Multiplication.md",
        "content": "```\nFUNCTION_BLOCK MatrixMultiply\nVAR_INPUT\n    MatrixA : ARRAY [1..4, 1..4] OF REAL; // First matrix\n    MatrixB : ARRAY [1..4, 1..4] OF REAL; // Second matrix\nVAR_OUTPUT\n    Product : ARRAY [1..4, 1..4] OF REAL; // Resultant matrix product\nVAR\n    i, j, k : INT; // Loop counters\nEND_VAR\n\n// Initialize the product matrix with zeros\nFOR i := 1 TO 4 DO\n    FOR j := 1 TO 4 DO\n        Product[i, j] := 0;\n    END_FOR\nEND_FOR\n\n// Matrix multiplication\nFOR i := 1 TO 4 DO\n    FOR j := 1 TO 4 DO\n        FOR k := 1 TO 4 DO\n            // Accumulate the product of the corresponding row and column elements\n            Product[i, j] := Product[i, j] + MatrixA[i, k] * MatrixB[k, j];\n        END_FOR\n    END_FOR\nEND_FOR\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Matrix Multiplication.md",
        "path": "Reference Solutions/Mathematical Functions/Matrix Multiplication.md"
    },
    {
        "filename": "Mean and StdDev.md",
        "content": "```\nFUNCTION_BLOCK MeanStdDev\nVAR_INPUT\n    Data : ARRAY [1..100] OF INT; // Input array of 100 integers\nVAR_OUTPUT\n    Mean : REAL; // Mean value\n    StdDev : REAL; // Standard deviation\nVAR\n    Sum : REAL := 0; // Sum of the elements\n    SumOfSquares : REAL := 0; // Sum of the squares of the elements\n    N : INT := 100; // Number of elements in the array\n    Element : REAL; // Temporary variable for element conversion\nEND_VAR\n\n// Calculate the sum of the elements\nFOR i := 1 TO N DO\n    Element := REAL(Data[i]); // Convert integer to real to avoid overflow\n    Sum := Sum + Element;\nEND_FOR\n\n// Calculate the mean\nMean := Sum / REAL(N);\n\n// Calculate the sum of the squares of the elements\nFOR i := 1 TO N DO\n    Element := REAL(Data[i]);\n    SumOfSquares := SumOfSquares + (Element - Mean) * (Element - Mean);\nEND_FOR\n\n// Calculate the standard deviation\nStdDev := SQRT(SumOfSquares / REAL(N));\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Mean and StdDev.md",
        "path": "Reference Solutions/Mathematical Functions/Mean and StdDev.md"
    },
    {
        "filename": "Natural Logarithm.md",
        "content": "```\nFUNCTION_BLOCK NaturalLogarithm\nVAR_INPUT\n    Input : REAL; // Input value for which the natural logarithm is computed\nVAR_OUTPUT\n    Result : REAL; // The natural logarithm of the input value\nVAR\n    epsilon : REAL := 1E-9; // Small positive number to handle edge cases\nEND_VAR\n\n// Check if the input is positive\nIF Input > 0 THEN\n    // Compute the natural logarithm using the built-in function\n    Result := LN(Input);\nELSIF Input = 0 THEN\n    // Handle the case where the input is zero\n    Result := -INF; // Negative infinity represents undefined ln(0)\nELSE\n    // Handle the case where the input is negative\n    Result := -INF; // Negative infinity represents undefined ln(x) for x < 0\nEND_IF;\n\n// Additional check to handle very small positive numbers close to zero\nIF Input < epsilon THEN\n    Result := -INF; // Negative infinity for values too close to zero\nEND_IF;\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Natural Logarithm.md",
        "path": "Reference Solutions/Mathematical Functions/Natural Logarithm.md"
    },
    {
        "filename": "Poisson Distribution.md",
        "content": "```\nFUNCTION_BLOCK PoissonDistribution\nVAR_INPUT\n    Lambda : REAL; // Mean of the Poisson distribution\n    K : INT; // Input value (number of occurrences)\nVAR_OUTPUT\n    Probability : REAL; // Probability of K occurrences\nVAR\n    FactorialCache : ARRAY [0..100] OF REAL; // Cache for factorial calculations\n    Sum : REAL := 0; // Accumulator for the Poisson probability\n    FactorialK : REAL := 1; // Factorial of K\n    Term : REAL; // Intermediate term in the Poisson formula\n    OverflowDetected : BOOL := FALSE; // Flag for detecting overflow\nEND_VAR\n\n// Initialize the factorial cache\nFOR i := 0 TO 100 DO\n    IF i = 0 THEN\n        FactorialCache[i] := 1;\n    ELSE\n        FactorialCache[i] := FactorialCache[i-1] * REAL(i);\n    END_IF;\nEND_FOR;\n\n// Check for valid input values\nIF Lambda >= 0 AND K >= 0 THEN\n    // Use cached factorials for efficiency\n    IF K <= 100 THEN\n        FactorialK := FactorialCache[K];\n    ELSE\n        // Calculate factorial for larger K values\n        OverflowDetected := TRUE;\n        FOR i := 1 TO K DO\n            FactorialK := FactorialK * REAL(i);\n            IF IS_OVERFLOW(FactorialK) THEN\n                OverflowDetected := TRUE;\n                EXIT;\n            END_IF;\n        END_FOR;\n    END_IF;\n    \n    // Calculate the Poisson probability\n    IF NOT OverflowDetected THEN\n        Term := EXP(-Lambda) * POWER(Lambda, K);\n        Probability := Term / FactorialK;\n    ELSE\n        Probability := 0; // Set to zero if overflow occurred\n    END_IF;\nELSE\n    Probability := 0; // Invalid input values\nEND_IF;\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Poisson Distribution.md",
        "path": "Reference Solutions/Mathematical Functions/Poisson Distribution.md"
    },
    {
        "filename": "Sine Function.md",
        "content": "```\nFUNCTION_BLOCK SineCalculation\nVAR_INPUT\n    Angle : REAL; // Angle in radians for which sine is to be calculated\nVAR_OUTPUT\n    SineValue : REAL; // Computed sine value\nVAR\n    SeriesTerms : ARRAY [0..5] OF REAL; // Terms of the Taylor series expansion\n    FactorialCache : ARRAY [0..5] OF REAL; // Cache for factorial calculations\n    CurrentTerm : REAL; // Current term in the series expansion\n    Sign : REAL := 1; // Sign of the current term (+1/-1)\nEND_VAR\n\n// Initialize the factorial cache for the first few terms\nFOR i := 0 TO 5 DO\n    IF i = 0 THEN\n        FactorialCache[i] := 1;\n    ELSE\n        FactorialCache[i] := FactorialCache[i-1] * REAL(i);\n    END_IF;\nEND_FOR;\n\n// Compute the sine using the Taylor series expansion\nFOR i := 0 TO 5 DO\n    CurrentTerm := POWER(Angle, 2*i + 1) / FactorialCache[2*i + 1];\n    SeriesTerms[i] := CurrentTerm * Sign;\n    Sign := -Sign; // Alternate the sign for the next term\nEND_FOR;\n\n// Sum the series terms to get the sine value\nFOR i := 0 TO 5 DO\n    SineValue := SineValue + SeriesTerms[i];\nEND_FOR;\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Sine Function.md",
        "path": "Reference Solutions/Mathematical Functions/Sine Function.md"
    },
    {
        "filename": "Spline Interpolation.md",
        "content": "```\nFUNCTION_BLOCK SplineInterpolation\nVAR_INPUT\n    X : ARRAY [1..N] OF REAL; // X-coordinates of data points\n    Y : ARRAY [1..N] OF REAL; // Y-coordinates of data points\n    XQuery : REAL; // X-coordinate for which to interpolate Y\nVAR_OUTPUT\n    YInterpolated : REAL; // Interpolated Y-value\nVAR\n    N : INT := CNT(X); // Number of data points\n    h : ARRAY [1..N-1] OF REAL; // Differences between consecutive X-values\n    alpha : ARRAY [1..N-1] OF REAL; // Intermediate values for spline coefficients\n    z : ARRAY [1..N] OF REAL; // Coefficients for second derivatives\n    u : ARRAY [1..N-1] OF REAL; // Intermediate values for solving tridiagonal system\n    y2 : ARRAY [1..N] OF REAL; // Second derivatives of the spline at knots\n    i : INT; // Index for finding the correct segment\n    a, b, c, d : REAL; // Coefficients of the cubic polynomial\nEND_VAR\n\n// Compute the differences between consecutive X-values\nFOR i := 1 TO N-1 DO\n    h[i] := X[i+1] - X[i];\nEND_FOR;\n\n// Compute alpha values\nFOR i := 1 TO N-1 DO\n    alpha[i] := (Y[i+1] - Y[i]) / h[i] - (Y[i] - Y[i-1]) / h[i-1];\nEND_FOR;\n\n// Solve the tridiagonal system for z values\nz[1] := 0; // Set the boundary conditions\nz[N] := 0; // Set the boundary conditions\nFOR i := 1 TO N-1 DO\n    u[i] := 2 * (h[i] + h[i-1]);\n    z[i+1] := (alpha[i] - h[i-1] * z[i]) / (u[i] - h[i-1] * z[i]);\nEND_FOR;\n\n// Compute the second derivatives\nFOR i := N-1 DOWNTO 1 DO\n    y2[i] := z[i] - h[i-1] * z[i+1];\nEND_FOR;\ny2[1] := 0; // Boundary condition\ny2[N] := 0; // Boundary condition\n\n// Find the correct segment and compute the interpolated value\ni := 1;\nWHILE XQuery > X[i+1] DO\n    i := i + 1;\nEND_WHILE;\n\na := Y[i];\nb := y2[i];\nc := (Y[i+1] - Y[i]) / h[i] - h[i] * (y2[i] + 2 * y2[i+1]) / 3;\nd := (y2[i] - y2[i+1]) / (3 * h[i]);\n\nYInterpolated := (a + b * (XQuery - X[i]) + c * POWER((XQuery - X[i]), 2) + d * POWER((XQuery - X[i]), 3));\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Spline Interpolation.md",
        "path": "Reference Solutions/Mathematical Functions/Spline Interpolation.md"
    },
    {
        "filename": "Automatic Car Wash Station Control Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM CarWashControl\nVAR\n    CarDetected : BOOL := FALSE; // Sensor detects a car\n    HumanDetected : BOOL := FALSE; // Sensor detects a human\n    WashInitiated : BOOL := FALSE; // Flag to indicate wash initiation\n    AlarmTriggered : BOOL := FALSE; // Flag to indicate an alarm has been triggered\n    SafeState : BOOL := TRUE; // Initial state is safe\n    WashActive : BOOL := FALSE; // Indicates if the wash process is active\n    WashCompleted : BOOL := FALSE; // Indicates if the wash process is completed\n    Timer : TIME; // Timer to manage wash duration\n    TimerDuration : TIME := T#20s; // Duration of the wash process\nEND_VAR\n\n// Main control logic\nIF CarDetected AND (NOT HumanDetected) THEN\n    // If a car is detected and no human is present, start the wash process\n    WashInitiated := TRUE;\nELSIF HumanDetected THEN\n    // If a human is detected, stop the wash process and trigger an alarm\n    WashInitiated := FALSE;\n    WashActive := FALSE;\n    AlarmTriggered := TRUE;\n    SafeState := FALSE;\nEND_IF;\n\nIF WashInitiated AND (NOT WashActive) THEN\n    // If the wash is initiated and not yet active, start the wash process\n    WashActive := TRUE;\n    Timer := T#0s;\nEND_IF;\n\nIF WashActive THEN\n    // If the wash process is active, run the wash cycle\n    Timer := Timer + T#1s;\n    IF Timer >= TimerDuration THEN\n        // If the timer reaches the duration, mark the wash as complete\n        WashCompleted := TRUE;\n        WashActive := FALSE;\n    END_IF;\nEND_IF;\n\nIF AlarmTriggered THEN\n    // If an alarm is triggered, maintain a safe state until cleared\n    SafeState := FALSE;\nEND_IF;\n\nIF WashCompleted THEN\n    // If the wash is completed, reset the system\n    WashInitiated := FALSE;\n    WashActive := FALSE;\n    WashCompleted := FALSE;\n    Timer := T#0s;\nEND_IF;\n\n// Output control signals\nIF WashActive THEN\n    // Activate the wash equipment\n    // Example: MotorOn := TRUE;\n    // Example: SprayOn := TRUE;\nELSIF NOT SafeState THEN\n    // Trigger alarms and safety equipment\n    // Example: SoundAlarm := TRUE;\n    // Example: SafetyLights := TRUE;\nEND_IF;\n\n// External sensor inputs\n// Example: CarDetected := CarSensor;\n// Example: HumanDetected := HumanSensor;\n\n// Reset the system if it's safe again\nIF NOT HumanDetected AND NOT WashActive AND NOT WashInitiated THEN\n    SafeState := TRUE;\n    AlarmTriggered := FALSE;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Car Detected\", CarDetected);\n// Example: Write(\"Human Detected\", HumanDetected);\n// Example: Write(\"Wash Active\", WashActive);\n// Example: Write(\"Safe State\", SafeState);\n// Example: Write(\"Timer\", Timer);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Automatic Car Wash Station Control Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Automatic Car Wash Station Control Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Coffee Maker Control Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM CoffeeMachineControl\nVAR\n    TankLevel : INT := 0; // Level of the mixer tank (0-130 ml)\n    MixerRunning : BOOL := FALSE; // Indicates if the mixer is running\n    MixingTime : TIME := T#4s; // Duration for the mixer to run\n    MixTimer : TIME := T#0s; // Timer for the mixing process\n    OutputOpen : BOOL := FALSE; // Indicates if the output valve is open\n    CoffeeValveOpen : BOOL := FALSE; // Indicates if the coffee valve is open\n    MilkValveOpen : BOOL := FALSE; // Indicates if the milk valve is open\n    EmergencyStop : BOOL := FALSE; // Emergency stop button status\n    StartButton : BOOL := FALSE; // Start button status\n    CoffeeMilkButton : BOOL := FALSE; // Coffee and milk button status\n    CoffeeOnlyButton : BOOL := FALSE; // Coffee only button status\n    IsMixing : BOOL := FALSE; // Indicates if the system is currently mixing\n    IsDispensing : BOOL := FALSE; // Indicates if the system is dispensing\nEND_VAR\n\n// Main control logic\nIF EmergencyStop THEN\n    // If emergency stop is pressed, halt all operations and reset the system\n    CoffeeValveOpen := FALSE;\n    MilkValveOpen := FALSE;\n    MixerRunning := FALSE;\n    OutputOpen := FALSE;\n    MixTimer := T#0s;\n    TankLevel := 0;\nELSIF StartButton THEN\n    // If start button is pressed, begin the coffee-making process\n    IF CoffeeMilkButton THEN\n        // If coffee and milk button is pressed, prepare coffee with milk\n        CoffeeValveOpen := TRUE;\n        MilkValveOpen := TRUE;\n    ELSIF CoffeeOnlyButton THEN\n        // If coffee only button is pressed, prepare coffee without milk\n        CoffeeValveOpen := TRUE;\n        MilkValveOpen := FALSE;\n    END_IF;\nEND_IF;\n\n// Fill the mixer tank\nIF CoffeeValveOpen OR MilkValveOpen THEN\n    IF TankLevel < 130 THEN\n        // Increment the tank level\n        TankLevel := TankLevel + 1;\n    ELSE\n        // If the tank is full, close the valves and start mixing\n        CoffeeValveOpen := FALSE;\n        MilkValveOpen := FALSE;\n        MixerRunning := TRUE;\n        IsMixing := TRUE;\n        MixTimer := T#0s;\n    END_IF;\nEND_IF;\n\n// Mixing process\nIF IsMixing THEN\n    MixTimer := MixTimer + T#1s;\n    IF MixTimer >= MixingTime THEN\n        // If mixing is complete, open the output valve\n        MixerRunning := FALSE;\n        OutputOpen := TRUE;\n        IsMixing := FALSE;\n        IsDispensing := TRUE;\n    END_IF;\nEND_IF;\n\n// Dispensing process\nIF IsDispensing THEN\n    // After dispensing, reset the system\n    IF TankLevel > 0 THEN\n        TankLevel := TankLevel - 1;\n    ELSE\n        OutputOpen := FALSE;\n        IsDispensing := FALSE;\n    END_IF;\nEND_IF;\n\n// Safety features\nIF EmergencyStop THEN\n    // If emergency stop is pressed, ensure all operations cease\n    CoffeeValveOpen := FALSE;\n    MilkValveOpen := FALSE;\n    MixerRunning := FALSE;\n    OutputOpen := FALSE;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Tank Level\", TankLevel);\n// Example: Write(\"Coffee Valve Open\", CoffeeValveOpen);\n// Example: Write(\"Milk Valve Open\", MilkValveOpen);\n// Example: Write(\"Output Open\", OutputOpen);\n// Example: Write(\"Emergency Stop\", EmergencyStop);\n// Example: Write(\"Start Button\", StartButton);\n// Example: Write(\"Coffee and Milk Button\", CoffeeMilkButton);\n// Example: Write(\"Coffee Only Button\", CoffeeOnlyButton);\n// Example: Write(\"Is Mixing\", IsMixing);\n// Example: Write(\"Is Dispensing\", IsDispensing);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Coffee Maker Control Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Coffee Maker Control Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Conveyor Belt Control Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM ConveyorBeltControl\nVAR\n    ConveyorSpeed : REAL := 2.0; // Conveyor belt speed in m/s\n    IsRunning : BOOL := FALSE; // Indicates if the conveyor is running\n    IsStopped : BOOL := TRUE; // Indicates if the conveyor is stopped\n    ObjectDetected : ARRAY [1..5] OF BOOL := (FALSE, FALSE, FALSE, FALSE, FALSE); // Array of sensor statuses\n    ManualStopStation1 : BOOL := FALSE; // Manual stop command from station 1\n    ManualStopStation2 : BOOL := FALSE; // Manual stop command from station 2\n    ManualStopStation3 : BOOL := FALSE; // Manual stop command from station 3\n    AutoMode : BOOL := TRUE; // Indicates if the system is in auto mode\n    ManualMode : BOOL := FALSE; // Indicates if the system is in manual mode\n    ConveyorMotor : BOOL := FALSE; // Indicates if the conveyor motor is powered\nEND_VAR\n\n// Main control logic\nIF AutoMode THEN\n    // Automatic mode logic\n    IF NOT IsStopped THEN\n        // Conveyor is running\n        FOR i := 1 TO 5 DO\n            IF NOT ObjectDetected[i] THEN\n                // If any sensor does not detect an object, stop the conveyor\n                IsRunning := FALSE;\n                IsStopped := TRUE;\n                ConveyorMotor := FALSE;\n                EXIT;\n            END_IF;\n        END_FOR;\n        \n        IF ManualStopStation1 OR ManualStopStation2 OR ManualStopStation3 THEN\n            // If any station triggers a stop command, stop the conveyor\n            IsRunning := FALSE;\n            IsStopped := TRUE;\n            ConveyorMotor := FALSE;\n        END_IF;\n        \n        // If no stop conditions are met, keep the conveyor running\n        IsRunning := TRUE;\n        ConveyorMotor := TRUE;\n    ELSE\n        // Conveyor is stopped\n        FOR i := 1 TO 5 DO\n            IF ObjectDetected[i] THEN\n                // If any sensor detects an object, start the conveyor\n                IsRunning := TRUE;\n                IsStopped := FALSE;\n                ConveyorMotor := TRUE;\n                EXIT;\n            END_IF;\n        END_FOR;\n    END_IF;\nELSIF ManualMode THEN\n    // Manual mode logic\n    IF NOT ManualStopStation1 AND NOT ManualStopStation2 AND NOT ManualStopStation3 THEN\n        // If no manual stop commands are active, start the conveyor\n        IsRunning := TRUE;\n        IsStopped := FALSE;\n        ConveyorMotor := TRUE;\n    ELSE\n        // If any manual stop command is active, stop the conveyor\n        IsRunning := FALSE;\n        IsStopped := TRUE;\n        ConveyorMotor := FALSE;\n    END_IF;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Conveyor Running\", IsRunning);\n// Example: Write(\"Manual Stop Station 1\", ManualStopStation1);\n// Example: Write(\"Manual Stop Station 2\", ManualStopStation2);\n// Example: Write(\"Manual Stop Station 3\", ManualStopStation3);\n// Example: Write(\"Object Detected 1\", ObjectDetected[1]);\n// Example: Write(\"Object Detected 2\", ObjectDetected[2]);\n// Example: Write(\"Object Detected 3\", ObjectDetected[3]);\n// Example: Write(\"Object Detected 4\", ObjectDetected[4]);\n// Example: Write(\"Object Detected 5\", ObjectDetected[5]);\n// Example: Write(\"Auto Mode\", AutoMode);\n// Example: Write(\"Manual Mode\", ManualMode);\n// Example: Write(\"Conveyor Motor\", ConveyorMotor);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Conveyor Belt Control Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Conveyor Belt Control Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Elevator Control System Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM ElevatorControlSystem\nVAR\n    CurrentFloor : INT := 1; // Current floor of the elevator (1-5)\n    Direction : INT := 0; // Direction of travel (-1 for down, 0 for stop, 1 for up)\n    DoorOpen : BOOL := FALSE; // Indicates if the elevator door is open\n    DoorOpenTimer : TIME := T#0s; // Timer for the door open period\n    DoorReopenTimer : TIME := T#0s; // Timer for the door reopen period\n    TopLimit : BOOL := FALSE; // Top limit switch status\n    BottomLimit : BOOL := FALSE; // Bottom limit switch status\n    CabinButtons : ARRAY [1..5] OF BOOL := (FALSE, FALSE, FALSE, FALSE, FALSE); // Cabin button status\n    FloorCallButtons : ARRAY [1..5] OF ARRAY [1..2] OF BOOL := ((FALSE, FALSE), (FALSE, FALSE), (FALSE, FALSE), (FALSE, FALSE), (FALSE, FALSE)); // Up/Down call button status for each floor\nEND_VAR\n\n// Main control logic\nIF TopLimit THEN\n    // If the elevator is at the top floor, set direction to stop\n    Direction := 0;\nELSIF BottomLimit THEN\n    // If the elevator is at the bottom floor, set direction to stop\n    Direction := 0;\nELSE\n    // Determine the direction based on call buttons and current floor\n    IF FloorCallButtons[CurrentFloor][1] OR FloorCallButtons[CurrentFloor][2] THEN\n        // If there is a call at the current floor, ignore it if already there\n    ELSE\n        Direction := FindDirection(FloorCallButtons, CabinButtons, CurrentFloor);\n    END_IF;\nEND_IF;\n\n// Move the elevator\nIF Direction = 1 THEN\n    // Move up\n    CurrentFloor := CurrentFloor + 1;\nELSIF Direction = -1 THEN\n    // Move down\n    CurrentFloor := CurrentFloor - 1;\nEND_IF;\n\n// Handle door operations\nIF DoorOpen THEN\n    // Door is open\n    DoorOpenTimer := DoorOpenTimer + T#1s;\n    IF DoorOpenTimer >= T#7s THEN\n        // If the door has been open for 7 seconds\n        DoorOpen := FALSE;\n        DoorOpenTimer := T#0s;\n        IF NOT (CabinButtons[CurrentFloor] OR CabinButtons[CurrentFloor+1] OR CabinButtons[CurrentFloor+2] OR CabinButtons[CurrentFloor+3] OR CabinButtons[CurrentFloor+4]) THEN\n            // If no cabin buttons are pressed, reopen the door for 10 seconds\n            DoorReopenTimer := T#0s;\n            DoorOpen := TRUE;\n        END_IF;\n    END_IF;\nELSIF DoorReopenTimer >= T#10s THEN\n    // If the door has been reopened for 10 seconds, close the door\n    DoorOpen := FALSE;\n    DoorReopenTimer := T#0s;\nEND_IF;\n\n// Open the door when the elevator stops at a floor\nIF CurrentFloor MOD 1 = 0 THEN\n    // If the elevator has stopped at a floor\n    DoorOpen := TRUE;\n    DoorOpenTimer := T#0s;\n    DoorReopenTimer := T#0s;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Current Floor\", CurrentFloor);\n// Example: Write(\"Direction\", Direction);\n// Example: Write(\"Door Open\", DoorOpen);\n// Example: Write(\"Door Open Timer\", DoorOpenTimer);\n// Example: Write(\"Top Limit\", TopLimit);\n// Example: Write(\"Bottom Limit\", BottomLimit);\n// Example: Write(\"Cabin Buttons\", CabinButtons);\n// Example: Write(\"Floor Call Buttons\", FloorCallButtons);\n\nEND_PROGRAM\n\nFUNCTION FindDirection : INT (FloorCallButtons : ARRAY [1..5] OF ARRAY [1..2] OF BOOL; CabinButtons : ARRAY [1..5] OF BOOL; CurrentFloor : INT)\nVAR\n    NextFloorUp : INT := CurrentFloor + 1; // Next floor going up\n    NextFloorDown : INT := CurrentFloor - 1; // Next floor going down\n    UpCallActive : BOOL := FALSE; // Up call button active at the next floor\n    DownCallActive : BOOL := FALSE; // Down call button active at the next floor\n    CabinCallActive : BOOL := FALSE; // Cabin button active for the next floor\nEND_VAR\n\n// Determine if there is a call to go up or down\nUpCallActive := FloorCallButtons[NextFloorUp][1];\nDownCallActive := FloorCallButtons[NextFloorDown][2];\nCabinCallActive := CabinButtons[NextFloorUp];\n\n// Set direction based on calls and current floor\nIF UpCallActive OR CabinCallActive THEN\n    FindDirection := 1; // Set direction to up\nELSIF DownCallActive THEN\n    FindDirection := -1; // Set direction to down\nELSE\n    FindDirection := 0; // Set direction to stop\nEND_IF;\n\nEND_FUNCTION\n```\n",
        "description": "Markdown file from Elevator Control System Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Elevator Control System Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Empty Bottle Removal for Packaging Line Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM EmptyBottleRemoval\nVAR\n    AnyBottleDetected : BOOL := FALSE; // Proximity sensor for any bottle\n    EmptyBottleDetected : BOOL := FALSE; // Proximity sensor for empty bottle\n    CylinderActivated : BOOL := FALSE; // Pneumatic cylinder activation status\n    ConveyorRunning : BOOL := TRUE; // Conveyor operation status\n    CylinderActivationDelay : TIME := T#0s; // Delay timer for cylinder activation\n    CylinderActivationTime : TIME := T#1s; // Time delay before activating the cylinder\n    BottleRemovalDelay : TIME := T#2s; // Delay timer for bottle removal\n    BottleRemovalTime : TIME := T#2s; // Time delay before deactivating the cylinder\nEND_VAR\n\n// Main control logic\nIF AnyBottleDetected AND EmptyBottleDetected THEN\n    // If an empty bottle is detected, activate the cylinder after a delay\n    CylinderActivationDelay := CylinderActivationDelay + T#100ms;\n    IF CylinderActivationDelay >= CylinderActivationTime THEN\n        CylinderActivated := TRUE;\n        CylinderActivationDelay := T#0s;\n    END_IF;\nELSIF CylinderActivated THEN\n    // After removing the empty bottle, deactivate the cylinder\n    BottleRemovalDelay := BottleRemovalDelay + T#100ms;\n    IF BottleRemovalDelay >= BottleRemovalTime THEN\n        CylinderActivated := FALSE;\n        BottleRemovalDelay := T#0s;\n    END_IF;\nEND_IF;\n\n// Conveyor control\nIF NOT CylinderActivated THEN\n    // Keep the conveyor running unless the cylinder is activated\n    ConveyorRunning := TRUE;\nELSE\n    // Stop the conveyor when the cylinder is activated\n    ConveyorRunning := FALSE;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Any Bottle Detected\", AnyBottleDetected);\n// Example: Write(\"Empty Bottle Detected\", EmptyBottleDetected);\n// Example: Write(\"Cylinder Activated\", CylinderActivated);\n// Example: Write(\"Conveyor Running\", ConveyorRunning);\n// Example: Write(\"Cylinder Activation Delay\", CylinderActivationDelay);\n// Example: Write(\"Bottle Removal Delay\", BottleRemovalDelay);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Empty Bottle Removal for Packaging Line Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Empty Bottle Removal for Packaging Line Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Entry and Exit Control for Underground Car Park Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM CarParkControl\nVAR\n    // Sensors\n    X1 : BOOL; // Photoelectric switch at the ground floor entry/exit\n    X2 : BOOL; // Photoelectric switch at the basement entry/exit\n    \n    // Intermediate variables\n    M1 : BOOL := FALSE; // ON for one scan cycle when a car from the ground floor passes X1\n    M2 : BOOL := FALSE; // ON for one scan cycle when a car from the basement passes X1\n    M3 : BOOL := FALSE; // ON for one scan cycle when a car from the basement passes X2\n    M4 : BOOL := FALSE; // ON for one scan cycle when a car from the ground floor passes X2\n    M20 : BOOL := FALSE; // ON during the process of a car entering from the ground floor\n    M30 : BOOL := FALSE; // ON during the process of a car entering from the basement\n    \n    // Output devices\n    Y1 : BOOL := FALSE; // Red lights at the entry/exit of the ground floor and the basement\n    Y2 : BOOL := TRUE; // Green lights at the entry/exit of the ground floor and the basement\nEND_VAR\n\n// Main control logic\nIF X1 AND NOT M1 THEN\n    // A car is entering from the ground floor\n    M1 := TRUE;\n    M20 := TRUE;\n    Y1 := TRUE;\n    Y2 := FALSE;\nELSIF X2 AND NOT M4 THEN\n    // A car is exiting to the ground floor\n    M4 := TRUE;\n    M20 := FALSE;\n    Y1 := FALSE;\n    Y2 := TRUE;\nELSIF X1 AND NOT M3 THEN\n    // A car is exiting to the basement\n    M3 := TRUE;\n    M30 := FALSE;\n    Y1 := FALSE;\n    Y2 := TRUE;\nELSIF X2 AND NOT M2 THEN\n    // A car is entering from the basement\n    M2 := TRUE;\n    M30 := TRUE;\n    Y1 := TRUE;\n    Y2 := FALSE;\nELSIF M1 AND NOT X1 THEN\n    // A car has passed through from the ground floor\n    M1 := FALSE;\n    M20 := FALSE;\n    Y1 := FALSE;\n    Y2 := TRUE;\nELSIF M2 AND NOT X1 THEN\n    // A car has passed through from the basement\n    M2 := FALSE;\n    M30 := FALSE;\n    Y1 := FALSE;\n    Y2 := TRUE;\nELSIF M3 AND NOT X2 THEN\n    // A car has passed through to the basement\n    M3 := FALSE;\n    M30 := FALSE;\n    Y1 := FALSE;\n    Y2 := TRUE;\nELSIF M4 AND NOT X2 THEN\n    // A car has passed through to the ground floor\n    M4 := FALSE;\n    M20 := FALSE;\n    Y1 := FALSE;\n    Y2 := TRUE;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"X1\", X1);\n// Example: Write(\"X2\", X2);\n// Example: Write(\"M1\", M1);\n// Example: Write(\"M2\", M2);\n// Example: Write(\"M3\", M3);\n// Example: Write(\"M4\", M4);\n// Example: Write(\"M20\", M20);\n// Example: Write(\"M30\", M30);\n// Example: Write(\"Y1\", Y1);\n// Example: Write(\"Y2\", Y2);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Entry and Exit Control for Underground Car Park Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Entry and Exit Control for Underground Car Park Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Heating System Control Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM HeatingSystemControl\nVAR\n    // Input sensors\n    TempSensor1 : REAL; // Temperature sensor 1 reading\n    TempSensor2 : REAL; // Temperature sensor 2 reading\n    TempSensor3 : REAL; // Temperature sensor 3 reading\n    \n    // Intermediate variables\n    AvgTemp : REAL; // Average temperature calculated from the sensors\n    HeatingOn : BOOL := FALSE; // Indicates whether the heater is ON\n    HeaterFault : BOOL := FALSE; // Indicates if there is a fault condition\n    MinTemp : REAL := 20.0; // Minimum desired temperature\n    MaxTemp : REAL := 22.0; // Maximum desired temperature\n    Hysteresis : REAL := 0.5; // Temperature hysteresis to minimize switching\n    HeaterCycleTime : TIME := T#5s; // Time delay to prevent rapid switching\n    HeaterCycleTimer : TIME := T#0s; // Timer for heater cycling\nEND_VAR\n\n// Calculate average temperature from the three sensors\nAvgTemp := (TempSensor1 + TempSensor2 + TempSensor3) / 3.0;\n\n// Check for sensor faults\nIF (TempSensor1 < 0.0 OR TempSensor1 > 50.0) OR (TempSensor2 < 0.0 OR TempSensor2 > 50.0) OR (TempSensor3 < 0.0 OR TempSensor3 > 50.0) THEN\n    HeaterFault := TRUE;\nELSIF AvgTemp < MinTemp - Hysteresis THEN\n    // Turn the heater ON if below minimum temperature minus hysteresis\n    HeatingOn := TRUE;\nELSIF AvgTemp > MaxTemp + Hysteresis THEN\n    // Turn the heater ON if above maximum temperature plus hysteresis\n    HeatingOn := TRUE;\nELSIF AvgTemp < MinTemp THEN\n    // Turn the heater ON if below minimum temperature but within hysteresis\n    HeatingOn := TRUE;\nELSIF AvgTemp > MaxTemp THEN\n    // Turn the heater OFF if above maximum temperature but within hysteresis\n    HeatingOn := FALSE;\nELSIF HeatingOn AND AvgTemp <= MaxTemp - Hysteresis THEN\n    // Turn the heater OFF if the temperature drops below max temp minus hysteresis\n    HeatingOn := FALSE;\nELSIF NOT HeatingOn AND AvgTemp >= MinTemp + Hysteresis THEN\n    // Turn the heater ON if the temperature rises above min temp plus hysteresis\n    HeatingOn := TRUE;\nELSIF HeatingOn THEN\n    // If the heater is ON, wait for the cycle time before checking again\n    HeaterCycleTimer := HeaterCycleTimer + T#1s;\n    IF HeaterCycleTimer >= HeaterCycleTime THEN\n        HeatingOn := FALSE;\n        HeaterCycleTimer := T#0s;\n    END_IF;\nELSIF NOT HeatingOn THEN\n    // If the heater is OFF, wait for the cycle time before checking again\n    HeaterCycleTimer := HeaterCycleTimer + T#1s;\n    IF HeaterCycleTimer >= HeaterCycleTime THEN\n        HeatingOn := TRUE;\n        HeaterCycleTimer := T#0s;\n    END_IF;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Average Temperature\", AvgTemp);\n// Example: Write(\"Heating On\", HeatingOn);\n// Example: Write(\"Heater Fault\", HeaterFault);\n// Example: Write(\"Heater Cycle Timer\", HeaterCycleTimer);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Heating System Control Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Heating System Control Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Pick-and-Place Application for a Robot Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM PickAndPlaceRobot\nVAR\n    // Inputs\n    ManualButtonPressed : BOOL; // Manual mode activation button\n    AutoButtonPressed : BOOL; // Auto mode activation button\n    ClipCommand : BOOL; // Manual command to clip the product\n    TransferCommand : BOOL; // Manual command to transfer the product\n    ReleaseCommand : BOOL; // Manual command to release the product\n    \n    // Outputs\n    ClipAction : BOOL := FALSE; // Action to clip the product\n    TransferAction : BOOL := FALSE; // Action to transfer the product\n    ReleaseAction : BOOL := FALSE; // Action to release the product\n    \n    // Internal Flags and Timers\n    ManualModeActive : BOOL := FALSE; // Flag to indicate Manual mode is active\n    AutoModeActive : BOOL := FALSE; // Flag to indicate Auto mode is active\n    AutoClipAction : BOOL := FALSE; // Flag to indicate the auto clip action is active\n    AutoTransferAction : BOOL := FALSE; // Flag to indicate the auto transfer action is active\n    AutoTransferTimer : TIME := T#0s; // Timer for the auto transfer action\n    AutoReleaseAction : BOOL := FALSE; // Flag to indicate the auto release action is active\n    InterlockTimer : TIME := T#0s; // Timer to prevent immediate re-activation of modes\n    InterlockDelay : TIME := T#2s; // Delay time to prevent immediate re-activation of modes\nEND_VAR\n\n// Manual Mode Logic\nIF ManualButtonPressed AND NOT ManualModeActive AND NOT AutoModeActive THEN\n    ManualModeActive := TRUE;\n    AutoModeActive := FALSE;\n    InterlockTimer := T#0s; // Reset interlock timer\nELSIF NOT ManualButtonPressed THEN\n    ManualModeActive := FALSE;\nEND_IF;\n\n// Auto Mode Logic\nIF AutoButtonPressed AND NOT AutoModeActive AND NOT ManualModeActive THEN\n    AutoModeActive := TRUE;\n    ManualModeActive := FALSE;\n    InterlockTimer := T#0s; // Reset interlock timer\nELSIF NOT AutoButtonPressed THEN\n    AutoModeActive := FALSE;\nEND_IF;\n\n// Interlock Logic\nIF (ManualButtonPressed OR AutoButtonPressed) AND InterlockTimer < InterlockDelay THEN\n    InterlockTimer := InterlockTimer + T#100ms; // Increment interlock timer\nELSIF InterlockTimer >= InterlockDelay THEN\n    InterlockTimer := T#0s; // Reset interlock timer\nEND_IF;\n\n// Manual Mode Commands\nIF ManualModeActive THEN\n    ClipAction := ClipCommand;\n    TransferAction := TransferCommand;\n    ReleaseAction := ReleaseCommand;\nEND_IF;\n\n// Auto Mode Process\nIF AutoModeActive THEN\n    // Clip Phase\n    IF NOT AutoClipAction THEN\n        ClipAction := TRUE;\n        AutoClipAction := TRUE;\n    END_IF;\n    \n    // Transfer Phase\n    IF AutoClipAction AND NOT AutoTransferAction THEN\n        ClipAction := FALSE;\n        TransferAction := TRUE;\n        AutoTransferAction := TRUE;\n        AutoTransferTimer := T#0s;\n    END_IF;\n    \n    IF AutoTransferAction AND AutoTransferTimer < T#2s THEN\n        AutoTransferTimer := AutoTransferTimer + T#100ms;\n    ELSIF AutoTransferAction AND AutoTransferTimer >= T#2s THEN\n        TransferAction := FALSE;\n        AutoTransferAction := FALSE;\n        AutoReleaseAction := TRUE;\n    END_IF;\n    \n    // Release Phase\n    IF AutoReleaseAction THEN\n        ReleaseAction := TRUE;\n        AutoReleaseAction := FALSE;\n        AutoModeActive := FALSE; // Complete one cycle of auto mode\n    END_IF;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Manual Mode Active\", ManualModeActive);\n// Example: Write(\"Auto Mode Active\", AutoModeActive);\n// Example: Write(\"Clip Action\", ClipAction);\n// Example: Write(\"Transfer Action\", TransferAction);\n// Example: Write(\"Release Action\", ReleaseAction);\n// Example: Write(\"Interlock Timer\", InterlockTimer);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Pick-and-Place Application for a Robot Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Pick-and-Place Application for a Robot Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Pneumatic System Control Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM PneumaticSystemControl\nVAR\n    // Inputs\n    PressureSensor : REAL; // Pressure sensor reading in bar\n    FlowSensor : REAL; // Flow sensor reading in standard liters per minute (SLPM)\n    \n    // Outputs\n    CompressorControl : BOOL := FALSE; // Control signal for compressor\n    ValveControl : BOOL := FALSE; // Control signal for flow control valve\n    \n    // Intermediate Variables\n    DesiredPressure : REAL := 5.75; // Desired pressure in bar (mid-point of range)\n    DesiredFlowRate : REAL := 50.0; // Desired flow rate in SLPM\n    PressureTolerance : REAL := 0.25; // Pressure tolerance band around the desired pressure\n    FlowRateTolerance : REAL := 5.0; // Flow rate tolerance band around the desired flow rate\n    ControlLoopFrequency : TIME := T#100ms; // Control loop frequency\n    CompressorTimer : TIME := T#0s; // Timer for compressor control delay\n    ValveTimer : TIME := T#0s; // Timer for valve control delay\n    CompressorDelay : TIME := T#2s; // Delay before compressor activates\n    ValveDelay : TIME := T#1s; // Delay before valve adjusts\nEND_VAR\n\n// Main control logic executed every 100 ms\nIF TCU(ControlLoopFrequency) THEN\n    // Pressure Control\n    IF PressureSensor < DesiredPressure - PressureTolerance THEN\n        // Pressure is too low, activate compressor\n        CompressorControl := TRUE;\n        CompressorTimer := T#0s;\n    ELSIF PressureSensor > DesiredPressure + PressureTolerance THEN\n        // Pressure is too high, deactivate compressor\n        CompressorControl := FALSE;\n        CompressorTimer := T#0s;\n    ELSE\n        // Pressure is within tolerance, maintain current state\n        CompressorControl := CompressorControl;\n    END_IF;\n    \n    // Flow Rate Control\n    IF FlowSensor < DesiredFlowRate - FlowRateTolerance THEN\n        // Flow rate is too low, open valve more\n        ValveControl := TRUE;\n        ValveTimer := T#0s;\n    ELSIF FlowSensor > DesiredFlowRate + FlowRateTolerance THEN\n        // Flow rate is too high, close valve more\n        ValveControl := FALSE;\n        ValveTimer := T#0s;\n    ELSE\n        // Flow rate is within tolerance, maintain current state\n        ValveControl := ValveControl;\n    END_IF;\n    \n    // Safety Checks\n    IF PressureSensor < 5.5 OR PressureSensor > 6.0 THEN\n        // Pressure out of safe range, shut down system\n        CompressorControl := FALSE;\n        ValveControl := FALSE;\n    END_IF;\n    \n    // Timers for delayed actions\n    IF CompressorControl AND CompressorTimer < CompressorDelay THEN\n        CompressorTimer := CompressorTimer + T#100ms;\n    END_IF;\n    \n    IF ValveControl AND ValveTimer < ValveDelay THEN\n        ValveTimer := ValveTimer + T#100ms;\n    END_IF;\n    \n    // Debugging outputs (for simulation purposes)\n    // Example: Write(\"Desired Pressure\", DesiredPressure);\n    // Example: Write(\"Desired Flow Rate\", DesiredFlowRate);\n    // Example: Write(\"Pressure Sensor\", PressureSensor);\n    // Example: Write(\"Flow Sensor\", FlowSensor);\n    // Example: Write(\"Compressor Control\", CompressorControl);\n    // Example: Write(\"Valve Control\", ValveControl);\n    // Example: Write(\"Compressor Timer\", CompressorTimer);\n    // Example: Write(\"Valve Timer\", ValveTimer);\nEND_IF;\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Pneumatic System Control Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Pneumatic System Control Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Traffic Light Control System Using 61131-3 Structured Text.md",
        "content": "```\nPROGRAM TrafficLightControl\nVAR\n    // Inputs\n    PedestrianButton : BOOL; // Pedestrian push button status\n    EmergencyVehicleDetected : BOOL; // Emergency vehicle detection status\n    CurrentPhase : INT := 0; // Current phase of the traffic lights (0=Red, 1=Yellow, 2=Green)\n    \n    // Outputs\n    RedLight : BOOL := TRUE; // Red light status\n    YellowLight : BOOL := FALSE; // Yellow light status\n    GreenLight : BOOL := FALSE; // Green light status\n    WalkSignal : BOOL := FALSE; // Walk signal status\n    \n    // Timers and Counters\n    TransitionTimer : TIME := T#0s; // Timer for transitioning between phases\n    TransitionDelay : TIME := T#3s; // Delay for transitioning between phases\n    GreenDuration : TIME := T#30s; // Duration for green light\n    YellowDuration : TIME := T#3s; // Duration for yellow light\n    PedestrianWaitTime : TIME := T#15s; // Wait time before pedestrian gets walk signal\n    EmergencyClearTime : TIME := T#10s; // Clear time for emergency vehicles\n    EmergencyClearTimer : TIME := T#0s; // Timer for emergency vehicle clear time\nEND_VAR\n\n// Main Control Logic\nCASE CurrentPhase OF\n    0: // Red phase\n        RedLight := TRUE;\n        YellowLight := FALSE;\n        GreenLight := FALSE;\n        WalkSignal := PedestrianButton AND TransitionTimer >= PedestrianWaitTime;\n        \n        // Emergency vehicle handling\n        IF EmergencyVehicleDetected THEN\n            EmergencyClearTimer := EmergencyClearTime;\n            EmergencyVehicleDetected := FALSE;\n        ELSE\n            IF TransitionTimer >= GreenDuration THEN\n                CurrentPhase := 1; // Transition to Yellow phase\n                TransitionTimer := T#0s;\n            END_IF;\n        END_IF;\n        \n    1: // Yellow phase\n        RedLight := FALSE;\n        YellowLight := TRUE;\n        GreenLight := FALSE;\n        WalkSignal := FALSE;\n        \n        IF TransitionTimer >= YellowDuration THEN\n            CurrentPhase := 2; // Transition to Green phase\n            TransitionTimer := T#0s;\n        END_IF;\n        \n    2: // Green phase\n        RedLight := FALSE;\n        YellowLight := FALSE;\n        GreenLight := TRUE;\n        WalkSignal := FALSE;\n        \n        IF TransitionTimer >= GreenDuration THEN\n            CurrentPhase := 0; // Transition to Red phase\n            TransitionTimer := T#0s;\n        END_IF;\n        \n        // Emergency vehicle handling\n        IF EmergencyVehicleDetected THEN\n            EmergencyClearTimer := EmergencyClearTime;\n            EmergencyVehicleDetected := FALSE;\n        END_IF;\n        \nEND_CASE;\n\n// Emergency Vehicle Handling\nIF EmergencyClearTimer > T#0s THEN\n    RedLight := TRUE;\n    YellowLight := FALSE;\n    GreenLight := FALSE;\n    WalkSignal := FALSE;\n    EmergencyClearTimer := EmergencyClearTimer - T#1s;\nEND_IF;\n\n// Increment Transition Timer\nIF TCU(T#1s) THEN\n    IF CurrentPhase = 1 OR CurrentPhase = 2 THEN\n        TransitionTimer := TransitionTimer + T#1s;\n    ELSE\n        IF PedestrianButton THEN\n            TransitionTimer := TransitionTimer + T#1s;\n        END_IF;\n    END_IF;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Current Phase\", CurrentPhase);\n// Example: Write(\"Red Light\", RedLight);\n// Example: Write(\"Yellow Light\", YellowLight);\n// Example: Write(\"Green Light\", GreenLight);\n// Example: Write(\"Walk Signal\", WalkSignal);\n// Example: Write(\"Transition Timer\", TransitionTimer);\n// Example: Write(\"Emergency Clear Timer\", EmergencyClearTimer);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Traffic Light Control System Using 61131-3 Structured Text.md",
        "path": "Reference Solutions/PLC Programing Tasks/Traffic Light Control System Using 61131-3 Structured Text.md"
    },
    {
        "filename": "Cascade Control Heat Exchanger.md",
        "content": "```\nPROGRAM HeatExchangerCascadeControl\nVAR\n    // Inputs\n    ProcessTemperature : REAL; // Temperature sensor reading in Celsius\n    HeatingDemand : REAL; // Demand for heating from the process\n    FlowRateSensor : REAL; // Flow rate sensor reading in liters/minute\n    \n    // Outputs\n    TemperatureSetpoint : REAL := 50.0; // Outer loop setpoint in Celsius\n    FlowRateControl : REAL := 50.0; // Inner loop output for flow control\n    \n    // Parameters\n    KpTemp : REAL := 1.0; // Proportional gain for temperature control\n    KiTemp : REAL := 0.1; // Integral gain for temperature control\n    KdTemp : REAL := 0.01; // Derivative gain for temperature control\n    KpFlow : REAL := 0.5; // Proportional gain for flow rate control\n    KiFlow : REAL := 0.05; // Integral gain for flow rate control\n    KdFlow : REAL := 0.005; // Derivative gain for flow rate control\n    \n    // Intermediate Variables\n    ErrorTemp : REAL; // Temperature error\n    IntegralTemp : REAL := 0.0; // Integral term for temperature control\n    DerivativeTemp : REAL := 0.0; // Derivative term for temperature control\n    ErrorFlow : REAL; // Flow rate error\n    IntegralFlow : REAL := 0.0; // Integral term for flow rate control\n    DerivativeFlow : REAL := 0.0; // Derivative term for flow rate control\n    LastProcessTemperature : REAL := ProcessTemperature; // Previous process temperature for derivative calculation\n    LastFlowRateSensor : REAL := FlowRateSensor; // Previous flow rate for derivative calculation\n    SampleTime : TIME := T#1s; // Sample time for PID calculations\n    \n    // Timers\n    PIDSampleTimer : TIME := T#0s; // Timer for sample interval\nEND_VAR\n\n// Main Control Logic\nIF TCU(SampleTime) THEN\n    // Update last known values for derivative calculation\n    LastProcessTemperature := ProcessTemperature;\n    LastFlowRateSensor := FlowRateSensor;\n    \n    // Calculate temperature error\n    ErrorTemp := TemperatureSetpoint - ProcessTemperature;\n    \n    // Calculate integral term for temperature control\n    IntegralTemp := IntegralTemp + ErrorTemp * T#1s;\n    \n    // Calculate derivative term for temperature control\n    DerivativeTemp := (ProcessTemperature - LastProcessTemperature) / T#1s;\n    \n    // Calculate flow rate setpoint based on temperature error\n    FlowRateSetpoint := KpTemp * ErrorTemp + KiTemp * IntegralTemp + KdTemp * DerivativeTemp;\n    \n    // Calculate flow rate error\n    ErrorFlow := FlowRateSetpoint - FlowRateSensor;\n    \n    // Calculate integral term for flow rate control\n    IntegralFlow := IntegralFlow + ErrorFlow * T#1s;\n    \n    // Calculate derivative term for flow rate control\n    DerivativeFlow := (FlowRateSensor - LastFlowRateSensor) / T#1s;\n    \n    // Calculate flow rate control output\n    FlowRateControl := KpFlow * ErrorFlow + KiFlow * IntegralFlow + KdFlow * DerivativeFlow;\n    \n    // Anti-windup for integral terms\n    IF ErrorTemp > 0 THEN\n        IntegralTemp := MAX(IntegralTemp, 0);\n    ELSE\n        IntegralTemp := MIN(IntegralTemp, 0);\n    END_IF;\n    \n    IF ErrorFlow > 0 THEN\n        IntegralFlow := MAX(IntegralFlow, 0);\n    ELSE\n        IntegralFlow := MIN(IntegralFlow, 0);\n    END_IF;\n    \n    // Limit the output of the flow rate control to a reasonable range\n    FlowRateControl := MAX(FlowRateControl, 0);\n    FlowRateControl := MIN(FlowRateControl, 100);\n    \n    // Reset timers\n    PIDSampleTimer := T#0s;\nELSE\n    PIDSampleTimer := PIDSampleTimer + T#1s;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Temperature Setpoint\", TemperatureSetpoint);\n// Example: Write(\"Process Temperature\", ProcessTemperature);\n// Example: Write(\"Flow Rate Control Output\", FlowRateControl);\n// Example: Write(\"Flow Rate Sensor Reading\", FlowRateSensor);\n// Example: Write(\"Error Temp\", ErrorTemp);\n// Example: Write(\"Integral Temp\", IntegralTemp);\n// Example: Write(\"Derivative Temp\", DerivativeTemp);\n// Example: Write(\"Flow Rate Setpoint\", FlowRateSetpoint);\n// Example: Write(\"Error Flow\", ErrorFlow);\n// Example: Write(\"Integral Flow\", IntegralFlow);\n// Example: Write(\"Derivative Flow\", DerivativeFlow);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Cascade Control Heat Exchanger.md",
        "path": "Reference Solutions/Process Control/Cascade Control Heat Exchanger.md"
    },
    {
        "filename": "Cascade Control Oil Refinery.md",
        "content": "```\nPROGRAM OilRefineryCascadeControl\nVAR\n    // Inputs\n    ProcessPressure : REAL; // Pressure sensor reading in bar\n    OilFlowSensor : REAL; // Oil flow sensor reading in liters/minute\n    PressureSetpoint : REAL := 10.0; // Primary loop setpoint in bar (adjust based on process requirements)\n    \n    // Outputs\n    OilFlowControl : REAL := 50.0; // Secondary loop output for flow control\n    \n    // Parameters for Primary Loop (Pressure Control)\n    KpPressure : REAL := 0.5; // Proportional gain for pressure control\n    KiPressure : REAL := 0.01; // Integral gain for pressure control\n    KdPressure : REAL := 0.05; // Derivative gain for pressure control\n    \n    // Parameters for Secondary Loop (Oil Flow Control)\n    KpFlow : REAL := 0.8; // Proportional gain for flow control\n    KiFlow : REAL := 0.05; // Integral gain for flow control\n    KdFlow : REAL := 0.02; // Derivative gain for flow control\n    \n    // Intermediate Variables\n    ErrorPressure : REAL; // Pressure error\n    IntegralPressure : REAL := 0.0; // Integral term for pressure control\n    DerivativePressure : REAL := 0.0; // Derivative term for pressure control\n    ErrorFlow : REAL; // Flow rate error\n    IntegralFlow : REAL := 0.0; // Integral term for flow rate control\n    DerivativeFlow : REAL := 0.0; // Derivative term for flow rate control\n    LastProcessPressure : REAL := ProcessPressure; // Previous process pressure for derivative calculation\n    LastOilFlowSensor : REAL := OilFlowSensor; // Previous oil flow for derivative calculation\n    SampleTime : TIME := T#1s; // Sample time for PID calculations\n    \n    // Timers\n    PIDSampleTimer : TIME := T#0s; // Timer for sample interval\nEND_VAR\n\n// Main Control Logic\nIF TCU(SampleTime) THEN\n    // Update last known values for derivative calculation\n    LastProcessPressure := ProcessPressure;\n    LastOilFlowSensor := OilFlowSensor;\n    \n    // Calculate pressure error\n    ErrorPressure := PressureSetpoint - ProcessPressure;\n    \n    // Calculate integral term for pressure control\n    IntegralPressure := IntegralPressure + ErrorPressure * T#1s;\n    \n    // Calculate derivative term for pressure control\n    DerivativePressure := (ProcessPressure - LastProcessPressure) / T#1s;\n    \n    // Calculate flow rate setpoint based on pressure error\n    FlowRateSetpoint := KpPressure * ErrorPressure + KiPressure * IntegralPressure + KdPressure * DerivativePressure;\n    \n    // Calculate flow rate error\n    ErrorFlow := FlowRateSetpoint - OilFlowSensor;\n    \n    // Calculate integral term for flow rate control\n    IntegralFlow := IntegralFlow + ErrorFlow * T#1s;\n    \n    // Calculate derivative term for flow rate control\n    DerivativeFlow := (OilFlowSensor - LastOilFlowSensor) / T#1s;\n    \n    // Calculate flow rate control output\n    OilFlowControl := KpFlow * ErrorFlow + KiFlow * IntegralFlow + KdFlow * DerivativeFlow;\n    \n    // Anti-windup for integral terms\n    IF ErrorPressure > 0 THEN\n        IntegralPressure := MAX(IntegralPressure, 0);\n    ELSE\n        IntegralPressure := MIN(IntegralPressure, 0);\n    END_IF;\n    \n    IF ErrorFlow > 0 THEN\n        IntegralFlow := MAX(IntegralFlow, 0);\n    ELSE\n        IntegralFlow := MIN(IntegralFlow, 0);\n    END_IF;\n    \n    // Limit the output of the flow rate control to a reasonable range\n    OilFlowControl := MAX(OilFlowControl, 0);\n    OilFlowControl := MIN(OilFlowControl, 100); // Adjust the maximum value based on the system capacity\n    \n    // Reset timers\n    PIDSampleTimer := T#0s;\nELSE\n    PIDSampleTimer := PIDSampleTimer + T#1s;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Pressure Setpoint\", PressureSetpoint);\n// Example: Write(\"Process Pressure\", ProcessPressure);\n// Example: Write(\"Oil Flow Control Output\", OilFlowControl);\n// Example: Write(\"Oil Flow Sensor Reading\", OilFlowSensor);\n// Example: Write(\"Error Pressure\", ErrorPressure);\n// Example: Write(\"Integral Pressure\", IntegralPressure);\n// Example: Write(\"Derivative Pressure\", DerivativePressure);\n// Example: Write(\"Flow Rate Setpoint\", FlowRateSetpoint);\n// Example: Write(\"Error Flow\", ErrorFlow);\n// Example: Write(\"Integral Flow\", IntegralFlow);\n// Example: Write(\"Derivative Flow\", DerivativeFlow);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Cascade Control Oil Refinery.md",
        "path": "Reference Solutions/Process Control/Cascade Control Oil Refinery.md"
    },
    {
        "filename": "Feedforward Control Conveyor.md",
        "content": "```\nPROGRAM ConveyorBeltFeedforwardControl\nVAR\n    // Inputs\n    PredictedLoad : REAL; // Sensor input predicting the weight/volume of incoming material\n    CurrentSpeed : REAL; // Current speed of the conveyor belt in meters/minute\n    \n    // Outputs\n    NewSpeed : REAL; // New speed setting for the conveyor belt\n    \n    // Parameters\n    BaseSpeed : REAL := 50.0; // Base speed of the conveyor belt in meters/minute\n    LoadFactor : REAL := 0.01; // Factor to adjust speed based on load prediction\n    MinSpeed : REAL := 10.0; // Minimum allowed speed in meters/minute\n    MaxSpeed : REAL := 100.0; // Maximum allowed speed in meters/minute\n    \n    // Intermediate Variables\n    RequiredSpeed : REAL; // Calculated required speed based on predicted load\nEND_VAR\n\n// Main Control Logic\n// Calculate the required speed adjustment based on the predicted load\nRequiredSpeed := BaseSpeed + LoadFactor * PredictedLoad;\n\n// Clamp the required speed to the minimum and maximum allowed speeds\nNewSpeed := MAX(MinSpeed, MIN(MaxSpeed, RequiredSpeed));\n\n// Ensure smooth transition by limiting the speed change rate\nIF ABS(NewSpeed - CurrentSpeed) > 5 THEN\n    IF NewSpeed > CurrentSpeed THEN\n        NewSpeed := CurrentSpeed + 5;\n    ELSE\n        NewSpeed := CurrentSpeed - 5;\n    END_IF;\nEND_IF;\n\n// Output the new speed setting\n// In a real application, this would be sent to the conveyor motor controller\n// Example: SetMotorSpeed(NewSpeed);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Feedforward Control Conveyor.md",
        "path": "Reference Solutions/Process Control/Feedforward Control Conveyor.md"
    },
    {
        "filename": "Feedforward Control Mixing.md",
        "content": "```\nPROGRAM ReactantMixingFeedforwardControl\nVAR\n    // Inputs\n    FlowRateA : REAL; // Flow rate of Reactant A in liters/minute\n    FlowRateB : REAL; // Flow rate of Reactant B in liters/minute\n    ConcentrationA : REAL; // Concentration of Reactant A in percent\n    ConcentrationB : REAL; // Concentration of Reactant B in percent\n    Temperature : REAL; // Temperature of the mixing vessel in Celsius\n    DisturbanceSignal : REAL; // Signal indicating a disturbance or input change\n    \n    // Outputs\n    AdjustedFlowRateA : REAL; // Adjusted flow rate of Reactant A in liters/minute\n    AdjustedFlowRateB : REAL; // Adjusted flow rate of Reactant B in liters/minute\n    \n    // Parameters\n    BaseFlowRateA : REAL := 50.0; // Base flow rate of Reactant A in liters/minute\n    BaseFlowRateB : REAL := 50.0; // Base flow rate of Reactant B in liters/minute\n    GainA : REAL := 0.01; // Gain factor for flow rate adjustment of Reactant A\n    GainB : REAL := 0.01; // Gain factor for flow rate adjustment of Reactant B\n    TemperatureAdjustmentFactor : REAL := 0.005; // Adjustment factor for temperature changes\n    DisturbanceFactor : REAL := 0.05; // Adjustment factor for disturbance signals\n    \n    // Intermediate Variables\n    TemperatureEffectOnFlowRateA : REAL; // Effect of temperature on flow rate of Reactant A\n    TemperatureEffectOnFlowRateB : REAL; // Effect of temperature on flow rate of Reactant B\n    DisturbanceEffectOnFlowRateA : REAL; // Effect of disturbance on flow rate of Reactant A\n    DisturbanceEffectOnFlowRateB : REAL; // Effect of disturbance on flow rate of Reactant B\n    RequiredFlowRateA : REAL; // Required flow rate of Reactant A after adjustments\n    RequiredFlowRateB : REAL; // Required flow rate of Reactant B after adjustments\nEND_VAR\n\n// Main Control Logic\n// Calculate the effect of temperature on flow rates\nTemperatureEffectOnFlowRateA := TemperatureAdjustmentFactor * Temperature;\nTemperatureEffectOnFlowRateB := TemperatureAdjustmentFactor * Temperature;\n\n// Calculate the effect of disturbance on flow rates\nDisturbanceEffectOnFlowRateA := DisturbanceFactor * DisturbanceSignal;\nDisturbanceEffectOnFlowRateB := DisturbanceFactor * DisturbanceSignal;\n\n// Calculate the required flow rates including all adjustments\nRequiredFlowRateA := BaseFlowRateA + TemperatureEffectOnFlowRateA + DisturbanceEffectOnFlowRateA;\nRequiredFlowRateB := BaseFlowRateB + TemperatureEffectOnFlowRateB + DisturbanceEffectOnFlowRateB;\n\n// Apply gain factors to the required flow rates\nAdjustedFlowRateA := BaseFlowRateA + GainA * RequiredFlowRateA;\nAdjustedFlowRateB := BaseFlowRateB + GainB * RequiredFlowRateB;\n\n// Ensure the adjusted flow rates stay within operational bounds\nAdjustedFlowRateA := MAX(10.0, MIN(100.0, AdjustedFlowRateA));\nAdjustedFlowRateB := MAX(10.0, MIN(100.0, AdjustedFlowRateB));\n\n// Output the adjusted flow rates\n// In a real application, these would be sent to the flow control valves\n// Example: SetValveA(AdjustedFlowRateA);\n// Example: SetValveB(AdjustedFlowRateB);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Feedforward Control Mixing.md",
        "path": "Reference Solutions/Process Control/Feedforward Control Mixing.md"
    },
    {
        "filename": "PID Flow Control Water Treatment.md",
        "content": "```\nPROGRAM ChlorineDosingPIDControl\nVAR\n    // Inputs\n    FlowMeasurement : REAL; // Flow measurement in liters per minute (L/min)\n    DesiredConcentration : REAL := 3.0; // Desired chlorine concentration in ppm\n    \n    // Outputs\n    DosingRate : REAL; // Chemical dosing rate in milliliters per minute (mL/min)\n    \n    // PID Parameters\n    Kp : REAL := 0.5; // Proportional gain\n    Ki : REAL := 0.1; // Integral gain\n    Kd : REAL := 0.05; // Derivative gain\n    SetPoint : REAL := 3.0; // Set point for chlorine concentration in ppm\n    \n    // PID Intermediate Variables\n    Error : REAL; // Error between setpoint and actual concentration\n    IntegralTerm : REAL := 0.0; // Integral term for PID algorithm\n    DerivativeTerm : REAL := 0.0; // Derivative term for PID algorithm\n    LastError : REAL := 0.0; // Last error value for derivative calculation\n    LastSampleTime : TIME := T#0ms; // Last sample time for delta calculation\n    \n    // Safety Limits\n    MinDosingRate : REAL := 0.0; // Minimum allowed dosing rate in mL/min\n    MaxDosingRate : REAL := 100.0; // Maximum allowed dosing rate in mL/min\n    SampleTime : TIME := T#100ms; // Sampling time for PID algorithm\n    \n    // Timing Variable\n    CurrentSampleTime : TIME := T#0ms; // Current sample time for delta calculation\nEND_VAR\n\n// Main Control Logic\nIF TCU(SampleTime) THEN\n    // Update the current sample time\n    CurrentSampleTime := T#0ms;\n    \n    // Calculate the current error\n    Error := DesiredConcentration - (FlowMeasurement * DosingRate / 1000);\n    \n    // Update the integral term\n    IntegralTerm := IntegralTerm + Error * SampleTime;\n    \n    // Calculate the derivative term\n    DerivativeTerm := (Error - LastError) / SampleTime;\n    \n    // Calculate the dosing rate adjustment using the PID formula\n    DosingRate := DosingRate + (Kp * Error + Ki * IntegralTerm + Kd * DerivativeTerm);\n    \n    // Anti-windup protection for the integral term\n    IF Error > 0 THEN\n        IntegralTerm := MAX(IntegralTerm, 0);\n    ELSE\n        IntegralTerm := MIN(IntegralTerm, 0);\n    END_IF;\n    \n    // Limit the dosing rate to ensure it stays within the safety limits\n    DosingRate := MAX(MinDosingRate, MIN(MaxDosingRate, DosingRate));\n    \n    // Update the last error for the next derivative calculation\n    LastError := Error;\n    \n    // Reset the sample time counter\n    LastSampleTime := CurrentSampleTime;\nELSE\n    // Increment the sample time counter\n    CurrentSampleTime := CurrentSampleTime + T#100ms;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Flow Measurement\", FlowMeasurement);\n// Example: Write(\"Desired Concentration\", DesiredConcentration);\n// Example: Write(\"Dosing Rate\", DosingRate);\n// Example: Write(\"Error\", Error);\n// Example: Write(\"Integral Term\", IntegralTerm);\n// Example: Write(\"Derivative Term\", DerivativeTerm);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from PID Flow Control Water Treatment.md",
        "path": "Reference Solutions/Process Control/PID Flow Control Water Treatment.md"
    },
    {
        "filename": "PID Level Control Distillation Column.md",
        "content": "```\nPROGRAM DistillationColumnLevelControl\nVAR\n    // Inputs\n    CurrentLevel : REAL; // Current liquid level in the column (percentage or arbitrary units)\n    SetPoint : REAL := 50.0; // Desired liquid level setpoint (percentage or arbitrary units)\n    \n    // Outputs\n    ValvePosition : REAL; // Position of the inlet valve (percentage open)\n    \n    // PID Parameters\n    Kp : REAL := 1.0; // Proportional gain\n    Ki : REAL := 0.1; // Integral gain\n    Kd : REAL := 0.05; // Derivative gain\n    \n    // PID Intermediate Variables\n    Error : REAL; // Error between setpoint and actual level\n    IntegralTerm : REAL := 0.0; // Integral term for PID algorithm\n    DerivativeTerm : REAL := 0.0; // Derivative term for PID algorithm\n    LastError : REAL := 0.0; // Last error value for derivative calculation\n    LastSampleTime : TIME := T#0ms; // Last sample time for delta calculation\n    SampleTime : TIME := T#1s; // Sampling time for PID algorithm (adjust as needed)\n    \n    // Safety Limits\n    MinValvePosition : REAL := 0.0; // Minimum allowed valve position (percentage open)\n    MaxValvePosition : REAL := 100.0; // Maximum allowed valve position (percentage open)\n    \n    // Timing Variable\n    CurrentSampleTime : TIME := T#0ms; // Current sample time for delta calculation\nEND_VAR\n\n// Main Control Logic\nIF TCU(SampleTime) THEN\n    // Update the current sample time\n    CurrentSampleTime := T#0ms;\n    \n    // Calculate the current error\n    Error := SetPoint - CurrentLevel;\n    \n    // Update the integral term\n    IntegralTerm := IntegralTerm + Error * SampleTime;\n    \n    // Calculate the derivative term\n    DerivativeTerm := (Error - LastError) / SampleTime;\n    \n    // Calculate the valve position adjustment using the PID formula\n    ValvePosition := ValvePosition + (Kp * Error + Ki * IntegralTerm + Kd * DerivativeTerm);\n    \n    // Anti-windup protection for the integral term\n    IF ValvePosition > MaxValvePosition THEN\n        IntegralTerm := IntegralTerm - Error * SampleTime;\n    ELSIF ValvePosition < MinValvePosition THEN\n        IntegralTerm := IntegralTerm + Error * SampleTime;\n    END_IF;\n    \n    // Limit the valve position to ensure it stays within the safety limits\n    ValvePosition := MAX(MinValvePosition, MIN(MaxValvePosition, ValvePosition));\n    \n    // Update the last error for the next derivative calculation\n    LastError := Error;\n    \n    // Reset the sample time counter\n    LastSampleTime := CurrentSampleTime;\nELSE\n    // Increment the sample time counter\n    CurrentSampleTime := CurrentSampleTime + T#1s;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Current Level\", CurrentLevel);\n// Example: Write(\"Set Point\", SetPoint);\n// Example: Write(\"Valve Position\", ValvePosition);\n// Example: Write(\"Error\", Error);\n// Example: Write(\"Integral Term\", IntegralTerm);\n// Example: Write(\"Derivative Term\", DerivativeTerm);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from PID Level Control Distillation Column.md",
        "path": "Reference Solutions/Process Control/PID Level Control Distillation Column.md"
    },
    {
        "filename": "PID Pressure Control Chemical Reactor.md",
        "content": "```\nPROGRAM ChemicalReactorPressureControl\nVAR\n    // Inputs\n    CurrentPressure : REAL; // Current pressure in the reactor (PSI or bar)\n    SetPoint : REAL := 100.0; // Desired pressure setpoint (PSI or bar)\n    \n    // Outputs\n    ValvePosition : REAL; // Position of the pressure control valve (percentage open)\n    \n    // PID Parameters\n    Kp : REAL := 1.0; // Proportional gain\n    Ki : REAL := 0.1; // Integral gain\n    Kd : REAL := 0.05; // Derivative gain\n    \n    // PID Intermediate Variables\n    Error : REAL; // Error between setpoint and actual pressure\n    IntegralTerm : REAL := 0.0; // Integral term for PID algorithm\n    DerivativeTerm : REAL := 0.0; // Derivative term for PID algorithm\n    LastError : REAL := 0.0; // Last error value for derivative calculation\n    LastSampleTime : TIME := T#0ms; // Last sample time for delta calculation\n    SampleTime : TIME := T#1s; // Sampling time for PID algorithm (adjust as needed)\n    \n    // Safety Limits\n    MinValvePosition : REAL := 0.0; // Minimum allowed valve position (percentage open)\n    MaxValvePosition : REAL := 100.0; // Maximum allowed valve position (percentage open)\n    \n    // Timing Variable\n    CurrentSampleTime : TIME := T#0ms; // Current sample time for delta calculation\nEND_VAR\n\n// Main Control Logic\nIF TCU(SampleTime) THEN\n    // Update the current sample time\n    CurrentSampleTime := T#0ms;\n    \n    // Calculate the current error\n    Error := SetPoint - CurrentPressure;\n    \n    // Update the integral term\n    IntegralTerm := IntegralTerm + Error * SampleTime;\n    \n    // Calculate the derivative term\n    DerivativeTerm := (Error - LastError) / SampleTime;\n    \n    // Calculate the valve position adjustment using the PID formula\n    ValvePosition := ValvePosition + (Kp * Error + Ki * IntegralTerm + Kd * DerivativeTerm);\n    \n    // Anti-windup protection for the integral term\n    IF ValvePosition > MaxValvePosition THEN\n        IntegralTerm := IntegralTerm - Error * SampleTime;\n    ELSIF ValvePosition < MinValvePosition THEN\n        IntegralTerm := IntegralTerm + Error * SampleTime;\n    END_IF;\n    \n    // Limit the valve position to ensure it stays within the safety limits\n    ValvePosition := MAX(MinValvePosition, MIN(MaxValvePosition, ValvePosition));\n    \n    // Update the last error for the next derivative calculation\n    LastError := Error;\n    \n    // Reset the sample time counter\n    LastSampleTime := CurrentSampleTime;\nELSE\n    // Increment the sample time counter\n    CurrentSampleTime := CurrentSampleTime + T#1s;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Current Pressure\", CurrentPressure);\n// Example: Write(\"Set Point\", SetPoint);\n// Example: Write(\"Valve Position\", ValvePosition);\n// Example: Write(\"Error\", Error);\n// Example: Write(\"Integral Term\", IntegralTerm);\n// Example: Write(\"Derivative Term\", DerivativeTerm);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from PID Pressure Control Chemical Reactor.md",
        "path": "Reference Solutions/Process Control/PID Pressure Control Chemical Reactor.md"
    },
    {
        "filename": "PID Temperature Control Gas Turbine.md",
        "content": "```\nPROGRAM GasTurbineTemperatureControl\nVAR\n    // Inputs\n    CurrentTemp : REAL; // Current temperature inside the turbine (\u00b0C or \u00b0F)\n    SetPoint : REAL := 800.0; // Desired temperature setpoint (\u00b0C or \u00b0F)\n    \n    // Outputs\n    ValvePosition : REAL; // Position of the inlet valve (percentage open)\n    \n    // PID Parameters\n    Kp : REAL := 1.0; // Proportional gain\n    Ki : REAL := 0.1; // Integral gain\n    Kd : REAL := 0.05; // Derivative gain\n    \n    // PID Intermediate Variables\n    Error : REAL; // Error between setpoint and actual temperature\n    IntegralTerm : REAL := 0.0; // Integral term for PID algorithm\n    DerivativeTerm : REAL := 0.0; // Derivative term for PID algorithm\n    LastError : REAL := 0.0; // Last error value for derivative calculation\n    LastSampleTime : TIME := T#0ms; // Last sample time for delta calculation\n    SampleTime : TIME := T#1s; // Sampling time for PID algorithm (adjust as needed)\n    \n    // Safety Limits\n    MinValvePosition : REAL := 0.0; // Minimum allowed valve position (percentage open)\n    MaxValvePosition : REAL := 100.0; // Maximum allowed valve position (percentage open)\n    \n    // Timing Variable\n    CurrentSampleTime : TIME := T#0ms; // Current sample time for delta calculation\nEND_VAR\n\n// Main Control Logic\nIF TCU(SampleTime) THEN\n    // Update the current sample time\n    CurrentSampleTime := T#0ms;\n    \n    // Calculate the current error\n    Error := SetPoint - CurrentTemp;\n    \n    // Update the integral term\n    IntegralTerm := IntegralTerm + Error * SampleTime;\n    \n    // Calculate the derivative term\n    DerivativeTerm := (Error - LastError) / SampleTime;\n    \n    // Calculate the valve position adjustment using the PID formula\n    ValvePosition := ValvePosition + (Kp * Error + Ki * IntegralTerm + Kd * DerivativeTerm);\n    \n    // Anti-windup protection for the integral term\n    IF ValvePosition > MaxValvePosition THEN\n        IntegralTerm := IntegralTerm - Error * SampleTime;\n    ELSIF ValvePosition < MinValvePosition THEN\n        IntegralTerm := IntegralTerm + Error * SampleTime;\n    END_IF;\n    \n    // Limit the valve position to ensure it stays within the safety limits\n    ValvePosition := MAX(MinValvePosition, MIN(MaxValvePosition, ValvePosition));\n    \n    // Update the last error for the next derivative calculation\n    LastError := Error;\n    \n    // Reset the sample time counter\n    LastSampleTime := CurrentSampleTime;\nELSE\n    // Increment the sample time counter\n    CurrentSampleTime := CurrentSampleTime + T#1s;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Current Temperature\", CurrentTemp);\n// Example: Write(\"Set Point\", SetPoint);\n// Example: Write(\"Valve Position\", ValvePosition);\n// Example: Write(\"Error\", Error);\n// Example: Write(\"Integral Term\", IntegralTerm);\n// Example: Write(\"Derivative Term\", DerivativeTerm);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from PID Temperature Control Gas Turbine.md",
        "path": "Reference Solutions/Process Control/PID Temperature Control Gas Turbine.md"
    },
    {
        "filename": "PID pH Control.md",
        "content": "```\nPROGRAM pHControlProcess\nVAR\n    // Inputs\n    CurrentPH : REAL; // Current pH value (0-14)\n    SetPoint : REAL := 7.0; // Desired pH setpoint (0-14)\n    \n    // Outputs\n    DosingRate : REAL; // Rate of acid/base addition (percentage open)\n    \n    // PID Parameters\n    Kp : REAL := 1.0; // Proportional gain\n    Ki : REAL := 0.1; // Integral gain\n    Kd : REAL := 0.05; // Derivative gain\n    \n    // PID Intermediate Variables\n    Error : REAL; // Error between setpoint and actual pH\n    IntegralTerm : REAL := 0.0; // Integral term for PID algorithm\n    DerivativeTerm : REAL := 0.0; // Derivative term for PID algorithm\n    LastError : REAL := 0.0; // Last error value for derivative calculation\n    LastSampleTime : TIME := T#0ms; // Last sample time for delta calculation\n    SampleTime : TIME := T#1s; // Sampling time for PID algorithm (adjust as needed)\n    \n    // Safety Limits\n    MinDosingRate : REAL := 0.0; // Minimum allowed dosing rate (percentage open)\n    MaxDosingRate : REAL := 100.0; // Maximum allowed dosing rate (percentage open)\n    \n    // Timing Variable\n    CurrentSampleTime : TIME := T#0ms; // Current sample time for delta calculation\nEND_VAR\n\n// Main Control Logic\nIF TCU(SampleTime) THEN\n    // Update the current sample time\n    CurrentSampleTime := T#0ms;\n    \n    // Calculate the current error\n    Error := SetPoint - CurrentPH;\n    \n    // Update the integral term\n    IntegralTerm := IntegralTerm + Error * SampleTime;\n    \n    // Calculate the derivative term\n    DerivativeTerm := (Error - LastError) / SampleTime;\n    \n    // Calculate the dosing rate adjustment using the PID formula\n    DosingRate := DosingRate + (Kp * Error + Ki * IntegralTerm + Kd * DerivativeTerm);\n    \n    // Anti-windup protection for the integral term\n    IF DosingRate > MaxDosingRate THEN\n        IntegralTerm := IntegralTerm - Error * SampleTime;\n    ELSIF DosingRate < MinDosingRate THEN\n        IntegralTerm := IntegralTerm + Error * SampleTime;\n    END_IF;\n    \n    // Limit the dosing rate to ensure it stays within the safety limits\n    DosingRate := MAX(MinDosingRate, MIN(MaxDosingRate, DosingRate));\n    \n    // Update the last error for the next derivative calculation\n    LastError := Error;\n    \n    // Reset the sample time counter\n    LastSampleTime := CurrentSampleTime;\nELSE\n    // Increment the sample time counter\n    CurrentSampleTime := CurrentSampleTime + T#1s;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Current pH\", CurrentPH);\n// Example: Write(\"Set Point\", SetPoint);\n// Example: Write(\"Dosing Rate\", DosingRate);\n// Example: Write(\"Error\", Error);\n// Example: Write(\"Integral Term\", IntegralTerm);\n// Example: Write(\"Derivative Term\", DerivativeTerm);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from PID pH Control.md",
        "path": "Reference Solutions/Process Control/PID pH Control.md"
    },
    {
        "filename": "Ratio Control Mixing.md",
        "content": "```\nPROGRAM RatioControlMixing\nVAR\n    // Inputs\n    FlowRateA : REAL; // Flow rate of Reactant A (L/min)\n    FlowRateB : REAL; // Flow rate of Reactant B (L/min)\n    \n    // Outputs\n    AdjustedFlowRateA : REAL; // Adjusted flow rate of Reactant A (L/min)\n    AdjustedFlowRateB : REAL; // Adjusted flow rate of Reactant B (L/min)\n    \n    // Constants\n    Ratio : REAL := 2.0; // Desired ratio (Reactant A : Reactant B)\n    \n    // Control Variables\n    CorrectionFactor : REAL := 1.0; // Factor used to adjust the flow rate of Reactant B\n    FlowRateDifference : REAL; // Difference between the actual and desired flow rates\n    \n    // Tolerances\n    Tolerance : REAL := 0.05; // Acceptable deviation from the desired ratio\nEND_VAR\n\n// Main Control Logic\nIF ABS(FlowRateA / FlowRateB - Ratio) > Tolerance THEN\n    // Calculate the difference between the actual and desired flow rates\n    FlowRateDifference := FlowRateA / Ratio - FlowRateB;\n    \n    // Adjust the flow rate of Reactant B to maintain the ratio\n    CorrectionFactor := FlowRateA / Ratio / FlowRateB;\n    \n    // Ensure the correction factor is within reasonable bounds\n    IF CorrectionFactor > 1.0 + Tolerance THEN\n        CorrectionFactor := 1.0 + Tolerance;\n    ELSIF CorrectionFactor < 1.0 - Tolerance THEN\n        CorrectionFactor := 1.0 - Tolerance;\n    END_IF;\n    \n    // Adjust the flow rate of Reactant B\n    AdjustedFlowRateB := FlowRateB * CorrectionFactor;\n    \n    // Keep the flow rate of Reactant A unchanged\n    AdjustedFlowRateA := FlowRateA;\nELSE\n    // If the flow rates are already close to the desired ratio, no adjustment is needed\n    AdjustedFlowRateA := FlowRateA;\n    AdjustedFlowRateB := FlowRateB;\nEND_IF;\n\n// Debugging outputs (for simulation purposes)\n// Example: Write(\"Adjusted Flow Rate A\", AdjustedFlowRateA);\n// Example: Write(\"Adjusted Flow Rate B\", AdjustedFlowRateB);\n// Example: Write(\"Correction Factor\", CorrectionFactor);\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Ratio Control Mixing.md",
        "path": "Reference Solutions/Process Control/Ratio Control Mixing.md"
    },
    {
        "filename": "Explain Cascade Control Code.md",
        "content": "```\nThe provided structured text (ST) program implements a cascade control system, which is commonly used in industrial automation to improve the responsiveness and stability of a control system. In this case, the program controls the pressure of a vessel (primary loop) by adjusting the flow rate through a valve (secondary loop). Here\u2019s a detailed explanation of the code:\n\nOverview\n\nPrimary Loop: Controls the pressure inside a vessel.\nSecondary Loop: Controls the flow rate through a valve, which affects the pressure inside the vessel.\nVariables\n\nPrimary Loop Variables\n\nPV1: Represents the measured pressure (process variable).\nSP1: Represents the target pressure (setpoint).\nOP1: Represents the output from the primary loop, which serves as the setpoint for the secondary loop.\nKp1, Ki1, Kd1: Proportional, integral, and derivative gains for the primary PID controller.\ne1, e1_prev, e1_sum, e1_diff: Error, previous error, integral sum of the error, and differential of the error for the primary loop.\nSecondary Loop Variables\n\nPV2: Represents the measured flow rate.\nSP2: Represents the target flow rate, which is the output from the primary loop (OP1).\nOP2: Represents the final output, which controls the valve position.\nKp2, Ki2, Kd2: Proportional, integral, and derivative gains for the secondary PID controller.\ne2, e2_prev, e2_sum, e2_diff: Error, previous error, integral sum of the error, and differential of the error for the secondary loop.\nTiming\n\ndt: Sample time for the PID calculations.\nt_last: Used for timing purposes (not directly used in the provided method).\nMethod RunCascadeControl\n\nReading Process Variables\n\nPV1 := ReadPressure(): Reads the current pressure.\nPV2 := ReadFlowRate(): Reads the current flow rate.\nPrimary Loop (Pressure Control)\n\nCalculate Error:\ne1 := SP1 - PV1: Calculates the error between the setpoint and the current pressure.\nIntegral Term:\ne1_sum := e1_sum + e1 * dt: Accumulates the error over time.\nDerivative Term:\ne1_diff := (e1 - e1_prev) / dt: Calculates the rate of change of the error.\nPID Calculation:\nOP1 := Kp1 * e1 + Ki1 * e1_sum + Kd1 * e1_diff: Applies the PID formula to determine the output for the secondary loop setpoint.\nUpdate Previous Error:\ne1_prev := e1: Stores the current error for the next derivative calculation.\nLimit Output:\nIF OP1 > 100.0 THEN OP1 := 100.0; ELSIF OP1 < 0.0 THEN OP1 := 0.0; END_IF: Ensures the output is within the valid range [0, 100].\nSecondary Loop (Flow Control)\n\nSet Secondary Setpoint:\nSP2 := OP1: Sets the target flow rate to the output of the primary loop.\nCalculate Error:\ne2 := SP2 - PV2: Calculates the error between the secondary setpoint and the current flow rate.\nIntegral Term:\ne2_sum := e2_sum + e2 * dt: Accumulates the error over time.\nDerivative Term:\ne2_diff := (e2 - e2_prev) / dt: Calculates the rate of change of the error.\nPID Calculation:\nOP2 := Kp2 * e2 + Ki2 * e2_sum + Kd2 * e2_diff: Applies the PID formula to determine the valve position.\nUpdate Previous Error:\ne2_prev := e2: Stores the current error for the next derivative calculation.\nLimit Output:\nIF OP2 > 100.0 THEN OP2 := 100.0; ELSIF OP2 < 0.0 THEN OP2 := 0.0; END_IF: Ensures the output is within the valid range [0, 100].\nFinal Step\n\nSetValvePosition(OP2): Sets the valve position based on the calculated output from the secondary loop.\nDiscussion\n\nCascade control systems are advantageous because they can provide better control over the primary variable (pressure in this case) by more effectively managing the secondary variable (flow rate). By having two loops, where the secondary loop responds faster to disturbances, the overall system can achieve tighter control and faster response times.\n\nIn summary, the provided code implements a cascade control strategy where the outer loop (pressure control) sets the setpoint for the inner loop (flow control), and the inner loop reacts more quickly to disturbances, thereby improving the overall control of the process.\n```\n",
        "description": "Markdown file from Explain Cascade Control Code.md",
        "path": "Reference Solutions/Programmer Support/Explain Cascade Control Code.md"
    },
    {
        "filename": "Explanation PID Function Block.md",
        "content": "```\nThe PID (Proportional-Integral-Derivative) function block is a fundamental component in process control systems, designed to automatically adjust a control output in response to an error between a setpoint (SP) and a process variable (PV). In the context of industrial automation, the PID function block is often implemented using libraries like OSCAT (Open Source Control Application Toolkit), which provides standardized blocks for control engineering applications.\n\nInputs and Outputs of the PID Function Block\n\nInputs\n\nSetpoint (SP): The desired value of the process variable. This is the target that the control system aims to reach or maintain.\nProcess Variable (PV): The actual value of the process variable being controlled. It is typically measured by a sensor and fed back into the controller.\nManual Mode (MAN): An input that allows switching the controller between automatic (AUT) and manual (MAN) modes. In manual mode, the output is set by an external signal rather than the PID algorithm.\nProportional Gain (KP): Determines how strongly the output responds to the current error.\nIntegral Gain (KI): Determines the contribution of the accumulated past error to the output.\nDerivative Gain (KD): Determines the contribution of the predicted future error based on the current rate of change of the error.\nOutput Limit (OLIM): Defines the upper and lower bounds of the output signal to prevent excessive actuator movement or damage to equipment.\nFilter Time Constant (FTC): A parameter that can be used to filter out noise in the derivative term.\nBias (BIAS): An offset that is added to the PID output. It can be useful for starting the controller from a known good position or to compensate for static offsets in the system.\nReset Windup Protection (RWP): Mechanism to prevent the integral term from accumulating excessively when the controller output is saturated (i.e., at its limit).\nOutputs\n\nControl Output (CO): The output signal sent to the actuator (such as a valve or motor) to adjust the process variable.\nStatus (STS): Indicates the status of the controller, whether it is in auto or manual mode, or if it is experiencing any faults.\nError (ERR): The difference between the setpoint and the process variable.\nRole of Each Parameter\n\nProportional Gain (KP): Higher KP results in a larger change in the output for a given change in the error. It provides a quick response but can lead to oscillation if set too high.\nIntegral Gain (KI): Helps eliminate steady-state error by integrating the error over time. It ensures that the process variable reaches the setpoint even if the error is very small.\nDerivative Gain (KD): Helps to predict future trends of the error and can dampen oscillations. It is less commonly used because it amplifies noise unless properly filtered.\nOutput Limit (OLIM): Prevents the actuator from moving beyond safe operating ranges, protecting the equipment from damage.\nBias (BIAS): Can be used to adjust the initial condition of the controller or to counteract a constant disturbance.\nReset Windup Protection (RWP): Prevents the integral action from \"winding up\" when the actuator is at its limit, which would otherwise result in a large integral term that needs to be \"unwound.\"\nPractical Implementation Examples\n\nExample 1: Temperature Control in a Boiler\n\nIn a boiler system, a PID controller might be used to control the temperature of the water. The setpoint could be a desired temperature, while the process variable is the actual temperature measured by a thermocouple. The output could be the position of a steam valve controlling the amount of heat applied to the boiler. The proportional term would respond immediately to changes in temperature, the integral term would work to eliminate any persistent error, and the derivative term would help to prevent overshoot.\n\nExample 2: Level Control in a Tank\n\nFor controlling the liquid level in a tank, the setpoint would be the desired level, and the process variable would be the actual level as measured by a level sensor. The output could be the speed of a pump adding or removing fluid from the tank. The PID controller would adjust the pump speed to maintain the level at the setpoint, with the proportional term responding to the current level error, the integral term working to eliminate any steady-state error, and the derivative term helping to smooth out rapid changes in level.\n\nThese examples illustrate how the PID function block is used in industrial settings to achieve precise control over various process variables, ensuring efficient and stable operation of the systems involved.\n```\n",
        "description": "Markdown file from Explanation PID Function Block.md",
        "path": "Reference Solutions/Programmer Support/Explanation PID Function Block.md"
    },
    {
        "filename": "Fix Traffic Light Code.md",
        "content": "```\nPROGRAM TrafficLightControl\nVAR\n    pedestrianButtonPressed: BOOL;\n    emergencyVehicleApproaching: BOOL;\n    greenLightOn: BOOL;\n    yellowLightOn: BOOL;\n    redLightOn: BOOL;\n    timer: TON; // timer to control the duration of green and yellow lights\n    pedestrianCrossingTimer: TON; // timer for pedestrian crossing duration\nEND_VAR\n\n// Initialize the program\ngreenLightOn := TRUE;\nyellowLightOn := FALSE;\nredLightOn := FALSE;\ntimer(IN := NOT emergencyVehicleApproaching, PT := T#5s);\npedestrianCrossingTimer(IN := FALSE, PT := T#10s); // Assume 10 seconds for pedestrian crossing\n\n// Main program loop\nWHILE TRUE DO\n    // Check for pedestrian button press\n    pedestrianButtonPressed := ReadPedestrianButton();\n    \n    // Check for emergency vehicle approaching\n    emergencyVehicleApproaching := ReadEmergencyVehicleSensor();\n    \n    // Handle emergency vehicles\n    IF emergencyVehicleApproaching THEN\n        // Turn off all lights and turn on green light for emergency vehicle\n        greenLightOn := TRUE;\n        yellowLightOn := FALSE;\n        redLightOn := FALSE;\n        timer(IN := FALSE);\n        pedestrianCrossingTimer(IN := FALSE);\n        \n    ELSEIF pedestrianButtonPressed THEN\n        // Turn off all lights and turn on red light and pedestrian light\n        greenLightOn := FALSE;\n        yellowLightOn := FALSE;\n        redLightOn := TRUE;\n        \n        // Start pedestrian crossing timer\n        pedestrianCrossingTimer(IN := TRUE);\n        \n        // Turn off pedestrian button press once timer starts\n        pedestrianButtonPressed := FALSE;\n        \n        // Reset main timer\n        timer(IN := FALSE);\n        \n    ELSEIF pedestrianCrossingTimer.Q THEN\n        // Pedestrian crossing time is over, go to yellow light phase\n        yellowLightOn := TRUE;\n        redLightOn := FALSE;\n        pedestrianCrossingTimer(IN := FALSE);\n        \n        // Start the timer for yellow light\n        timer(IN := TRUE);\n        \n    ELSEIF timer.Q THEN\n        IF greenLightOn THEN\n            greenLightOn := FALSE;\n            yellowLightOn := TRUE;\n            timer(IN := TRUE); // Restart timer for yellow light duration\n            \n        ELSEIF yellowLightOn THEN\n            yellowLightOn := FALSE;\n            redLightOn := TRUE;\n            timer(IN := FALSE); // Stop timer once red light is on\n            \n        ELSE // Red light is on\n            redLightOn := FALSE;\n            greenLightOn := TRUE;\n            timer(IN := NOT emergencyVehicleApproaching);\n        END_IF;\n    END_IF;\n    \n    // Set the traffic lights based on the variables\n    SetTrafficLights(greenLightOn, yellowLightOn, redLightOn);\n    \n    // Wait for a short time before checking again\n    DELAY 100ms;\nEND_WHILE\n\n// Read the pedestrian button state from an input\nFUNCTION ReadPedestrianButton: BOOL\n    // Code to read the input goes here\nEND_FUNCTION\n\n// Read the emergency vehicle sensor state from an input\nFUNCTION ReadEmergencyVehicleSensor: BOOL\n    // Code to read the input goes here\nEND_FUNCTION\n\n// Set the traffic lights based on the variables\nPROCEDURE SetTrafficLights(\n    green: BOOL;\n    yellow: BOOL;\n    red: BOOL \n)\n    // Code to set the traffic lights goes here\nEND_PROCEDURE\n```\n",
        "description": "Markdown file from Fix Traffic Light Code.md",
        "path": "Reference Solutions/Programmer Support/Fix Traffic Light Code.md"
    },
    {
        "filename": "Generate Documentation Urea Reaction.md",
        "content": "```\nOverview\n\nThis Structured Text (ST) program, UreaReactionControl, automates the urea synthesis process by controlling the opening and closing of ammonia and carbon dioxide (CO2) valves. The program ensures that the reactor reaches and maintains the required conditions (pressure and temperature) for the urea synthesis reaction to take place. After the reaction period, the valves are closed, and the process is marked as completed.\n\nProgram Structure\n\nThe program is organized into sections for inputs, outputs, internal variables, parameters, and the main sequence control logic.\n\nInputs\n\nstAmmoniaValve (BOOL): Indicates whether the ammonia valve is open (TRUE) or closed (FALSE).\nstCO2Valve (BOOL): Indicates whether the CO2 valve is open (TRUE) or closed (FALSE).\nrCurrentPressure (REAL): Current pressure in the reactor in bars.\nrCurrentTemperature (REAL): Current temperature in the reactor in degrees Celsius.\nOutputs\n\nstAmmoniaValveControl (BOOL): Signal to control the ammonia valve. TRUE indicates the valve should be opened, FALSE indicates it should be closed.\nstCO2ValveControl (BOOL): Signal to control the CO2 valve. TRUE indicates the valve should be opened, FALSE indicates it should be closed.\nInternal Variables\n\nstStep1 (BOOL): Flag indicating the completion of step 1 (loading raw materials).\nstStep2 (BOOL): Flag indicating the completion of step 2 (controlling the reaction).\nstReactionFinished (BOOL): Flag indicating the completion of the entire reaction process.\nParameters\n\nrTargetPressure (REAL): Target pressure for the reactor in bars.\nrPressureTolerance (REAL): Allowed deviation from the target pressure in bars.\nrTargetTemperature (REAL): Target temperature for the reactor in degrees Celsius.\nrTemperatureTolerance (REAL): Allowed deviation from the target temperature in degrees Celsius.\ntReactionTime (TIME): Total time allowed for the reaction in minutes.\ntReactionTimer (TIME): Timer to track the progress of the reaction.\nMain Sequence Control\n\nThe main sequence control is structured as a series of steps that ensure the reaction conditions are met and maintained until the reaction is complete.\n\nStep 1: Load Raw Materials\nOpen both the ammonia and CO2 valves (stAmmoniaValveControl := TRUE and stCO2ValveControl := TRUE).\nCheck the status of the valves (IF stAmmoniaValve AND stCO2Valve THEN). If both valves are open, set the flag stStep1 := TRUE and record the current time (tReactionTimer := CURRENT_TIME) to start the reaction timing.\nStep 2: Control Reaction\nCheck if the current pressure and temperature are within the target range (IF (rCurrentPressure >= rTargetPressure - rPressureTolerance) AND (rCurrentPressure <= rTargetPressure + rPressureTolerance) AND (rCurrentTemperature >= rTargetTemperature - rTemperatureTolerance) AND (rCurrentTemperature <= rTargetTemperature + rTemperatureTolerance)).\nIf the conditions are met, check if the reaction time has been reached (IF CURRENT_TIME >= tReactionTimer + tReactionTime). If so, set the flag stStep2 := TRUE to proceed to the next step.\nIf the conditions are not met, adjust the valves based on the pressure and temperature (stAmmoniaValveControl := (rCurrentPressure < rTargetPressure) OR (rCurrentTemperature < rTargetTemperature) and stCO2ValveControl := (rCurrentPressure < rTargetPressure) OR (rCurrentTemperature < rTargetTemperature)).\nCompletion of Reaction\nClose all valves (stAmmoniaValveControl := FALSE and stCO2ValveControl := FALSE) and mark the reaction as finished (stReactionFinished := TRUE).\nNotes\n\nThe program assumes continuous monitoring of the reactor's pressure and temperature. Any updates to these values should trigger a reevaluation of the current step and potentially lead to changes in the valve control signals.\nThe program uses the CURRENT_TIME function to manage the timing of the reaction steps. This function should return the current system time or a time stamp that is updated regularly.\nThe logic for adjusting the valves is based on the principle that additional reactants are needed if the pressure or temperature falls below the target values. More sophisticated control strategies may be required for precise regulation, especially in industrial settings where safety and efficiency are critical.\nThis documentation provides an overview of the UreaReactionControl program, detailing the inputs, outputs, internal variables, parameters, and the main sequence control logic. Developers should refer to this document for understanding and maintaining the program.\n```\n",
        "description": "Markdown file from Generate Documentation Urea Reaction.md",
        "path": "Reference Solutions/Programmer Support/Generate Documentation Urea Reaction.md"
    },
    {
        "filename": "Learning IEC 61499.md",
        "content": "```\nIntroduction to IEC 61499\n\nIEC 61499 is an international standard published by the International Electrotechnical Commission (IEC) for the design and implementation of distributed embedded control systems. It is designed to address the challenges of creating software for networked control devices, particularly those found in industrial automation environments. For individuals familiar with IEC 61131-3, understanding IEC 61499 involves recognizing several key concepts that differ significantly from traditional PLC programming paradigms.\n\nKey Concepts\n\nFunction Blocks: Similar to IEC 61131-3, IEC 61499 uses function blocks as the basic building blocks of control logic. However, in IEC 61499, function blocks are more powerful and flexible, allowing for the encapsulation of complex functionality and the management of communication and resource allocation.\nDistributed Execution: Unlike IEC 61131-3, which typically operates on a single device or centralized controller, IEC 61499 supports a distributed execution model. Function blocks can be dynamically allocated to different devices in a network, allowing for optimized use of resources and redundancy.\nEvent-Driven Model: While IEC 61131-3 primarily operates on a cycle-by-cycle basis, IEC 61499 supports event-driven execution. This means that function blocks can be triggered by events such as changes in input values or messages received from other devices, leading to more responsive and efficient systems.\nCommunication: IEC 61499 defines a standard way of communicating between function blocks across different devices. This includes mechanisms for data exchange, synchronization, and coordination of distributed processes.\nResource Management: IEC 61499 introduces the concept of resources, which are entities that can be shared among function blocks. Resources can represent physical devices or logical entities that require coordinated access, such as databases or actuators.\nPortability and Scalability: Due to its modular and distributed nature, IEC 61499 enables the creation of portable and scalable control systems. Function blocks can be reused across different projects and platforms, facilitating a higher degree of interoperability.\nComparison with IEC 61131-3\n\nArchitecture: IEC 61499 promotes a distributed architecture, whereas IEC 61131-3 typically follows a centralized approach. This means that IEC 61499 can better leverage the capabilities of modern networks and computing infrastructures.\nExecution Model: While IEC 61131-3 executes programs in a fixed scan cycle, IEC 61499 supports asynchronous and event-driven execution, which can lead to more efficient use of processing power and faster response times.\nFlexibility for Distributed Systems: IEC 61499's support for dynamic allocation of function blocks and resources makes it highly suitable for complex distributed control systems, offering greater flexibility in system configuration and maintenance.\nReferences for Further Reading\n\nTo deepen your understanding of IEC 61499 and its relevance in modern industrial applications, consider the following references:\n\nIEC 61499 Standard: Obtain the latest version of the IEC 61499 standard from the IEC website or national standards bodies. This document will provide the most authoritative details on the standard's specifications and requirements.\n\"IEC 61499: A Practitioner\u2019s Guide\" by J\u00f6rg B\u00f6cker: This book offers practical insights into implementing IEC 61499 in industrial automation projects. It covers the theoretical foundations as well as real-world examples and best practices.\n\"Distributed Control System Design Using IEC 61499\" by John W. Webb: This book focuses on the design aspects of distributed control systems using IEC 61499. It explores the principles behind the standard and how they apply to system design.\nResearch Papers: Look for academic papers discussing the application of IEC 61499 in specific industries or use cases. Journals such as the IEEE Transactions on Industrial Informatics or Automation in Construction often publish relevant studies.\nOnline Courses and Webinars: Platforms like Coursera, Udemy, or industry-specific training providers offer courses that introduce IEC 61499 and provide hands-on experience with tools and frameworks supporting the standard.\nBy exploring these resources, you will gain a deeper understanding of IEC 61499 and its potential to revolutionize the way industrial control systems are designed and deployed.\n```\n",
        "description": "Markdown file from Learning IEC 61499.md",
        "path": "Reference Solutions/Programmer Support/Learning IEC 61499.md"
    },
    {
        "filename": "List Mathematical Function Blocks.md",
        "content": "```\nThe OSCAT library, or Open Source Control Application Toolkit, provides a collection of reusable function blocks designed to simplify the development of control applications for programmable logic controllers (PLCs). Among these blocks are various mathematical function blocks that perform arithmetic operations, conversions, and other numerical computations essential for control systems.\n\nHere is a detailed list of common mathematical function blocks that you might find in the OSCAT library or similar libraries used for PLC programming, along with brief descriptions of their functionality and typical use cases:\n\nArithmetic Function Blocks\n\nAdd (ADD)\nDescription: Adds two numbers together.\nUse Case: Commonly used in summing inputs in feedback control systems.\nSubtract (SUB)\nDescription: Subtracts one number from another.\nUse Case: Useful for calculating differences, such as in error detection systems.\nMultiply (MUL)\nDescription: Multiplies two numbers.\nUse Case: Often used in scaling operations or calculating areas/volumes.\nDivide (DIV)\nDescription: Divides one number by another.\nUse Case: Used in rate calculations, such as flow rates or speed adjustments.\nPower (POW)\nDescription: Raises one number to the power of another.\nUse Case: Useful in exponential growth/decay models, such as in chemical reactions or population dynamics.\nSquare Root (SQRT)\nDescription: Computes the square root of a number.\nUse Case: Common in physics equations, such as calculating velocity from acceleration.\nTrigonometric Function Blocks\n\nSine (SIN)\nDescription: Calculates the sine of an angle.\nUse Case: Used in wave generation, harmonic analysis, or robotic arm positioning.\nCosine (COS)\nDescription: Calculates the cosine of an angle.\nUse Case: Similar to Sine but used in different phases of waveforms or vector calculations.\nTangent (TAN)\nDescription: Calculates the tangent of an angle.\nUse Case: Useful in determining slopes or gradients in control systems.\nArcsine (ASIN)\nDescription: Calculates the inverse sine of a number.\nUse Case: Used in navigation systems or for inverse trigonometric functions.\nArccosine (ACOS)\nDescription: Calculates the inverse cosine of a number.\nUse Case: Similar to ASIN but for calculating angles in certain geometrical problems.\nArctangent (ATAN)\nDescription: Calculates the inverse tangent of a number.\nUse Case: Used in coordinate transformations or for calculating angles from slopes.\nConversion Function Blocks\n\nDegrees to Radians (DEG_TO_RAD)\nDescription: Converts degrees to radians.\nUse Case: Necessary for using trigonometric functions that expect radians as input.\nRadians to Degrees (RAD_TO_DEG)\nDescription: Converts radians to degrees.\nUse Case: Useful for displaying angular measurements in a more human-readable format.\nLogical and Bit Manipulation Function Blocks\n\nAbsolute Value (ABS)\nDescription: Returns the absolute value of a number.\nUse Case: Used to remove the sign of a value, such as in distance calculations.\nMaximum (MAX)\nDescription: Returns the maximum of two or more numbers.\nUse Case: Used in setting limits or selecting the highest value among options.\nMinimum (MIN)\nDescription: Returns the minimum of two or more numbers.\nUse Case: Used in setting limits or selecting the lowest value among options.\nBit Shift Left (BSHIFT_LEFT)\nDescription: Shifts bits to the left by a specified number of positions.\nUse Case: Used in bit manipulation for scaling or encoding data.\nBit Shift Right (BSHIFT_RIGHT)\nDescription: Shifts bits to the right by a specified number of positions.\nUse Case: Used in bit manipulation for scaling down or decoding data.\nBitwise AND (BIT_AND)\nDescription: Performs a bitwise AND operation on two numbers.\nUse Case: Used in masking operations to isolate specific bits.\nBitwise OR (BIT_OR)\nDescription: Performs a bitwise OR operation on two numbers.\nUse Case: Used in combining multiple flags or setting bits.\nMiscellaneous Function Blocks\n\nLogarithm (LOG)\nDescription: Calculates the logarithm of a number (base 10 or natural log).\nUse Case: Used in exponential decay models or for scaling purposes.\nExponential (EXP)\nDescription: Calculates e raised to the power of a number.\nUse Case: Used in growth models or for converting linear scales to exponential ones.\nModulo (MOD)\nDescription: Computes the remainder of a division.\nUse Case: Useful for cycling through a range of values or implementing periodic behavior.\nThis list covers a broad spectrum of mathematical functions that are typically available in a library like OSCAT. Depending on the specific library and implementation, there may be additional specialized blocks tailored to particular industries or applications. Always consult the official documentation of the library for the most accurate information.\n```\n",
        "description": "Markdown file from List Mathematical Function Blocks.md",
        "path": "Reference Solutions/Programmer Support/List Mathematical Function Blocks.md"
    },
    {
        "filename": "Object-oriented 61131-3.md",
        "content": "```\nPROGRAM ConveyorBelt\nVAR\n    speed : INT; // Variable to store the speed of the conveyor belt\nEND_VAR\n\nMETHOD SetSpeed(newSpeed : INT) : BOOL;\n    speed := newSpeed;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD GetSpeed() : INT;\n    RETURN speed;\nEND_METHOD\n\nPROGRAM ReversibleConveyorBelt INHERITS ConveyorBelt\nMETHOD ReverseDirection() : BOOL;\n    speed := -speed; // Reverse the speed\n    RETURN TRUE;\nEND_METHOD\n\nFUNCTION_BLOCK ControlConveyor\nVAR_INPUT\n    conveyor : ANY;\nEND_VAR\nVAR\n    speed : INT;\nEND_VAR\n\nspeed := conveyor.GetSpeed(); // Uses polymorphism to call the correct GetSpeed method\nconveyor.SetSpeed(speed * 2); // Calls the correct SetSpeed method\n\n```\n",
        "description": "Markdown file from Object-oriented 61131-3.md",
        "path": "Reference Solutions/Programmer Support/Object-oriented 61131-3.md"
    },
    {
        "filename": "Optimize Batch Code.md",
        "content": "```\nPROGRAM PolyethyleneBatchControl\nVAR\n    // States for the batch process\n    state: INT := 0;\n    timer: TON;\n    stepStartTime: TIME := T#0s;\n\n    // Process parameters\n    rawMatPrepTemp: REAL := 70.0; // \u00b0C\n    rawMatPrepPressure: REAL := 1.0; // bar\n    polymerizationTemp: REAL := 150.0; // \u00b0C\n    polymerizationPressure: REAL := 30.0; // bar\n    quenchingTemp: REAL := 25.0; // \u00b0C\n    quenchingPressure: REAL := 5.0; // bar\n    dryingTemp: REAL := 80.0; // \u00b0C\n    pelletizingTemp: REAL := 150.0; // \u00b0C\n    qualityControlTemp: REAL := 25.0; // \u00b0C\n    packagingStorageTemp: REAL := 20.0; // \u00b0C\nEND_VAR\n\nMETHOD UpdateTemperaturesAndPressures: BOOL\n    // Update temperatures and pressures for each process step\n    CASE state OF\n        1: (* Raw material preparation *)\n            SetTemperatureAndPressure(rawMatPrepTemp, rawMatPrepPressure);\n        2: (* Polymerization *)\n            SetTemperatureAndPressure(polymerizationTemp, polymerizationPressure);\n        3: (* Quenching *)\n            SetTemperatureAndPressure(quenchingTemp, quenchingPressure);\n        4: (* Drying *)\n            SetTemperatureAndPressure(dryingTemp, quenchingPressure);\n        5: (* Pelletizing *)\n            SetTemperatureAndPressure(pelletizingTemp, quenchingPressure);\n        6: (* Quality control *)\n            SetTemperatureAndPressure(qualityControlTemp, quenchingPressure);\n        7: (* Packaging and storage *)\n            SetTemperatureAndPressure(packagingStorageTemp, quenchingPressure);\n    END_CASE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD SetTemperatureAndPressure: BOOL (temp: REAL; pressure: REAL)\n    // Set temperature and pressure for the current process step\n    // Dummy function for demonstration purposes\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE state OF\n    0: (* Start the batch process *)\n        state := 1;\n        stepStartTime := NOW();\n\n    1: (* Raw material preparation *)\n        timer(IN:=NOT timer.Q, PT:=T#5s);\n        IF timer.Q THEN\n            state := 2;\n            stepStartTime := NOW();\n            timer(IN:=FALSE);\n        END_IF;\n\n    2: (* Polymerization *)\n        timer(IN:=NOT timer.Q, PT:=T#30m);\n        IF timer.Q THEN\n            state := 3;\n            stepStartTime := NOW();\n            timer(IN:=FALSE);\n        END_IF;\n\n    3: (* Quenching *)\n        timer(IN:=NOT timer.Q, PT:=T#15m);\n        IF timer.Q THEN\n            state := 4;\n            stepStartTime := NOW();\n            timer(IN:=FALSE);\n        END_IF;\n\n    4: (* Drying *)\n        timer(IN:=NOT timer.Q, PT:=T#1h);\n        IF timer.Q THEN\n            state := 5;\n            stepStartTime := NOW();\n            timer(IN:=FALSE);\n        END_IF;\n\n    5: (* Pelletizing *)\n        timer(IN:=NOT timer.Q, PT:=T#1h30m);\n        IF timer.Q THEN\n            state := 6;\n            stepStartTime := NOW();\n            timer(IN:=FALSE);\n        END_IF;\n\n    6: (* Quality control *)\n        timer(IN:=NOT timer.Q, PT:=T#2h);\n        IF timer.Q THEN\n            state := 7;\n            stepStartTime := NOW();\n            timer(IN:=FALSE);\n        END_IF;\n\n    7: (* Packaging and storage *)\n        timer(IN:=NOT timer.Q, PT:=T#3h);\n        IF timer.Q THEN\n            // Batch process complete\n            state := 0;\n            timer(IN:=FALSE);\n        END_IF;\nEND_CASE;\n\nUpdateTemperaturesAndPressures();\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Optimize Batch Code.md",
        "path": "Reference Solutions/Programmer Support/Optimize Batch Code.md"
    },
    {
        "filename": "Programming Reference.md",
        "content": "```\nThe IEC 61131-3 Structured Text (ST) programming language is used for specifying the behavior of programmable logic controllers (PLCs) and other industrial automation devices. Below is a list of keywords and constructs commonly used in ST, along with brief descriptions and examples where applicable.\n\nKeywords and Constructs\n\nStatements and Expressions\n\nAND: Logical AND operator.\nIec61131\n\n\na AND b\nOR: Logical OR operator.\nIec61131\n\n\na OR b\nXOR: Logical XOR operator.\nIec61131\n\n\na XOR b\nNOT: Logical NOT operator.\nIec61131\n\n\nNOT a\nEQ: Equality operator.\nIec61131\n\n\na EQ b\nNE: Not equal operator.\nIec61131\n\n\na NE b\nLT: Less than operator.\nIec61131\n\n\na LT b\nLE: Less than or equal to operator.\nIec61131\n\n\na LE b\nGT: Greater than operator.\nIec61131\n\n\na GT b\nGE: Greater than or equal to operator.\nIec61131\n\n\na GE b\n+: Addition operator.\nIec61131\n\n\na + b\n-: Subtraction operator.\nIec61131\n\n\na - b\n*: Multiplication operator.\nIec61131\n\n\na * b\n/: Division operator.\nIec61131\n\n\na / b\nDIV: Integer division operator.\nIec61131\n\n\na DIV b\nMOD: Modulo operator.\nIec61131\n\n\na MOD b\n^: Exponentiation operator.\nIec61131\n\n\na ^ b\nControl Flow Structures\n\nIF ... THEN ... ELSE ... END_IF: Conditional statement.\nIec61131\n\n\nIF a > b THEN\n    c := a;\nELSE\n    c := b;\nEND_IF;\nCASE ... OF ... END_CASE: Selection statement.\nIec61131\n\n\nCASE a OF\n    1: b := 10;\n    2: b := 20;\n    ELSE b := 0;\nEND_CASE;\nWHILE ... DO ... END_WHILE: Loop statement.\nIec61131\n\n\nWHILE a < 10 DO\n    a := a + 1;\nEND_WHILE;\nFOR ... TO ... DO ... END_FOR: Loop statement.\nIec61131\n\n\nFOR i := 1 TO 10 DO\n    a := a + 1;\nEND_FOR;\nEXIT: Terminates the nearest enclosing loop or CASE statement.\nIec61131\n\n\nWHILE True DO\n    IF a > 10 THEN\n        EXIT;\n    END_IF;\nEND_WHILE;\nCONTINUE: Skips the rest of the loop body and proceeds to the next iteration.\nIec61131\n\n\nFOR i := 1 TO 10 DO\n    IF i MOD 2 = 0 THEN\n        CONTINUE;\n    END_IF;\n    a := a + 1;\nEND_FOR;\nData Types\n\nBOOL: Boolean data type.\nIec61131\n\n\na := TRUE;\nINT: Signed integer data type.\nIec61131\n\n\na := 10;\nUINT: Unsigned integer data type.\nIec61131\n\n\na := 10U;\nDINT: Double precision signed integer data type.\nIec61131\n\n\na := 10L;\nUDINT: Double precision unsigned integer data type.\nIec61131\n\n\na := 10LU;\nREAL: Floating point data type.\nIec61131\n\n\na := 10.0;\nLREAL: Long double precision floating point data type.\nIec61131\n\n\na := 10.0L;\nSTRING: Character string data type.\nIec61131\n\n\na := \"Hello\";\nWSTRING: Wide character string data type.\nIec61131\n\n\na := W\"Hello\";\nDATE: Date data type.\nIec61131\n\n\na := DATE#20240101;\nTIME: Time data type.\nIec61131\n\n\na := TIME#120000;\nDATE_AND_TIME: Date and time data type.\nIec61131\n\n\na := DATE_AND_TIME#20240101T120000;\nTIME_OF_DAY: Time of day data type.\nIec61131\n\n\na := TIME_OF_DAY#120000;\nARRAY: Array data type.\nIec61131\n\n\na[1] := 10;\nSTRUCT: User-defined structure data type.\nIec61131\n\n\nTYPE Point : STRUCT\n    x : INT;\n    y : INT;\nEND_STRUCT\nEND_TYPE\n\nVAR\n    p : Point;\nEND_VAR\n\np.x := 10;\np.y := 20;\nENUM: Enumeration data type.\nIec61131\n\n\nTYPE Color : ENUM\n    Red : INT := 1;\n    Green : INT := 2;\n    Blue : INT := 3;\nEND_ENUM\nEND_TYPE\n\nVAR\n    c : Color;\nEND_VAR\n\nc := Color#Red;\nFunctions and Procedures\n\nFUNCTION ... END_FUNCTION: Function declaration.\nIec61131\n\n\nFUNCTION Add(a : INT; b : INT) : INT\n    Add := a + b;\nEND_FUNCTION\nFUNCTION_BLOCK ... END_FUNCTION_BLOCK: Function block declaration.\nIec61131\n\n\nFUNCTION_BLOCK Increment\n    VAR_INPUT\n        value : INT;\n    END_VAR\n    VAR_OUTPUT\n        result : INT;\n    END_VAR\n    result := value + 1;\nEND_FUNCTION_BLOCK\nPROCEDURE ... END_PROCEDURE: Procedure declaration.\nIec61131\n\n\nPROCEDURE PrintHello\n    WRITE(\"Hello\");\nEND_PROCEDURE\nRETURN: Return statement.\nIec61131\n\n\nFUNCTION Add(a : INT; b : INT) : INT\n    RETURN a + b;\nEND_FUNCTION\nVAR: Local variable declaration.\nIec61131\n\n\nVAR\n    a : INT;\nEND_VAR\nVAR_INPUT: Input variable declaration.\nIec61131\n\n\nFUNCTION_BLOCK Increment\n    VAR_INPUT\n        value : INT;\n    END_VAR\nEND_FUNCTION_BLOCK\nVAR_OUTPUT: Output variable declaration.\nIec61131\n\n\nFUNCTION_BLOCK Increment\n    VAR_OUTPUT\n        result : INT;\n    END_VAR\nEND_FUNCTION_BLOCK\nVAR_INOUT: In/out variable declaration.\nIec61131\n\n\nFUNCTION_BLOCK Swap\n    VAR_INOUT\n        a, b : INT;\n    END_VAR\n    temp := a;\n    a := b;\n    b := temp;\nEND_FUNCTION_BLOCK\nThis list should cover the fundamental aspects of the IEC 61131-3 Structured Text programming language. Note that the actual implementation and syntax might vary slightly depending on the specific compiler or toolchain being used.\n```\n",
        "description": "Markdown file from Programming Reference.md",
        "path": "Reference Solutions/Programmer Support/Programming Reference.md"
    },
    {
        "filename": "Translate ST To Instruction List.md",
        "content": "```\n// BEGIN PROGRAM PickAndPlace\nLD ManualButton\nJMP ManualModeLabel IF TRUE\n\n// Auto mode control process\nLD AutoButton\nJMP AutoModeLabel IF TRUE\n\n// No buttons pressed, do nothing\nJMP EndOfProgram\n\nAutoModeLabel:\nLD Mode\nCMP Mode 1 =\nJMP ManualModeLabel IF TRUE\n\n// Auto mode processing\nLD NOT AutoProcess\nAND ConveyorA\nJMP AutoProcessStart IF TRUE\n\nJMP AutoProcessEnd\n\nAutoProcessStart:\nSET AutoProcess TRUE\nSET RoboticArm TRUE\nWAIT 2\nSET ConveyorB TRUE\nJMP AutoProcessEnd\n\nAutoProcessEnd:\nLD ConveyorB\nAND NOT ConveyorA\nJMP ReleaseProduct IF TRUE\n\nJMP ManualModeLabel\n\nReleaseProduct:\nSET ConveyorB FALSE\nSET AutoProcess FALSE\nJMP ManualModeLabel\n\nManualModeLabel:\nLD Mode\nCMP Mode 0 =\nJMP AutoModeLabel IF TRUE\n\n// Manual mode control process\nLD ClipButton\nAND ConveyorA\nJMP ClipProduct IF TRUE\n\nLD TransferButton\nJMP TransferProduct IF TRUE\n\nLD ReleaseButton\nJMP ReleaseProduct IF TRUE\n\nJMP AutoModeLabel\n\nClipProduct:\nSET RoboticArm TRUE\nJMP AutoModeLabel\n\nTransferProduct:\nSET ConveyorB TRUE\nJMP AutoModeLabel\n\nReleaseProduct:\nSET ConveyorB FALSE\nJMP AutoModeLabel\n\nEndOfProgram:\n// END PROGRAM PickAndPlace\n```\n",
        "description": "Markdown file from Translate ST To Instruction List.md",
        "path": "Reference Solutions/Programmer Support/Translate ST To Instruction List.md"
    },
    {
        "filename": "3D Pouch Making Machine.md",
        "content": "```\nPROGRAM InitializeMachine\nVAR\n    // Initial Parameters\n    initHeatingTemp : REAL := 120.0; // \u00b0C\n    initCoolingTemp : REAL := 25.0; // \u00b0C\n    initFeederSpeed : REAL := 0.0; // m/min\nEND_VAR\n\nMETHOD InitializeParameters : BOOL\n    FOR i := 1 TO 8 DO\n        SetHeatingStationTemp(i, initHeatingTemp);\n        SetCoolingStationTemp(i, initCoolingTemp);\n    END_FOR;\n    SetFeederUnitSpeed(1, initFeederSpeed);\n    SetFeederUnitSpeed(2, initFeederSpeed);\n    MoveHorizontalCutterToHomePosition();\n    MoveVerticalCutterToHomePosition();\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD StartFeeders : BOOL (targetSpeed : REAL)\n    FOR i := 1 TO 2 DO\n        rampUpSpeed := RampFunction(0, targetSpeed, 10); // Ramp up over 10 seconds\n        SetFeederUnitSpeed(i, rampUpSpeed);\n    END_FOR;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD HeatStations : BOOL (targetTemp : REAL)\n    FOR i := 1 TO 8 DO\n        SetHeatingStationTemp(i, targetTemp);\n        WHILE NOT IsHeatingStationAtTemp(i, targetTemp) DO\n            WAIT 1; // Wait for 1 second\n        END_WHILE;\n    END_FOR;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD CoolStations : BOOL (targetTemp : REAL)\n    FOR i := 1 TO 8 DO\n        SetCoolingStationTemp(i, targetTemp);\n        WHILE NOT IsCoolingStationAtTemp(i, targetTemp) DO\n            WAIT 1; // Wait for 1 second\n        END_WHILE;\n    END_FOR;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD ActivateCutters : BOOL\n    MoveHorizontalCutterToOperationalPosition();\n    MoveVerticalCutterToOperationalPosition();\n    ActivateHorizontalCutter();\n    ActivateVerticalCutter();\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD StartupRoutine : BOOL\n    InitializeParameters();\n    StartFeeders(50.0); // Target speed of 50 m/min\n    HeatStations(120.0); // Heating temperature of 120\u00b0C\n    CoolStations(25.0); // Cooling temperature of 25\u00b0C\n    ActivateCutters();\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD DeactivateCutters : BOOL\n    DeactivateHorizontalCutter();\n    DeactivateVerticalCutter();\n    MoveHorizontalCutterToHomePosition();\n    MoveVerticalCutterToHomePosition();\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD StopFeeders : BOOL\n    FOR i := 1 TO 2 DO\n        rampDownSpeed := RampFunction(50.0, 0.0, 10); // Ramp down over 10 seconds\n        SetFeederUnitSpeed(i, rampDownSpeed);\n    END_FOR;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD CoolDownHeatingStations : BOOL (coolingTemp : REAL)\n    FOR i := 1 TO 8 DO\n        SetHeatingStationTemp(i, coolingTemp);\n        WHILE NOT IsHeatingStationAtTemp(i, coolingTemp) DO\n            WAIT 1; // Wait for 1 second\n        END_WHILE;\n    END_FOR;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD CoolDownCoolingStations : BOOL (roomTemp : REAL)\n    FOR i := 1 TO 8 DO\n        SetCoolingStationTemp(i, roomTemp);\n        WHILE NOT IsCoolingStationAtTemp(i, roomTemp) DO\n            WAIT 1; // Wait for 1 second\n        END_WHILE;\n    END_FOR;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD ShutdownRoutine : BOOL\n    DeactivateCutters();\n    StopFeeders();\n    CoolDownHeatingStations(25.0); // Cooling temperature of 25\u00b0C\n    CoolDownCoolingStations(25.0); // Room temperature of 25\u00b0C\n    RETURN TRUE;\nEND_METHOD\n```\n",
        "description": "Markdown file from 3D Pouch Making Machine.md",
        "path": "Reference Solutions/Sequential Control/3D Pouch Making Machine.md"
    },
    {
        "filename": "Batch Adhesive.md",
        "content": "```\nPROGRAM AdhesiveReactionControl\nVAR\n    // States for the batch process\n    state: INT := 0;\n    \n    // Timers\n    timerHeat: TON;\n    timerMix: TON;\n    timerReact: TON;\n    \n    // Process parameters\n    heatTemp: REAL := 80.0; // \u00b0C\n    mixTime: TIME := T#10m; // Mixing time\n    reactTime: TIME := T#30m; // Reaction time\n    \n    // Flags\n    isHeatingComplete: BOOL := FALSE;\n    isMixingComplete: BOOL := FALSE;\n    isReactingComplete: BOOL := FALSE;\nEND_VAR\n\nMETHOD HeatToTemp: BOOL (targetTemp: REAL)\n    // Dummy method for heating\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD MixSolution: BOOL (mixDuration: TIME)\n    // Dummy method for mixing\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD MaintainReaction: BOOL (reactDuration: TIME)\n    // Dummy method for maintaining reaction conditions\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD CoolDown: BOOL\n    // Dummy method for cooling down\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE state OF\n    0: (* Start the reaction process *)\n        state := 1;\n        \n    1: (* Heat *)\n        timerHeat(IN:=NOT timerHeat.Q, PT:=T#10m);\n        IF timerHeat.Q THEN\n            isHeatingComplete := TRUE;\n            state := 2;\n        END_IF;\n        \n    2: (* Mix *)\n        timerMix(IN:=NOT timerMix.Q, PT:=mixTime);\n        IF timerMix.Q THEN\n            isMixingComplete := TRUE;\n            state := 3;\n        END_IF;\n        \n    3: (* React *)\n        timerReact(IN:=NOT timerReact.Q, PT:=reactTime);\n        IF timerReact.Q THEN\n            isReactingComplete := TRUE;\n            state := 4;\n        END_IF;\n        \n    4: (* Cool *)\n        IF CoolDown() THEN\n            state := 0; // Complete and return to start\n        END_IF;\nEND_CASE;\n\n(* Call methods based on state *)\nCASE state OF\n    1: (* Heat *)\n        IF NOT isHeatingComplete THEN\n            IF HeatToTemp(heatTemp) THEN\n                // Heating is ongoing\n            END_IF;\n        END_IF;\n        \n    2: (* Mix *)\n        IF NOT isMixingComplete THEN\n            IF MixSolution(mixTime) THEN\n                // Mixing is ongoing\n            END_IF;\n        END_IF;\n        \n    3: (* React *)\n        IF NOT isReactingComplete THEN\n            IF MaintainReaction(reactTime) THEN\n                // Reaction is ongoing\n            END_IF;\n        END_IF;\nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Batch Adhesive.md",
        "path": "Reference Solutions/Sequential Control/Batch Adhesive.md"
    },
    {
        "filename": "Batch Aspirin.md",
        "content": "```\nPROGRAM AspirinProduction\nVAR\n    // States for the batch process\n    state: INT := 0;\n    \n    // Timers\n    timerHeat: TON;\n    timerMix: TON;\n    timerReact: TON;\n    \n    // Process parameters\n    heatTemp: REAL := 70.0; // \u00b0C\n    mixTime: TIME := T#10m; // Mixing time\n    reactTime: TIME := T#30m; // Reaction time\n    coolTemp: REAL := 20.0; // \u00b0C\n    dryTemp: REAL := 90.0; // \u00b0C\n    dryTime: TIME := T#1h; // Drying time\n    \n    // Flags\n    isHeatingComplete: BOOL := FALSE;\n    isMixingComplete: BOOL := FALSE;\n    isReactingComplete: BOOL := FALSE;\n    isCoolingComplete: BOOL := FALSE;\n    isDryingComplete: BOOL := FALSE;\n    \n    // Temperature sensors\n    reactorTemp: REAL;\n    crystallizerTemp: REAL;\n    dryerTemp: REAL;\n    \n    // Actuators\n    reactorHeater: BOOL;\n    reactorCooler: BOOL;\n    dryerHeater: BOOL;\nEND_VAR\n\nMETHOD HeatReactor: BOOL (targetTemp: REAL)\n    reactorHeater := TRUE;\n    WHILE reactorTemp < targetTemp DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    reactorHeater := FALSE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD MixSolution: BOOL (mixDuration: TIME)\n    WHILE timerMix.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD ReactSolution: BOOL (reactDuration: TIME)\n    WHILE timerReact.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD CoolSolution: BOOL (targetTemp: REAL)\n    reactorCooler := TRUE;\n    WHILE crystallizerTemp > targetTemp DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    reactorCooler := FALSE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD DryCrystals: BOOL (targetTemp: REAL, duration: TIME)\n    dryerHeater := TRUE;\n    WHILE timerDry.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    dryerHeater := FALSE;\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE state OF\n    0: (* Start the reaction process *)\n        state := 1;\n        \n    1: (* Heat reactor *)\n        IF NOT isHeatingComplete THEN\n            IF HeatReactor(heatTemp) THEN\n                isHeatingComplete := TRUE;\n                state := 2;\n            END_IF;\n        END_IF;\n        \n    2: (* Mix solution *)\n        timerMix(IN:=TRUE, PT:=mixTime);\n        IF timerMix.Q THEN\n            isMixingComplete := TRUE;\n            state := 3;\n        END_IF;\n        \n    3: (* React solution *)\n        timerReact(IN:=TRUE, PT:=reactTime);\n        IF timerReact.Q THEN\n            isReactingComplete := TRUE;\n            state := 4;\n        END_IF;\n        \n    4: (* Cool solution *)\n        IF NOT isCoolingComplete THEN\n            IF CoolSolution(coolTemp) THEN\n                isCoolingComplete := TRUE;\n                state := 5;\n            END_IF;\n        END_IF;\n        \n    5: (* Dry crystals *)\n        timerDry(IN:=TRUE, PT:=dryTime);\n        IF NOT isDryingComplete THEN\n            IF DryCrystals(dryTemp, dryTime) THEN\n                isDryingComplete := TRUE;\n                state := 0; // Complete and return to start\n            END_IF;\n        END_IF;\nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Batch Aspirin.md",
        "path": "Reference Solutions/Sequential Control/Batch Aspirin.md"
    },
    {
        "filename": "Batch Cocoa Milk.md",
        "content": "```\nPROGRAM CocoaMilkProduction\nVAR\n    // States for the batch process\n    state: INT := 0;\n    \n    // Timers\n    timerHeat: TON;\n    timerBlend: TON;\n    \n    // Process parameters\n    heatTemp: REAL := 60.0; // \u00b0C\n    blendTime: TIME := T#5m; // Blending time\n    \n    // Flags\n    isHeatingComplete: BOOL := FALSE;\n    isBlendingComplete: BOOL := FALSE;\n    \n    // Temperature sensor\n    mixTemp: REAL;\n    \n    // Actuators\n    heater: BOOL;\n    stirrer: BOOL;\n    \n    // Flow meters\n    milkFlow: REAL;\n    waterFlow: REAL;\n    sugarFlow: REAL;\n    cocoaFlow: REAL;\n    \n    // Required quantities\n    milkQty: REAL := 80.0; // kg\n    waterQty: REAL := 15.0; // kg\n    sugarQty: REAL := 4.0; // kg\n    cocoaQty: REAL := 1.0; // kg\nEND_VAR\n\nMETHOD ChargeIngredients: BOOL (milkQty: REAL, waterQty: REAL)\n    milkFlow := milkQty;\n    waterFlow := waterQty;\n    WHILE milkFlow > 0 OR waterFlow > 0 DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD HeatMixture: BOOL (targetTemp: REAL)\n    heater := TRUE;\n    WHILE mixTemp < targetTemp DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    heater := FALSE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD AddSweetener: BOOL (sugarQty: REAL)\n    sugarFlow := sugarQty;\n    WHILE sugarFlow > 0 DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD AddCocoa: BOOL (cocoaQty: REAL)\n    cocoaFlow := cocoaQty;\n    WHILE cocoaFlow > 0 DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD BlendMixture: BOOL (blendDuration: TIME)\n    stirrer := TRUE;\n    WHILE timerBlend.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    stirrer := FALSE;\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE state OF\n    0: (* Start the process *)\n        state := 1;\n        \n    1: (* Charge ingredients *)\n        IF NOT ChargeIngredients(milkQty, waterQty) THEN\n            state := 2;\n        END_IF;\n        \n    2: (* Heat mixture *)\n        IF NOT isHeatingComplete THEN\n            IF HeatMixture(heatTemp) THEN\n                isHeatingComplete := TRUE;\n                state := 3;\n            END_IF;\n        END_IF;\n        \n    3: (* Add sweetener *)\n        IF NOT AddSweetener(sugarQty) THEN\n            state := 4;\n        END_IF;\n        \n    4: (* Add cocoa *)\n        IF NOT AddCocoa(cocoaQty) THEN\n            state := 5;\n        END_IF;\n        \n    5: (* Blend mixture *)\n        timerBlend(IN:=TRUE, PT:=blendTime);\n        IF NOT isBlendingComplete THEN\n            IF BlendMixture(blendTime) THEN\n                isBlendingComplete := TRUE;\n                state := 6;\n            END_IF;\n        END_IF;\n        \n    6: (* Cool and finish *)\n        state := 0; // Complete and return to start\nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Batch Cocoa Milk.md",
        "path": "Reference Solutions/Sequential Control/Batch Cocoa Milk.md"
    },
    {
        "filename": "Batch PVC.md",
        "content": "```\nPROGRAM PVCPolymerizationControl\nVAR\n    // States for the batch process\n    state: INT := 0;\n    \n    // Timers\n    timerEvacuate: TON;\n    timerAddWater: TON;\n    timerPolymerize: TON;\n    \n    // Process parameters\n    evacTime: TIME := T#5m; // Evacuation time\n    waterVolume: REAL := 1000.0; // Liters\n    waterAddTime: TIME := T#2m; // Time to add water\n    polymerizeTemp: REAL := 55.0; // \u00b0C\n    polymerizeTime: TIME := T#2h; // Polymerization time\n    \n    // Flags\n    isEvacuated: BOOL := FALSE;\n    isWaterAdded: BOOL := FALSE;\n    isPolymerizationComplete: BOOL := FALSE;\n    \n    // Temperature and pressure sensors\n    reactorTemp: REAL;\n    reactorPressure: REAL;\n    \n    // Actuators\n    vacuumPump: BOOL;\n    waterValve: BOOL;\n    vcmValve: BOOL;\n    catalystValve: BOOL;\n    agitatorMotor: BOOL;\n    \n    // Other process variables\n    isAgitationActive: BOOL;\nEND_VAR\n\nMETHOD EvacuateReactor: BOOL (evacTime: TIME)\n    vacuumPump := TRUE;\n    timerEvacuate(IN:=TRUE, PT:=evacTime);\n    WHILE timerEvacuate.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    vacuumPump := FALSE;\n    isEvacuated := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD AddDemineralizedWater: BOOL (waterVolume: REAL, waterAddTime: TIME)\n    waterValve := TRUE;\n    timerAddWater(IN:=TRUE, PT:=waterAddTime);\n    WHILE timerAddWater.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    waterValve := FALSE;\n    isWaterAdded := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD InitiatePolymerization: BOOL (polymerizeTemp: REAL, polymerizeTime: TIME)\n    vcmValve := TRUE;\n    catalystValve := TRUE;\n    agitatorMotor := TRUE;\n    WHILE reactorTemp < polymerizeTemp DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    timerPolymerize(IN:=TRUE, PT:=polymerizeTime);\n    WHILE timerPolymerize.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    vcmValve := FALSE;\n    catalystValve := FALSE;\n    agitatorMotor := FALSE;\n    isPolymerizationComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE state OF\n    0: (* Start the process *)\n        state := 1;\n        \n    1: (* Evacuate reactor *)\n        IF NOT isEvacuated THEN\n            IF EvacuateReactor(evacTime) THEN\n                state := 2;\n            END_IF;\n        END_IF;\n        \n    2: (* Add demineralized water *)\n        IF NOT isWaterAdded THEN\n            IF AddDemineralizedWater(waterVolume, waterAddTime) THEN\n                state := 3;\n            END_IF;\n        END_IF;\n        \n    3: (* Initiate polymerization *)\n        IF NOT isPolymerizationComplete THEN\n            IF InitiatePolymerization(polymerizeTemp, polymerizeTime) THEN\n                state := 4;\n            END_IF;\n        END_IF;\n        \n    4: (* Decover and dry *)\n        state := 0; // Complete and return to start\nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Batch PVC.md",
        "path": "Reference Solutions/Sequential Control/Batch PVC.md"
    },
    {
        "filename": "Batch Polyethylene.md",
        "content": "```\nPROGRAM PolyethyleneBatchControl\nVAR\n    // States for the batch process\n    state: INT := 0;\n    \n    // Timers\n    timerPrepare: TON;\n    timerPolymerize: TON;\n    timerQuench: TON;\n    timerDry: TON;\n    timerPelletize: TON;\n    \n    // Process parameters\n    prepTime: TIME := T#5m; // Raw material preparation time\n    polymerizeTime: TIME := T#1h; // Polymerization time\n    quenchTime: TIME := T#10m; // Quenching time\n    dryTime: TIME := T#20m; // Drying time\n    pelletizeTime: TIME := T#15m; // Pelletizing time\n    \n    // Flags\n    isPrepComplete: BOOL := FALSE;\n    isPolymerizeComplete: BOOL := FALSE;\n    isQuenchComplete: BOOL := FALSE;\n    isDryComplete: BOOL := FALSE;\n    isPelletizeComplete: BOOL := FALSE;\n    isQualityApproved: BOOL := FALSE;\n    \n    // Actuators\n    materialLoader: BOOL;\n    reactorHeater: BOOL;\n    quencherCooler: BOOL;\n    dryerHeater: BOOL;\n    pelletizerMotor: BOOL;\n    qualitySystem: BOOL;\n    packager: BOOL;\n    \n    // Sensors\n    reactorTemp: REAL;\n    quencherTemp: REAL;\n    dryerTemp: REAL;\nEND_VAR\n\nMETHOD PrepareMaterials: BOOL (prepTime: TIME)\n    materialLoader := TRUE;\n    timerPrepare(IN:=TRUE, PT:=prepTime);\n    WHILE timerPrepare.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    materialLoader := FALSE;\n    isPrepComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD InitiatePolymerization: BOOL (polymerizeTime: TIME)\n    reactorHeater := TRUE;\n    timerPolymerize(IN:=TRUE, PT:=polymerizeTime);\n    WHILE timerPolymerize.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    reactorHeater := FALSE;\n    isPolymerizeComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD QuenchPolymer: BOOL (quenchTime: TIME)\n    quencherCooler := TRUE;\n    timerQuench(IN:=TRUE, PT:=quenchTime);\n    WHILE timerQuench.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    quencherCooler := FALSE;\n    isQuenchComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD DryPolymer: BOOL (dryTime: TIME)\n    dryerHeater := TRUE;\n    timerDry(IN:=TRUE, PT:=dryTime);\n    WHILE timerDry.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    dryerHeater := FALSE;\n    isDryComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD PelletizePolymer: BOOL (pelletizeTime: TIME)\n    pelletizerMotor := TRUE;\n    timerPelletize(IN:=TRUE, PT:=pelletizeTime);\n    WHILE timerPelletize.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    pelletizerMotor := FALSE;\n    isPelletizeComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD QualityCheck: BOOL\n    qualitySystem := TRUE;\n    // Assume quality check takes some time and is successful\n    WAIT T#10s;\n    qualitySystem := FALSE;\n    isQualityApproved := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD PackageProduct: BOOL\n    packager := TRUE;\n    // Assume packaging takes some time and is successful\n    WAIT T#5s;\n    packager := FALSE;\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE state OF\n    0: (* Start the process *)\n        state := 1;\n        \n    1: (* Raw material preparation *)\n        IF NOT isPrepComplete THEN\n            IF PrepareMaterials(prepTime) THEN\n                state := 2;\n            END_IF;\n        END_IF;\n        \n    2: (* Polymerization *)\n        IF NOT isPolymerizeComplete THEN\n            IF InitiatePolymerization(polymerizeTime) THEN\n                state := 3;\n            END_IF;\n        END_IF;\n        \n    3: (* Quenching *)\n        IF NOT isQuenchComplete THEN\n            IF QuenchPolymer(quenchTime) THEN\n                state := 4;\n            END_IF;\n        END_IF;\n        \n    4: (* Drying *)\n        IF NOT isDryComplete THEN\n            IF DryPolymer(dryTime) THEN\n                state := 5;\n            END_IF;\n        END_IF;\n        \n    5: (* Pelletizing *)\n        IF NOT isPelletizeComplete THEN\n            IF PelletizePolymer(pelletizeTime) THEN\n                state := 6;\n            END_IF;\n        END_IF;\n        \n    6: (* Quality control *)\n        IF NOT isQualityApproved THEN\n            IF QualityCheck() THEN\n                state := 7;\n            END_IF;\n        END_IF;\n        \n    7: (* Packaging and storage *)\n        IF PackageProduct() THEN\n            state := 0; // Complete and return to start\n        END_IF;\nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Batch Polyethylene.md",
        "path": "Reference Solutions/Sequential Control/Batch Polyethylene.md"
    },
    {
        "filename": "Batch Urea Fertilizer.md",
        "content": "```\nPROGRAM UreaFertilizerBatchControl\nVAR\n    // State variables\n    currentState: INT := 0; // Initial state\n    \n    // Timers\n    timerHeating: TON;\n    timerCooling: TON;\n    timerPressureRegulation: TON;\n    \n    // Process parameters\n    heatingTime: TIME := T#10m; // Heating time\n    coolingTime: TIME := T#5m; // Cooling time\n    pressureRegulationTime: TIME := T#3m; // Pressure regulation time\n    reactionTemp: REAL := 180.0; // Reaction temperature (\u00b0C)\n    maxPressure: REAL := 140.0; // Maximum allowed pressure (bar)\n    \n    // Flags\n    isHeatingComplete: BOOL := FALSE;\n    isCoolingComplete: BOOL := FALSE;\n    isPressureRegulationComplete: BOOL := FALSE;\n    \n    // Sensors\n    reactorTemp: REAL; // Reactor temperature sensor\n    reactorPressure: REAL; // Reactor pressure sensor\n    \n    // Actuators\n    heater: BOOL;\n    cooler: BOOL;\n    pressureValve: BOOL;\n    \nEND_VAR\n\nMETHOD HeatReactor: BOOL (heatingTime: TIME, targetTemp: REAL)\n    heater := TRUE;\n    timerHeating(IN:=TRUE, PT:=heatingTime);\n    WHILE timerHeating.Q = FALSE OR reactorTemp < targetTemp DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    heater := FALSE;\n    isHeatingComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD CoolReactor: BOOL (coolingTime: TIME, targetTemp: REAL)\n    cooler := TRUE;\n    timerCooling(IN:=TRUE, PT:=coolingTime);\n    WHILE timerCooling.Q = FALSE OR reactorTemp > targetTemp DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    cooler := FALSE;\n    isCoolingComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD RegulatePressure: BOOL (pressureRegulationTime: TIME, maxPressure: REAL)\n    pressureValve := TRUE;\n    timerPressureRegulation(IN:=TRUE, PT:=pressureRegulationTime);\n    WHILE timerPressureRegulation.Q = FALSE OR reactorPressure > maxPressure DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    pressureValve := FALSE;\n    isPressureRegulationComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE currentState OF\n    0: (* Initial state - Load materials *)\n        currentState := 1; // Proceed to heating\n        \n    1: (* Heating phase *)\n        IF NOT isHeatingComplete THEN\n            IF HeatReactor(heatingTime, reactionTemp) THEN\n                currentState := 2; // Proceed to pressure regulation\n            END_IF;\n        END_IF;\n        \n    2: (* Pressure regulation phase *)\n        IF NOT isPressureRegulationComplete THEN\n            IF RegulatePressure(pressureRegulationTime, maxPressure) THEN\n                currentState := 3; // Proceed to cooling\n            END_IF;\n        END_IF;\n        \n    3: (* Cooling phase *)\n        IF NOT isCoolingComplete THEN\n            IF CoolReactor(coolingTime, 150.0) THEN // Target temp after reaction\n                currentState := 4; // Offloading\n            END_IF;\n        END_IF;\n        \n    4: (* Offloading *)\n        currentState := 0; // Return to initial state\nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Batch Urea Fertilizer.md",
        "path": "Reference Solutions/Sequential Control/Batch Urea Fertilizer.md"
    },
    {
        "filename": "Shutdown Steel Production.md",
        "content": "```\nPROGRAM SteelPlantShutdown\nVAR\n    // States\n    currentState: INT := 0;\n    \n    // Timers\n    timerCooling: TON;\n    timerGasFlowReduction: TON;\n    \n    // Process parameters\n    initialTemp: REAL := 1600.0; // \u00b0C\n    targetTemp: REAL := 800.0; // \u00b0C\n    rateOfDecreaseTemp: REAL := 200.0; // \u00b0C/hour\n    initialGasFlow: REAL := 500.0; // m\u00b3/hour\n    targetGasFlow: REAL := 0.0; // m\u00b3/hour\n    rateOfDecreaseGas: REAL := 42.0; // m\u00b3/hour/hour\n    fuelToAirRatio: REAL := 1.0 / 2.5; // Fuel-to-air ratio\n    \n    // Flags\n    isCoolingComplete: BOOL := FALSE;\n    isGasFlowReductionComplete: BOOL := FALSE;\n    isOxygenAdjusted: BOOL := FALSE;\n    \n    // Sensors\n    furnaceTemp: REAL;\n    gasFlowRate: REAL;\n    oxygenLevel: REAL;\n    \n    // Actuators\n    furnaceHeater: BOOL;\n    gasValve: BOOL;\n    oxygenFan: BOOL;\nEND_VAR\n\nMETHOD ReduceFurnaceTemperature: BOOL (initialTemp: REAL, targetTemp: REAL, rateOfDecreaseTemp: REAL)\n    timerCooling(IN:=TRUE, PT:=T#1h); // Timer for cooling\n    WHILE timerCooling.Q = FALSE OR furnaceTemp > targetTemp DO\n        furnaceHeater := FALSE; // Turn off the heater\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    isCoolingComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD GradualGasFlowReduction: BOOL (initialGasFlow: REAL, targetGasFlow: REAL, rateOfDecreaseGas: REAL)\n    timerGasFlowReduction(IN:=TRUE, PT:=T#12h); // Timer for gas reduction\n    WHILE timerGasFlowReduction.Q = FALSE OR gasFlowRate > targetGasFlow DO\n        gasValve := gasFlowRate > targetGasFlow; // Close gas valve if gas flow exceeds target\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    gasValve := FALSE; // Fully close gas valve\n    isGasFlowReductionComplete := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD AdjustOxygenSupply: BOOL (fuelToAirRatio: REAL)\n    oxygenFan := TRUE; // Start oxygen fan\n    WHILE oxygenLevel < (gasFlowRate * fuelToAirRatio) DO\n        oxygenFan := TRUE; // Increase oxygen flow if ratio not met\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    oxygenFan := FALSE; // Stop oxygen fan if ratio is met\n    isOxygenAdjusted := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE currentState OF\n    0: (* Initial state - Start temperature reduction *)\n        IF ReduceFurnaceTemperature(initialTemp, targetTemp, rateOfDecreaseTemp) THEN\n            currentState := 1;\n        END_IF;\n        \n    1: (* Gas flow reduction *)\n        IF GradualGasFlowReduction(initialGasFlow, targetGasFlow, rateOfDecreaseGas) THEN\n            currentState := 2;\n        END_IF;\n        \n    2: (* Adjust oxygen supply *)\n        IF AdjustOxygenSupply(fuelToAirRatio) THEN\n            currentState := 3; // Final state\n        END_IF;\n        \n    3: (* Final state - Shutdown complete *)\n        currentState := 0; // Reset to initial state\nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n\nFUNCTION GradualGasFlowReduction: BOOL (initialGasFlow: REAL, targetGasFlow: REAL, rateOfDecreaseGas: REAL)\nVAR\n    timerGasFlowReduction: TON;\n    gasValve: BOOL;\nBEGIN\n    timerGasFlowReduction(IN:=TRUE, PT:=T#12h);\n    WHILE timerGasFlowReduction.Q = FALSE OR gasFlowRate > targetGasFlow DO\n        gasValve := gasFlowRate > targetGasFlow;\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    gasValve := FALSE;\n    GradualGasFlowReduction := TRUE;\nEND_FUNCTION\n\nFUNCTION AdjustOxygenSupply: BOOL (fuelToAirRatio: REAL)\nVAR\n    oxygenFan: BOOL;\nBEGIN\n    oxygenFan := TRUE;\n    WHILE oxygenLevel < (gasFlowRate * fuelToAirRatio) DO\n        oxygenFan := TRUE;\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    oxygenFan := FALSE;\n    AdjustOxygenSupply := TRUE;\nEND_FUNCTION\n```\n",
        "description": "Markdown file from Shutdown Steel Production.md",
        "path": "Reference Solutions/Sequential Control/Shutdown Steel Production.md"
    },
    {
        "filename": "Startup Paper Machine.md",
        "content": "```\nPROGRAM PaperMachinePressStartup\nVAR\n    // States\n    currentState: INT := 0; // Initial state\n    \n    // Timers\n    timerInit: TON;\n    timerLubrication: TON;\n    timerConveyor: TON;\n    timerRolls: TON;\n    timerPressureIncrease: TON;\n    timerSpeedIncrease: TON;\n    \n    // Process parameters\n    initTime: TIME := T#10s; // Initialization time\n    lubricationTime: TIME := T#30s; // Lubrication system startup time\n    conveyorTime: TIME := T#60s; // Conveyor startup time\n    rollsTime: TIME := T#120s; // Rolls engagement time\n    pressureIncreaseTime: TIME := T#180s; // Time to increase nip pressure\n    speedIncreaseTime: TIME := T#300s; // Time to increase speed to operational level\n    \n    // Flags\n    isInitialized: BOOL := FALSE;\n    isLubricated: BOOL := FALSE;\n    isConveyorStarted: BOOL := FALSE;\n    areRollsEngaged: BOOL := FALSE;\n    isPressureIncreased: BOOL := FALSE;\n    isSpeedIncreased: BOOL := FALSE;\n    \n    // Sensors\n    rollSpeed: REAL := 10.0; // Initial roll speed in m/min\n    nipPressure: REAL := 0.5; // Initial nip pressure in bar\n    feltTemperature: REAL := 20.0; // Initial felt temperature in \u00b0C\n    \n    // Actuators\n    powerSupply: BOOL;\n    safetyInterlock: BOOL;\n    lubricationPump: BOOL;\n    conveyorMotor: BOOL;\n    rollMotor: BOOL;\n    pressureValve: BOOL;\n    heatingUnit: BOOL;\nEND_VAR\n\nMETHOD InitializeSystem: BOOL (initTime: TIME)\n    powerSupply := TRUE;\n    safetyInterlock := TRUE;\n    timerInit(IN:=TRUE, PT:=initTime);\n    WHILE timerInit.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    isInitialized := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD StartLubricationSystem: BOOL (lubricationTime: TIME)\n    lubricationPump := TRUE;\n    timerLubrication(IN:=TRUE, PT:=lubricationTime);\n    WHILE timerLubrication.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    isLubricated := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD StartConveyorSystem: BOOL (conveyorTime: TIME)\n    conveyorMotor := TRUE;\n    timerConveyor(IN:=TRUE, PT:=conveyorTime);\n    WHILE timerConveyor.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    isConveyorStarted := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD EngagePressRolls: BOOL (rollsTime: TIME)\n    rollMotor := TRUE;\n    timerRolls(IN:=TRUE, PT:=rollsTime);\n    WHILE timerRolls.Q = FALSE DO\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    areRollsEngaged := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD IncreaseNipPressure: BOOL (pressureIncreaseTime: TIME)\n    pressureValve := TRUE;\n    timerPressureIncrease(IN:=TRUE, PT:=pressureIncreaseTime);\n    WHILE timerPressureIncrease.Q = FALSE DO\n        nipPressure := nipPressure + 0.01; // Increment pressure slowly\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    isPressureIncreased := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD IncreaseRollSpeed: BOOL (speedIncreaseTime: TIME)\n    timerSpeedIncrease(IN:=TRUE, PT:=speedIncreaseTime);\n    WHILE timerSpeedIncrease.Q = FALSE DO\n        rollSpeed := rollSpeed + 10.0; // Increment speed\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    isSpeedIncreased := TRUE;\n    RETURN TRUE;\nEND_METHOD\n\nMETHOD AdjustTemperature: BOOL (targetTemp: REAL)\n    heatingUnit := TRUE;\n    WHILE feltTemperature < targetTemp DO\n        feltTemperature := feltTemperature + 0.5; // Increment temperature\n        WAIT 1; // Wait for 1 second\n    END_WHILE;\n    heatingUnit := FALSE;\n    RETURN TRUE;\nEND_METHOD\n\n(* Main control logic *)\nCASE currentState OF\n    0: (* Initialize System *)\n        IF InitializeSystem(initTime) THEN\n            currentState := 1;\n        END_IF;\n        \n    1: (* Start Lubrication System *)\n        IF StartLubricationSystem(lubricationTime) THEN\n            currentState := 2;\n        END_IF;\n        \n    2: (* Start Conveyor System *)\n        IF StartConveyorSystem(conveyorTime) THEN\n            currentState := 3;\n        END_IF;\n        \n    3: (* Engage Press Rolls *)\n        IF EngagePressRolls(rollsTime) THEN\n            currentState := 4;\n        END_IF;\n        \n    4: (* Increase Nip Pressure *)\n        IF IncreaseNipPressure(pressureIncreaseTime) THEN\n            currentState := 5;\n        END_IF;\n        \n    5: (* Increase Roll Speed *)\n        IF IncreaseRollSpeed(speedIncreaseTime) THEN\n            currentState := 6;\n        END_IF;\n        \n    6: (* Adjust Temperature *)\n        IF AdjustTemperature(50.0) THEN\n            currentState := 0; // Return to initial state, ready for next cycle\n        END_IF;\n        \nEND_CASE;\n\n(* Additional logic can be added here for monitoring and alarms *)\n\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Startup Paper Machine.md",
        "path": "Reference Solutions/Sequential Control/Startup Paper Machine.md"
    },
    {
        "filename": "Startup Steam Generator.md",
        "content": "```\nimport numpy as np\nfrom scipy.optimize import minimize\nimport sympy as sp\n\n# Define the symbols for the states and controls\nx, y, z = sp.symbols('x y z')  # Example state variables\nu = sp.symbols('u')  # Control input\n\n# Define the prediction model (example for demonstration purposes)\nmodel = {\n    'dxdt': u + x*y,  # Example non-linear relationship\n    'dydt': z + u*x,\n    'dzdt': u*z + y\n}\n\ndef prediction_model(x, u):\n    \"\"\"Evaluate the prediction model numerically.\"\"\"\n    dxdt = u + x[0]*x[1]\n    dydt = x[2] + u*x[0]\n    dzdt = u*x[2] + x[1]\n    return np.array([dxdt, dydt, dzdt])\n\ndef simulate_model(x0, u, dt, N):\n    \"\"\"Simulate the model forward in time.\"\"\"\n    x = x0\n    X = [x0]\n    for _ in range(N):\n        dx = prediction_model(x, u)\n        x = x + dx*dt\n        X.append(x)\n    return np.array(X)\n\n# Define the objective function to be minimized\ndef objective_function(u, x0, dt, N):\n    \"\"\"Calculate the cost of the control sequence.\"\"\"\n    X = simulate_model(x0, u, dt, N)\n    cost = np.sum((X[-1] - x_target)**2) + np.sum(u**2)\n    return cost\n\n# Define the constraints\nconstraints = ({'type': 'ineq', 'fun': lambda u: u - u_min},\n               {'type': 'ineq', 'fun': lambda u: u_max - u})\n\n# Initial conditions and target states\nx0 = np.array([0, 0, 0])  # Initial state vector\nx_target = np.array([1, 1, 1])  # Target state vector\n\n# Control horizon and sample time\nN = 10  # Number of future steps considered\ndt = 0.1  # Sample time in seconds\n\n# Bounds on the control input\nu_min = -1\nu_max = 1\nbounds = [(u_min, u_max),]\n\n# Initial guess for the control input\nu_init = np.zeros(N)\n\n# Solve the optimization problem\nresult = minimize(objective_function, u_init, args=(x0, dt, N), \n                  method='SLSQP', bounds=bounds, constraints=constraints)\n\nprint(\"Optimized control sequence:\", result.x)\n```\n",
        "description": "Markdown file from Startup Steam Generator.md",
        "path": "Reference Solutions/Sequential Control/Startup Steam Generator.md"
    },
    {
        "filename": "Binary Search.md",
        "content": "```\nFUNCTION_BLOCK BinarySearch\nVAR_INPUT\n    arr : ARRAY [1..100] OF INT; // Array of integers\n    value : INT; // Value to search for\nEND_VAR\nVAR_OUTPUT\n    index : INT; // Index of the found element, or -1 if not found\nEND_VAR\nVAR\n    left : INT := 1; // Left boundary of the search\n    right : INT := 100; // Right boundary of the search\n    mid : INT; // Midpoint of the search\n    found : BOOL := FALSE; // Flag to indicate if the value was found\nEND_VAR\n\n// Input validation: Check if the array is sorted\nFOR i := 1 TO 99 DO\n    IF arr[i] > arr[i+1] THEN\n        index := -2; // Return -2 to indicate the array is not sorted\n        RETURN;\n    END_IF;\nEND_FOR;\n\nWHILE NOT found AND (left <= right) DO\n    mid := trunc((left + right) / 2); // Calculate midpoint\n    IF arr[mid] = value THEN\n        found := TRUE;\n        index := mid;\n    ELSIF arr[mid] < value THEN\n        left := mid + 1; // Adjust left boundary\n    ELSE\n        right := mid - 1; // Adjust right boundary\n    END_IF;\nEND_WHILE;\n\nIF NOT found THEN\n    index := -1; // Indicate the value was not found\nEND_IF;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM ExampleProgram\nVAR\n    numbers : ARRAY [1..100] OF INT;\n    val : INT;\n    idx : INT;\nBEGIN\n    // Populate the array with sorted values\n    FOR i := 1 TO 100 DO\n        numbers[i] := i;\n    END_FOR;\n\n    // Set the value to search for\n    val := 50;\n\n    // Call the BinarySearch function block\n    BinarySearch(arr:=numbers, value:=val, index:=idx);\n\n    // Output the result\n    IF idx >= 0 THEN\n        // Element found\n        WRITE(\"Value \", val, \" found at index \", idx);\n    ELSEIF idx = -1 THEN\n        // Element not found\n        WRITE(\"Value \", val, \" not found.\");\n    ELSE\n        // Array not sorted\n        WRITE(\"Array is not sorted.\");\n    END_IF;\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Binary Search.md",
        "path": "Reference Solutions/Standard Algorithms/Binary Search.md"
    },
    {
        "filename": "Counter.md",
        "content": "```\nFUNCTION_BLOCK DigitalCounter\nVAR_INPUT\n    mode : BOOL; // TRUE for UP, FALSE for DOWN\n    enable : BOOL; // Enable signal to trigger counting\n    initialValue : INT; // Initial value of the counter\n    stepSize : INT; // Step size for increment/decrement\n    minValue : INT; // Minimum value before underflow\n    maxValue : INT; // Maximum value before overflow\nEND_VAR\nVAR_OUTPUT\n    currentValue : INT; // Current value of the counter\nEND_VAR\nVAR\n    firstCall : BOOL := TRUE; // Flag to set initial value only once\nEND_VAR\n\n// On the first call, set the initial value\nIF firstCall THEN\n    currentValue := initialValue;\n    firstCall := FALSE;\nEND_IF;\n\n// Handle counting based on mode and enable signal\nIF enable THEN\n    IF mode THEN // UP mode\n        IF currentValue < maxValue THEN\n            currentValue := currentValue + stepSize;\n        ELSE\n            // Handle overflow\n            currentValue := minValue;\n        END_IF;\n    ELSE // DOWN mode\n        IF currentValue > minValue THEN\n            currentValue := currentValue - stepSize;\n        ELSE\n            // Handle underflow\n            currentValue := maxValue;\n        END_IF;\n    END_IF;\nEND_IF;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM CounterExample\nVAR\n    mode : BOOL := TRUE; // Start in UP mode\n    enable : BOOL := TRUE; // Enable counting\n    initialValue : INT := 0; // Initial value of the counter\n    stepSize : INT := 1; // Step size for increment/decrement\n    minValue : INT := 0; // Minimum value before underflow\n    maxValue : INT := 100; // Maximum value before overflow\n    currentValue : INT; // Variable to store the current value of the counter\nBEGIN\n    // Initialize the counter\n    DigitalCounter(mode:=mode, enable:=enable, initialValue:=initialValue,\n                   stepSize:=stepSize, minValue:=minValue, maxValue:=maxValue,\n                   currentValue:=currentValue);\n\n    // Optionally, update mode and enable based on some condition\n    IF /* some condition */ THEN\n        mode := NOT mode; // Toggle mode\n    END_IF;\n\n    // Optionally, update enable based on some condition\n    enable := /* some condition */;\n\n    // Output the current value of the counter\n    WRITE(\"Current Value: \", currentValue);\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Counter.md",
        "path": "Reference Solutions/Standard Algorithms/Counter.md"
    },
    {
        "filename": "DecToHex.md",
        "content": "```\nFUNCTION_BLOCK DecToHex\nVAR_INPUT\n    decimalValue : DINT; // Decimal input value\nEND_VAR\nVAR_OUTPUT\n    hexValue : STRING[9]; // Hexadecimal output string\nEND_VAR\nVAR\n    tempDecimal : DINT; // Temporary storage for the decimal value\n    tempHex : STRING[9]; // Temporary storage for the hexadecimal string\n    i : INT; // Loop index\nEND_VAR\n\n// Initialize temporary variables\ntempDecimal := decimalValue;\ntempHex := '';\n\n// Convert decimal to hexadecimal\nFOR i := 1 TO 8 DO\n    CASE tempDecimal MOD 16 OF\n        0 TO 9 : tempHex := CHAR(#'0'+tempDecimal MOD 16) + tempHex;\n        10 : tempHex := 'A' + tempHex;\n        11 : tempHex := 'B' + tempHex;\n        12 : tempHex := 'C' + tempHex;\n        13 : tempHex := 'D' + tempHex;\n        14 : tempHex := 'E' + tempHex;\n        15 : tempHex := 'F' + tempHex;\n    END_CASE;\n    tempDecimal := tempDecimal DIV 16;\n    IF tempDecimal = 0 THEN\n        EXIT;\n    END_IF;\nEND_FOR;\n\nhexValue := tempHex;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM ExampleProgram\nVAR\n    decimalInput : DINT := 1234567890; // Example decimal value\n    hexOutput : STRING[9]; // Variable to store the hexadecimal value\nBEGIN\n    // Call the DecToHex function block\n    DecToHex(decimalValue:=decimalInput, hexValue:=hexOutput);\n\n    // Output the hexadecimal value\n    WRITE(\"Hexadecimal Value: \", hexOutput);\nEND_PROGRAM\n```\n",
        "description": "Markdown file from DecToHex.md",
        "path": "Reference Solutions/Standard Algorithms/DecToHex.md"
    },
    {
        "filename": "Fahrenheit to Celsius.md",
        "content": "```\nFUNCTION_BLOCK FahToCel\nVAR_INPUT\n    fahrenheit : REAL; // Temperature in Fahrenheit\nEND_VAR\nVAR_OUTPUT\n    celsius : REAL; // Temperature in Celsius\nEND_VAR\n\n// Perform the conversion\ncelsius := (5.0 / 9.0) * (fahrenheit - 32.0);\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM ExampleProgram\nVAR\n    fahrenheitInput : REAL := 32.0; // Example Fahrenheit temperature\n    celsiusOutput : REAL; // Variable to store the Celsius temperature\nBEGIN\n    // Call the FahToCel function block\n    FahToCel(fahrenheit:=fahrenheitInput, celsius:=celsiusOutput);\n\n    // Output the Celsius temperature\n    WRITE(\"Celsius Temperature: \", celsiusOutput);\nEND_PROGRAM\n\nFUNCTION_BLOCK FahToCel\nVAR_INPUT\n    fahrenheit : REAL; // Temperature in Fahrenheit\nEND_VAR\nVAR_OUTPUT\n    celsius : REAL; // Temperature in Celsius\nEND_VAR\n\n// Perform the conversion if the input is valid\nIF fahrenheit BETWEEN -273.15 AND 1000 THEN // Reasonable range check\n    celsius := (5.0 / 9.0) * (fahrenheit - 32.0);\nELSE\n    celsius := INVALID_VALUE; // Placeholder for invalid value handling\nEND_IF;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n```\n",
        "description": "Markdown file from Fahrenheit to Celsius.md",
        "path": "Reference Solutions/Standard Algorithms/Fahrenheit to Celsius.md"
    },
    {
        "filename": "Heapsort.md",
        "content": "```\nFUNCTION_BLOCK HeapSort\nVAR_INPUT\n    arr : ARRAY [1..100] OF INT; // The array to be sorted\nEND_VAR\nVAR_OUTPUT\n    sortedArr : ARRAY [1..100] OF INT; // The sorted array\nEND_VAR\nVAR\n    n : INT := 100; // The number of elements in the array\n    i : INT := 1; // Loop index\n    j : INT := 1; // Inner loop index\n    temp : INT; // Temporary variable for swap\n    heapSize : INT := n; // Size of the heap\nEND_VAR\n\n// Build the max heap\nFOR i TO n/2 DO\n    MaxHeapify(i, heapSize, arr);\nEND_FOR;\n\n// Extract elements from the heap one by one\nWHILE heapSize > 1 DO\n    // Swap the root (maximum value) of the heap with the last element\n    temp := arr[heapSize];\n    arr[heapSize] := arr[1];\n    arr[1] := temp;\n    \n    // Decrease the size of the heap by one\n    heapSize := heapSize - 1;\n    \n    // Restore the heap property\n    MaxHeapify(1, heapSize, arr);\nEND_WHILE;\n\n// Copy the sorted array back to the output variable\nsortedArr := arr;\n\nRETURN;\n\n// Helper function to maintain the max heap property\nPROCEDURE MaxHeapify(rootIndex : INT; heapSize : INT; BY_REF arr : ARRAY [1..100] OF INT)\nVAR\n    largest : INT := rootIndex; // Initialize largest as root\n    l : INT := 2 * rootIndex; // Left child index\n    r : INT := 2 * rootIndex + 1; // Right child index\nBEGIN\n    // If left child exists and is greater than root\n    IF l <= heapSize AND arr[l] > arr[largest] THEN\n        largest := l;\n    END_IF;\n    \n    // If right child exists and is greater than the largest so far\n    IF r <= heapSize AND arr[r] > arr[largest] THEN\n        largest := r;\n    END_IF;\n    \n    // Change root if needed\n    IF largest <> rootIndex THEN\n        // Swap\n        temp := arr[rootIndex];\n        arr[rootIndex] := arr[largest];\n        arr[largest] := temp;\n        \n        // Recursively heapify the affected sub-tree\n        MaxHeapify(largest, heapSize, arr);\n    END_IF;\nEND_PROCEDURE\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM ExampleProgram\nVAR\n    unsortedArr : ARRAY [1..100] OF INT; // Unsorted array\n    sortedArr : ARRAY [1..100] OF INT; // Sorted array\nBEGIN\n    // Populate the array with unsorted values\n    FOR i := 1 TO 100 DO\n        unsortedArr[i] := /* Some value */;\n    END_FOR;\n    \n    // Call the HeapSort function block\n    HeapSort(arr:=unsortedArr, sortedArr:=sortedArr);\n    \n    // Output the sorted array\n    FOR i := 1 TO 100 DO\n        WRITE(sortedArr[i]);\n    END_FOR;\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Heapsort.md",
        "path": "Reference Solutions/Standard Algorithms/Heapsort.md"
    },
    {
        "filename": "Kalman Filter.md",
        "content": "```\nFUNCTION_BLOCK KalmanFilter\nVAR_INPUT\n    measurement : REAL; // Measured position\n    dt : REAL; // Time step between measurements\n    Q : REAL; // Process noise covariance\n    R : REAL; // Measurement noise covariance\n    x_prev : ARRAY [1..2] OF REAL; // Previous state (position, velocity)\n    P_prev : ARRAY [1..2, 1..2] OF REAL; // Previous state covariance matrix\nEND_VAR\nVAR_OUTPUT\n    x_est : ARRAY [1..2] OF REAL; // Estimated state (position, velocity)\n    P_est : ARRAY [1..2, 1..2] OF REAL; // Estimated state covariance matrix\nEND_VAR\nVAR\n    F : ARRAY [1..2, 1..2] OF REAL; // State transition matrix\n    H : ARRAY [1..1, 1..2] OF REAL; // Observation model\n    K : ARRAY [1..2, 1..1] OF REAL; // Kalman gain\n    y : REAL; // Innovation (measurement residual)\n    S : REAL; // Innovation covariance\n    P_pred : ARRAY [1..2, 1..2] OF REAL; // Predicted state covariance matrix\nEND_VAR\n\n// Initialize matrices\nF[1,1] := 1.0; F[1,2] := dt; F[2,1] := 0.0; F[2,2] := 1.0;\nH[1,1] := 1.0; H[1,2] := 0.0;\n\n// Prediction step\nx_pred := F * x_prev;\nP_pred := F * P_prev * TRANSPOSE(F) + Q;\n\n// Update step\ny := measurement - H * x_pred;\nS := H * P_pred * TRANSPOSE(H) + R;\nK := P_pred * TRANSPOSE(H) / S;\nx_est := x_pred + K * y;\nP_est := (IDENTITY(2) - K * H) * P_pred;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\n\nPROGRAM ExampleProgram\nVAR\n    measuredPosition : REAL := 0.0; // Measured position\n    deltaTime : REAL := 1.0; // Time step between measurements\n    processNoise : REAL := 0.1; // Process noise covariance\n    measurementNoise : REAL := 1.0; // Measurement noise covariance\n    prevState : ARRAY [1..2] OF REAL := {0.0, 0.0}; // Initial state (position, velocity)\n    prevCovariance : ARRAY [1..2, 1..2] OF REAL := {{1.0, 0.0}, {0.0, 1.0}}; // Initial state covariance\n    estimatedState : ARRAY [1..2] OF REAL; // Estimated state (position, velocity)\n    estimatedCovariance : ARRAY [1..2, 1..2] OF REAL; // Estimated state covariance\nBEGIN\n    // Simulate a new measurement (for demonstration purposes)\n    measuredPosition := /* New measured position */;\n    \n    // Call the KalmanFilter function block\n    KalmanFilter(measurement:=measuredPosition, dt:=deltaTime, Q:=processNoise, R:=measurementNoise,\n                 x_prev:=prevState, P_prev:=prevCovariance, x_est:=estimatedState, P_est:=estimatedCovariance);\n    \n    // Update the previous state and covariance for the next iteration\n    prevState := estimatedState;\n    prevCovariance := estimatedCovariance;\n    \n    // Optionally, log or use the estimated state\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Kalman Filter.md",
        "path": "Reference Solutions/Standard Algorithms/Kalman Filter.md"
    },
    {
        "filename": "PID Controller.md",
        "content": "```\nFUNCTION_BLOCK PIDController\nVAR_INPUT\n    pv : REAL; // Process variable (actual value)\n    sp : REAL; // Setpoint (desired value)\n    kp : REAL; // Proportional gain\n    ki : REAL; // Integral gain\n    kd : REAL; // Derivative gain\n    ts : TIME; // Sampling time\nEND_VAR\nVAR_OUTPUT\n    output : REAL; // PID output\nEND_VAR\nVAR\n    err : REAL; // Error (difference between setpoint and process variable)\n    intErr : REAL; // Integral of the error\n    derErr : REAL; // Derivative of the error\n    prevErr : REAL; // Previous error\n    prevTs : TIME; // Previous sampling time\n    antiWindup : REAL; // Anti-windup term\n    integralTerm : REAL; // Integral term\n    derivativeTerm : REAL; // Derivative term\n    proportionalTerm : REAL; // Proportional term\nEND_VAR\n\n// Initialize variables on the first call\nIF prevTs = T#0s THEN\n    prevTs := ts;\n    prevErr := sp - pv;\n    intErr := 0.0;\n    derErr := 0.0;\nEND_IF;\n\n// Calculate error\nerr := sp - pv;\n\n// Calculate integral term\nintegralTerm := intErr * ki * TIME_TO_NUM(ts);\n\n// Calculate derivative term\nderErr := (err - prevErr) / NUM_TO_TIME(TIME_TO_NUM(ts) - TIME_TO_NUM(prevTs));\nderErr := derErr * kd;\n\n// Calculate proportional term\nproportionalTerm := err * kp;\n\n// Update integral error\nintErr := intErr + err * TIME_TO_NUM(ts);\n\n// Anti-windup (optional): prevent integral windup if output is saturated\nantiWindup := IF output > MAX_OUTPUT OR output < MIN_OUTPUT THEN\n                -err * ki * TIME_TO_NUM(ts);\n              ELSE\n                0.0;\n              END_IF;\n\n// Calculate PID output\noutput := proportionalTerm + integralTerm + derErr + antiWindup;\n\n// Store current values for the next iteration\nprevErr := err;\nprevTs := ts;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM ExampleProgram\nVAR\n    processVar : REAL := 0.0; // Process variable (actual value)\n    setPoint : REAL := 100.0; // Setpoint (desired value)\n    pGain : REAL := 1.0; // Proportional gain\n    iGain : REAL := 0.1; // Integral gain\n    dGain : REAL := 0.01; // Derivative gain\n    sampleTime : TIME := T#1s; // Sampling time\n    pidOutput : REAL; // PID output\nBEGIN\n    // Call the PIDController function block\n    PIDController(pv:=processVar, sp:=setPoint, kp:=pGain, ki:=iGain, kd:=dGain, ts:=sampleTime, output:=pidOutput);\n    \n    // Optionally, log or use the PID output\nEND_PROGRAM\n```\n",
        "description": "Markdown file from PID Controller.md",
        "path": "Reference Solutions/Standard Algorithms/PID Controller.md"
    },
    {
        "filename": "Quicksort.md",
        "content": "```\nFUNCTION_BLOCK QuickSort\nVAR_INPUT\n    arr : ARRAY [1..100] OF INT; // The array to be sorted\nEND_VAR\nVAR_OUTPUT\n    sortedArr : ARRAY [1..100] OF INT; // The sorted array\nEND_VAR\nVAR\n    low : INT := 1; // Lower bound of the segment to be sorted\n    high : INT := 100; // Upper bound of the segment to be sorted\n    pivot : INT; // Pivot element\n    i : INT := 1; // Index of the smaller element\n    stack : ARRAY [1..100] OF STRUCT start : INT; end : INT; END_STRUCT; // Stack for recursion simulation\n    top : INT := 0; // Top of the stack\n    temp : INT; // Temporary variable for swapping\nEND_VAR\n\n// Initial push to the stack\nstack[top].start := low;\nstack[top].end := high;\ntop := top + 1;\n\n// Loop until the stack is empty\nWHILE top > 0 DO\n    // Pop from the stack\n    top := top - 1;\n    high := stack[top].end;\n    low := stack[top].start;\n\n    // Partition the array\n    pivot := Partition(low, high, arr);\n\n    // Push the lower part to the stack if it needs sorting\n    IF pivot - 1 > low THEN\n        top := top + 1;\n        stack[top].start := low;\n        stack[top].end := pivot - 1;\n    END_IF;\n\n    // Push the higher part to the stack if it needs sorting\n    IF pivot + 1 < high THEN\n        top := top + 1;\n        stack[top].start := pivot + 1;\n        stack[top].end := high;\n    END_IF;\nEND_WHILE;\n\n// Copy the sorted array back to the output variable\nsortedArr := arr;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\n// Helper function for partitioning the array\nPROCEDURE Partition(low : INT; high : INT; BY_REF arr : ARRAY [1..100] OF INT) : INT\nVAR\n    pivot : INT := arr[high]; // Choose the last element as pivot\n    i : INT := low - 1; // Index of smaller element\n    j : INT := low; // Index of current element\n    temp : INT; // Temporary variable for swapping\nBEGIN\n    WHILE j < high DO\n        // If current element is smaller than or equal to pivot\n        IF arr[j] <= pivot THEN\n            i := i + 1;\n            // Swap arr[i] and arr[j]\n            temp := arr[i];\n            arr[i] := arr[j];\n            arr[j] := temp;\n        END_IF;\n        j := j + 1;\n    END_WHILE;\n    \n    // Swap arr[i+1] and arr[high] (or pivot)\n    temp := arr[i + 1];\n    arr[i + 1] := arr[high];\n    arr[high] := temp;\n    \n    RETURN i + 1; // Return the pivot index\nEND_PROCEDURE\n\nPROGRAM ExampleProgram\nVAR\n    unsortedArr : ARRAY [1..100] OF INT; // Unsorted array\n    sortedArr : ARRAY [1..100] OF INT; // Sorted array\nBEGIN\n    // Populate the array with unsorted values\n    FOR i := 1 TO 100 DO\n        unsortedArr[i] := /* Some value */;\n    END_FOR;\n    \n    // Call the QuickSort function block\n    QuickSort(arr:=unsortedArr, sortedArr:=sortedArr);\n    \n    // Output the sorted array\n    FOR i := 1 TO 100 DO\n        WRITE(sortedArr[i]);\n    END_FOR;\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Quicksort.md",
        "path": "Reference Solutions/Standard Algorithms/Quicksort.md"
    },
    {
        "filename": "Real Comparator.md",
        "content": "```\nFUNCTION_BLOCK RealComparator\nVAR_INPUT\n    input1 : REAL; // First input value\n    input2 : REAL; // Second input value\n    precision : INT; // Number of decimal places to compare up to\nEND_VAR\nVAR_OUTPUT\n    isEqual : BOOL; // Indicates if the two inputs are equal up to the specified precision\nEND_VAR\nVAR\n    multiplier : REAL; // Multiplier for shifting the decimal point\n    roundedInput1 : REAL; // Rounded version of the first input\n    roundedInput2 : REAL; // Rounded version of the second input\nEND_VAR\n\n// Calculate the multiplier to shift the decimal point\nmultiplier := POWER(10.0, precision);\n\n// Round both inputs to the specified precision\nroundedInput1 := ROUND(input1 * multiplier) / multiplier;\nroundedInput2 := ROUND(input2 * multiplier) / multiplier;\n\n// Compare the rounded inputs\nisEqual := roundedInput1 = roundedInput2;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM ExampleProgram\nVAR\n    value1 : REAL := 123.456789; // First real value\n    value2 : REAL := 123.456788; // Second real value\n    precisionLevel : INT := 6; // Number of decimal places to compare\n    comparisonResult : BOOL; // Result of the comparison\nBEGIN\n    // Call the RealComparator function block\n    RealComparator(input1:=value1, input2:=value2, precision:=precisionLevel, isEqual:=comparisonResult);\n    \n    // Output the result\n    WRITE('Are the values equal up to ', precisionLevel, ' decimal places? ', comparisonResult);\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Real Comparator.md",
        "path": "Reference Solutions/Standard Algorithms/Real Comparator.md"
    },
    {
        "filename": "Timer.md",
        "content": "```\nFUNCTION_BLOCK Timer\nVAR_INPUT\n    enable : BOOL; // Enable the timer\n    reset : BOOL; // Reset the timer\n    duration : TIME; // Duration of the timer\nEND_VAR\nVAR_OUTPUT\n    timedOut : BOOL; // Indicates if the timer has timed out\nEND_VAR\nVAR\n    elapsed : TIME; // Elapsed time\n    running : BOOL; // Indicates if the timer is running\n    startTime : TIME; // Start time of the timer\nEND_VAR\n\n// Initialize variables\nelapsed := T#0s;\nrunning := FALSE;\n\n// Handle reset condition\nIF reset THEN\n    running := FALSE;\n    timedOut := FALSE;\nELSIF enable AND NOT running THEN\n    // Start the timer\n    running := TRUE;\n    startTime := CURRENT_TIME;\nELSIF enable AND running THEN\n    // Update the elapsed time\n    elapsed := TIME_TO_NUM(CURRENT_TIME) - TIME_TO_NUM(startTime);\n    IF elapsed >= TIME_TO_NUM(duration) THEN\n        // Timer has timed out\n        running := FALSE;\n        timedOut := TRUE;\n    END_IF;\nEND_IF;\n\nRETURN;\n\nEND_FUNCTION_BLOCK\n\nPROGRAM ExampleProgram\nVAR\n    startSignal : BOOL := FALSE; // Signal to start the timer\n    stopSignal : BOOL := FALSE; // Signal to stop/reset the timer\n    duration : TIME := T#5s; // Duration of the timer\n    timeoutSignal : BOOL; // Output indicating if the timer has timed out\nBEGIN\n    // Toggle the start signal every 10 seconds (for demonstration purposes)\n    startSignal := startSignal XOR (CURRENT_TIME >= T#10s);\n    \n    // Toggle the stop signal every 20 seconds (for demonstration purposes)\n    stopSignal := stopSignal XOR (CURRENT_TIME >= T#20s);\n    \n    // Call the Timer function block\n    Timer(enable:=startSignal, reset:=stopSignal, duration:=duration, timedOut:=timeoutSignal);\n    \n    // Output the timeout signal status\n    WRITE('Timer has timed out: ', timeoutSignal);\nEND_PROGRAM\n```\n",
        "description": "Markdown file from Timer.md",
        "path": "Reference Solutions/Standard Algorithms/Timer.md"
    },
    {
        "filename": "Control Narrative Beer Brewing.md",
        "content": "```\nControl Narrative for Beer Brewing\n\nSection 1: Overview\n\nBeer brewing involves several key steps: mashing, lauter tun operation (lautering), boiling, fermentation, conditioning, and packaging. Each step requires precise control of temperature, pH, and other parameters to ensure consistent quality and flavor.\n\nSection 2: Mashing\n\nThe mashing process is critical for converting starches in malted grains into fermentable sugars. The following setpoints and ranges are typical:\n\nMash Temperature: 63\u00b0C to 68\u00b0C (145\u00b0F to 154\u00b0F) depending on the desired fermentability and body of the beer.\nMash pH: Typically between 5.2 and 5.5 for optimal enzyme activity.\nRest Time: Typically 45 minutes to 1 hour for a single-step infusion mash.\nSection 3: Boiling\n\nBoiling the wort is necessary to sterilize the liquid and extract bitterness and aroma from hops. Key parameters include:\n\nBoil Temperature: 100\u00b0C (212\u00b0F) to ensure proper hop utilization and sterilization.\nBoil Time: Usually 60 to 90 minutes, depending on the recipe and desired hop characteristics.\nSection 4: Lautering\n\nLautering is the process of separating the liquid wort from the solid grain particles after the mashing process. The goal is to extract as much sugar-rich liquid as possible while minimizing tannin and protein extraction, which can lead to off-flavors.\n\nEquipment and Instrumentation Needed:\n\nLauter Tun: A large vessel equipped with a false bottom or a filter screen to allow the liquid to drain while retaining the spent grains.\nStirrer: To mix the grains and water effectively during the initial mixing stage.\nPumps: To circulate the liquid through the grains and transfer the wort to the boil kettle.\nSensors: For measuring temperature, flow rate, and pressure.\nValves: To control the flow of liquid through the system.\nFilters: Optional additional filtration to ensure clarity.\nSteps to Execute Lautering:\n\nInitial Mixing (Mash-in):\nIntroduce hot water (typically around 70\u00b0C to 75\u00b0C or 158\u00b0F to 167\u00b0F) to the milled grains in the lauter tun.\nStir gently to ensure uniform mixing and prevent clumping.\nRest Period:\nAllow the mixture to rest for about 30 to 45 minutes to allow enzymatic conversion of starches to sugars.\nMaintain a constant temperature of approximately 65\u00b0C to 68\u00b0C (149\u00b0F to 154\u00b0F).\nRecirculation (Wort Clarification):\nBegin recirculating the wort through the grains using a pump.\nMonitor the clarity of the liquid being returned to the lauter tun.\nContinue recirculation until the wort is clear and free of particles.\nRun-off (Wort Collection):\nSlowly open the valve under the false bottom to begin collecting the wort.\nControl the flow rate to avoid turbulence, which could cause tannins and proteins to leach into the wort.\nCollect the wort in a separate vessel or transfer directly to the boil kettle.\nSparging (Final Rinse):\nAdd fresh water (sparge water) heated to about 78\u00b0C (172\u00b0F) to rinse the remaining sugars from the grains.\nAdjust the flow rate to balance efficiency and quality.\nMonitor the gravity of the collected wort to ensure the desired sugar content.\nCleaning and Sanitizing:\nAfter lautering is complete, clean the lauter tun thoroughly to remove any residual grains and sanitize it for the next batch.\nSection 5: Fermentation\n\nFermentation converts the sugars extracted during the mashing and lautering processes into alcohol and carbon dioxide. Typical fermentation parameters include:\n\nTemperature: Controlled between 10\u00b0C to 18\u00b0C (50\u00b0F to 64\u00b0F) for lagers and 18\u00b0C to 24\u00b0C (64\u00b0F to 75\u00b0F) for ales.\nYeast Strain: Selected based on the beer style and desired flavor profile.\nSection 6: Conditioning and Packaging\n\nAfter fermentation, the beer is conditioned to mature and improve its flavor. It is then packaged into bottles, cans, or kegs for distribution.\n\nConditioning Temperature: Typically around 4\u00b0C (39\u00b0F) for cold storage.\nPackaging Pressure: Controlled to achieve the desired carbonation level.\n```\n",
        "description": "Markdown file from Control Narrative Beer Brewing.md",
        "path": "Reference Solutions/Various Engineering Inputs/Control Narrative Beer Brewing.md"
    },
    {
        "filename": "Control Narrative for Ammonium Nitrate Reactor.md",
        "content": "```\nControl Narrative for Ammonium Nitrate Production Reactor\n\nSection 1: Overview\n\nAmmonium nitrate production involves the neutralization of nitric acid with ammonia gas to form ammonium nitrate solution, which is then processed into solid form. The process requires precise control of reactant ratios, temperature, and pressure to ensure a safe and efficient reaction.\n\nSection 2: Reactor Preparation\n\nBefore starting the reaction, the reactor must be prepared and checked for leaks and safety integrity.\n\nPressure Check: Ensure the reactor is sealed and check for leaks at pressures up to 5 bar.\nTemperature Check: Preheat the reactor to 50\u00b0C to facilitate the exothermic reaction.\nInstrumentation Verification: Confirm that all sensors and control systems are calibrated and functioning correctly.\nSection 3: Reactant Introduction\n\nThe introduction of reactants into the reactor must be carefully controlled to maintain the correct stoichiometry and prevent overheating.\n\nAmmonia Flow Rate: Setpoint 50 kg/hour with a range of 45 to 55 kg/hour.\nNitric Acid Flow Rate: Setpoint 100 kg/hour with a range of 90 to 110 kg/hour.\nReactant Ratio: Maintain a molar ratio of NH\u2083 to HNO\u2083 of 1:1 to ensure complete neutralization.\nSection 4: Reaction Control\n\nDuring the reaction, it is crucial to maintain optimal conditions for the exothermic reaction.\n\nReaction Temperature: Setpoint 70\u00b0C with a range of 65\u00b0C to 75\u00b0C.\nCooling Water Flow Rate: Setpoint 150 L/min with a range of 140 to 160 L/min to manage heat release.\nPressure: Maintain pressure below 2 bar to prevent excessive stress on the reactor walls.\nAgitation Speed: Setpoint 300 rpm with a range of 280 to 320 rpm to ensure homogenous mixing.\nSection 5: Product Separation\n\nOnce the reaction is complete, the ammonium nitrate solution must be separated from any unreacted materials and purified.\n\nSolution Temperature: Setpoint 80\u00b0C with a range of 75\u00b0C to 85\u00b0C for optimal crystallization.\nCrystallizer Agitation: Setpoint 200 rpm with a range of 180 to 220 rpm to promote crystal growth.\nCrystal Size: Target average crystal size of 0.5 mm with a range of 0.4 to 0.6 mm to ensure easy handling and uniformity.\nSection 6: Drying and Packaging\n\nThe final step involves drying the ammonium nitrate crystals and packaging them for distribution.\n\nDrying Temperature: Setpoint 110\u00b0C with a range of 105\u00b0C to 115\u00b0C to remove moisture without degrading the product.\nDrying Time: Setpoint 3 hours with a range of 2.5 to 3.5 hours to ensure complete drying.\nProduct Moisture Content: Target moisture content below 0.5% to meet quality standards.\nSection 7: Safety Considerations\n\nGiven the explosive nature of ammonium nitrate, safety measures must be strictly adhered to throughout the process.\n\nEmergency Shutdown: Install automatic shutdown triggers for temperature above 80\u00b0C and pressure above 2.5 bar.\nVentilation System: Ensure the ventilation system is operational and capable of handling any accidental releases.\nExplosion Suppression: Equip the reactor with explosion suppression systems and fire extinguishing equipment.\nRegular Inspections: Conduct regular inspections and maintenance checks on all equipment to identify and rectify potential issues promptly.\n```\n",
        "description": "Markdown file from Control Narrative for Ammonium Nitrate Reactor.md",
        "path": "Reference Solutions/Various Engineering Inputs/Control Narrative for Ammonium Nitrate Reactor.md"
    },
    {
        "filename": "Control Narrative for Ethanol Production.md",
        "content": "```\nControl Narrative for Ethanol Production\n\nSection 1: Overview\n\nEthanol production typically involves several key steps: raw material preparation, saccharification (conversion of starches to sugars), fermentation, and distillation. Precise control over temperature, pH, and nutrient levels ensures optimal yeast activity and ethanol yield.\n\nSection 2: Raw Material Preparation\n\nThe preparation of raw materials includes milling, cooking, and liquefaction to break down complex carbohydrates into simpler sugars.\n\nMilling Temperature: Setpoint 35\u00b0C with a range of 30\u00b0C to 40\u00b0C to optimize starch breakdown.\nCooking Temperature: Setpoint 95\u00b0C with a range of 90\u00b0C to 100\u00b0C to gelatinize starches.\nLiquefaction Temperature: Setpoint 90\u00b0C with a range of 85\u00b0C to 95\u00b0C to activate enzymes for starch breakdown.\nSection 3: Fermentation\n\nFermentation is the core process where yeast converts sugars into ethanol and carbon dioxide. The following setpoints and ranges are essential for efficient fermentation:\n\n3.1 Yeast Activation\n\nBefore introducing yeast to the mash, it must be activated to ensure viability and activity.\n\nYeast Activation Temperature: Setpoint 35\u00b0C with a range of 30\u00b0C to 40\u00b0C to stimulate yeast metabolism.\nActivation Time: Setpoint 30 minutes with a range of 20 to 40 minutes to ensure full activation.\n3.2 Inoculation\n\nIntroducing the activated yeast into the fermentation vessel initiates the conversion of sugars to ethanol.\n\nInitial Fermentation Temperature: Setpoint 30\u00b0C with a range of 28\u00b0C to 32\u00b0C to optimize yeast activity.\nYeast Concentration: Setpoint 0.05 g/L with a range of 0.04 to 0.06 g/L to maintain adequate yeast cell count.\n3.3 Fermentation Monitoring\n\nContinuous monitoring of fermentation parameters ensures optimal conditions throughout the process.\n\nFermentation Temperature: Setpoint 32\u00b0C with a range of 30\u00b0C to 34\u00b0C to maximize ethanol yield.\npH Control: Setpoint 4.5 with a range of 4.3 to 4.7 to prevent bacterial contamination.\nOxygen Level: Setpoint 0 ppm with a range of 0 to 5 ppm to maintain anaerobic conditions.\n3.4 Nutrient Addition\n\nSupplementing the mash with nutrients can enhance yeast health and fermentation efficiency.\n\nNutrient Concentration: Setpoint 0.1 g/L with a range of 0.08 to 0.12 g/L to provide sufficient yeast nutrition.\nAddition Timing: Introduce nutrients at the beginning of fermentation to support yeast growth.\n3.5 Carbon Dioxide Removal\n\nExcess CO\u2082 must be vented to prevent pressure buildup and maintain optimal fermentation conditions.\n\nCO\u2082 Venting Rate: Setpoint 2 L/min with a range of 1.5 to 2.5 L/min to manage CO\u2082 levels.\nPressure Relief Valve: Setpoint 1 bar with a range of 0.9 to 1.1 bar to prevent overpressure.\n3.6 Fermentation Completion\n\nDetermining when fermentation is complete is critical to prevent over-fermentation and ensure maximum ethanol yield.\n\nEthanol Concentration: Setpoint 10% (v/v) with a range of 9% to 11% (v/v) to indicate fermentation completion.\nResidual Sugar Level: Setpoint 1 g/L with a range of 0.5 to 1.5 g/L to confirm minimal sugar remains.\n```\n\n",
        "description": "Markdown file from Control Narrative for Ethanol Production.md",
        "path": "Reference Solutions/Various Engineering Inputs/Control Narrative for Ethanol Production.md"
    },
    {
        "filename": "FBD PID.md",
        "content": "```\n  +--------------------------------------+\n  | Analog Input (AI)                    |\n  | Input Signal: 0.0 to 10.0 V          |\n  +------------+-------------------------+\n               |                         |\n               v                         v\n  +------------+     +-------------------+\n  | Timer      |     | PID               |\n  | Input: AI  |---->| Input: AI         |\n  | Timer Set: 5 s  | | P: 0.5           |\n  | Timer Out: TO   | | I: 0.2           |\n  +------------+     | | D: 0.1           |\n                     | | Output: PID_OUT |\n                     +-------------------+\n                                |\n                                v\n  +-----------------------------+\n  | Analog Output (AO)          |\n  | Input Signal: PID_OUT       |\n  | Output Signal: 4.0 to 20.0 mA|\n  +-----------------------------+\n```\n",
        "description": "Markdown file from FBD PID.md",
        "path": "Reference Solutions/Various Engineering Inputs/FBD PID.md"
    },
    {
        "filename": "IO List Rolling Mill.md",
        "content": "```\n# I/O List for Rolling Mill in Steel Production Plant\n\nThe following table provides an Input/Output (I/O) list for a rolling mill in a steel production plant. The list includes 30 lines detailing various signals involved in the operation of the rolling mill.\n\n| Signal Name          | Input/Output | Signal Tag Number | Analog/Digital | Engineering Unit | Ranges                      | Setpoint | P&ID Reference |\n|----------------------|--------------|-------------------|----------------|------------------|-----------------------------|----------|----------------|\n| Mill Drive Motor     | Output       | MDMOTOR_001       | Digital         | On/Off           | Off: 0, On: 1               | N/A      | P01            |\n| Motor Current        | Input        | MOTORCURR_001     | Analog          | Amps             | 0 - 2000 A                  | N/A      | P01            |\n| Roll Gap Position    | Input        | ROLLGAPPOS_001    | Analog          | mm               | 0 - 500 mm                  | 250 mm   | P02            |\n| Roll Gap Setpoint    | Output       | ROLLGAPSP_001     | Analog          | mm               | 0 - 500 mm                  | 250 mm   | P02            |\n| Strip Thickness      | Input        | STRIPTHICKNESS_001| Analog          | mm               | 0 - 10 mm                   | N/A      | P03            |\n| Strip Thickness SP   | Output       | STRIPTHICKNESS_SP_001| Analog          | mm               | 0 - 10 mm                   | 5 mm     | P03            |\n| Lubrication Pump     | Output       | LUBPUMP_001       | Digital         | On/Off           | Off: 0, On: 1               | N/A      | P04            |\n| Lubrication Pressure | Input        | LUBPRESSURE_001   | Analog          | Bar              | 0 - 10 Bar                  | N/A      | P04            |\n| Cooling Water Flow   | Input        | CWFLOW_001        | Analog          | L/min            | 0 - 1000 L/min              | N/A      | P05            |\n| Cooling Water Temp   | Input        | CWTMP_001         | Analog          | \u00b0C               | 0 - 50 \u00b0C                   | N/A      | P05            |\n| Strip Tension        | Input        | STRIPTENSION_001  | Analog          | kN               | 0 - 100 kN                  | N/A      | P06            |\n| Strip Tension Setpoint| Output      | STRIPTENSION_SP_001| Analog          | kN               | 0 - 100 kN                  | 50 kN    | P06            |\n| Strip Speed          | Input        | STRIPSPEED_001    | Analog          | m/min            | 0 - 1000 m/min              | N/A      | P07            |\n| Strip Speed Setpoint | Output       | STRIPSPEED_SP_001 | Analog          | m/min            | 0 - 1000 m/min              | 500 m/min| P07            |\n| Guide Roll Position  | Input        | GUIDEPOS_001      | Analog          | mm               | 0 - 200 mm                  | N/A      | P08            |\n| Guide Roll Setpoint  | Output       | GUIDESP_001       | Analog          | mm               | 0 - 200 mm                  | 100 mm   | P08            |\n| Roll Bite Temp       | Input        | ROLLBITETMP_001   | Analog          | \u00b0C               | 0 - 300 \u00b0C                  | N/A      | P09            |\n| Roll Bite Temp Setpoint| Output     | ROLLBITETMP_SP_001| Analog          | \u00b0C               | 0 - 300 \u00b0C                  | 150 \u00b0C   | P09            |\n| Roll Bearing Temp    | Input        | ROLLBRTMP_001     | Analog          | \u00b0C               | 0 - 100 \u00b0C                  | N/A      | P10            |\n| Hydraulic Pressure   | Input        | HYDPRESSURE_001   | Analog          | Bar              | 0 - 200 Bar                 | N/A      | P11            |\n| Hydraulic Pump       | Output       | HYDPUMP_001       | Digital         | On/Off           | Off: 0, On: 1               | N/A      | P11            |\n| Roll Feed Rate       | Input        | ROLLFEEDRATE_001  | Analog          | mm/s             | 0 - 100 mm/s                | N/A      | P12            |\n| Roll Feed Rate Setpoint| Output    | ROLLFEEDRATE_SP_001| Analog          | mm/s             | 0 - 100 mm/s                | 50 mm/s  | P12            |\n| Pinch Roll Pressure  | Input        | PINCHROLLPRESS_001| Analog          | Bar              | 0 - 50 Bar                  | N/A      | P13            |\n| Pinch Roll Pressure SP| Output    | PINCHROLLPRESS_SP_001| Analog          | Bar              | 0 - 50 Bar                  | 25 Bar   | P13            |\n| Roll Gap Force       | Input        | ROLLGAPFORCE_001  | Analog          | kN               | 0 - 5000 kN                 | N/A      | P14            |\n| Roll Gap Force Setpoint| Output    | ROLLGAPFORCE_SP_001| Analog          | kN               | 0 - 5000 kN                 | 2500 kN  | P14            |\n| Strip Edge Temp      | Input        | STRIPEDEGETMP_001 | Analog          | \u00b0C               | 0 - 300 \u00b0C                  | N/A      | P15            |\n| Strip Edge Temp Setpoint| Output    | STRIPEDEGETMP_SP_001| Analog          | \u00b0C               | 0 - 300 \u00b0C                  | 150 \u00b0C   | P15            |\n| Strip Surface Temp   | Input        | STRIPSURFTMP_001  | Analog          | \u00b0C               | 0 - 300 \u00b0C                  | N/A      | P16            |\n| Strip Surface Temp Setpoint| Output| STRIPSURFTMP_SP_001| Analog          | \u00b0C               | 0 - 300 \u00b0C                  | 150 \u00b0C   | P16            |\n\nThis I/O list covers a wide array of signals essential for the operation of a rolling mill in a steel production plant, including motor control, position sensing, temperature measurement, hydraulic systems, and tension control. The setpoints provided are typical values for a given operation and can be adjusted according to specific process requirements.\n```\n",
        "description": "Markdown file from IO List Rolling Mill.md",
        "path": "Reference Solutions/Various Engineering Inputs/IO List Rolling Mill.md"
    },
    {
        "filename": "IO List Steam Water Cycle.md",
        "content": "```\n# I/O List for Feedwater Control in a Steam-Water Cycle\n\nThe following table provides an Input/Output (I/O) list for feedwater control in a steam-water cycle in a power plant.\n\n| Name               | Signal Tag Number | Analog/Digital | Engineering Unit | Ranges                       | Setpoint | P&ID Reference |\n|--------------------|-------------------|----------------|------------------|------------------------------|----------|----------------|\n| Boiler Water Level | BWR_LVL_001       | Analog         | %                | 0 - 100 %                    | 50 %     | P01            |\n| Feedwater Flow     | FWF_FLOW_001      | Analog         | m\u00b3/h              | 0 - 1000 m\u00b3/h                | N/A      | P02            |\n| Feedwater Valve    | FWF_VALVE_001     | Analog         | %                | 0 - 100 %                    | N/A      | P02            |\n| Feedwater Temp     | FWF_TEMP_001      | Analog         | \u00b0C                | 0 - 300 \u00b0C                   | N/A      | P03            |\n| Feedwater Pump     | FWPUMP_001        | Digital        | On/Off            | Off: 0, On: 1                | N/A      | P04            |\n| Deaerator Level    | DEA_LVL_001       | Analog         | %                | 0 - 100 %                    | 70 %     | P05            |\n| Condenser Level    | CON_LVL_001       | Analog         | %                | 0 - 100 %                    | 30 %     | P06            |\n| Condensate Pump    | CONPUMP_001       | Digital        | On/Off            | Off: 0, On: 1                | N/A      | P07            |\n| Economizer Inlet   | ECON_INLET_001    | Analog         | \u00b0C                | 0 - 300 \u00b0C                   | N/A      | P08            |\n| Economizer Outlet  | ECON_OUTLET_001   | Analog         | \u00b0C                | 0 - 300 \u00b0C                   | N/A      | P09            |\n| Preheater Level    | PRE_LVL_001       | Analog         | %                | 0 - 100 %                    | 60 %     | P10            |\n| Preheater Temp     | PRE_TEMP_001      | Analog         | \u00b0C                | 0 - 300 \u00b0C                   | N/A      | P11            |\n| Feedwater Pressure | FWF_PRESS_001     | Analog         | Bar               | 0 - 200 Bar                  | N/A      | P12            |\n| Deaerator Pressure | DEA_PRESS_001     | Analog         | Bar               | 0 - 200 Bar                  | N/A      | P13            |\n| Condenser Pressure | CON_PRESS_001     | Analog         | Bar               | 0 - 200 Bar                  | N/A      | P14            |\n| Economizer Valve   | ECON_VALVE_001    | Analog         | %                | 0 - 100 %                    | N/A      | P15            |\n| Deaerator Valve    | DEA_VALVE_001     | Analog         | %                | 0 - 100 %                    | N/A      | P16            |\n| Condensate Valve   | CON_VALVE_001     | Analog         | %                | 0 - 100 %                    | N/A      | P17            |\n| Preheater Valve    | PRE_VALVE_001     | Analog         | %                | 0 - 100 %                    | N/A      | P18            |\n| Feedwater Heater   | FWH_LEVEL_001     | Analog         | %                | 0 - 100 %                    | 80 %     | P19            |\n| Feedwater Heater   | FWH_TEMP_001      | Analog         | \u00b0C                | 0 - 300 \u00b0C                   | N/A      | P20            |\n| Feedwater Heater   | FWH_VALVE_001     | Analog         | %                | 0 - 100 %                    | N/A      | P21            |\n| Feedwater Heater   | FWH_PRESS_001     | Analog         | Bar               | 0 - 200 Bar                  | N/A      | P22            |\n| Boiler Feedwater   | BWR_FWF_001       | Analog         | m\u00b3/h              | 0 - 1000 m\u00b3/h                | N/A      | P23            |\n| Boiler Pressure    | BWR_PRESS_001     | Analog         | Bar               | 0 - 200 Bar                  | N/A      | P24            |\n\nThis I/O list covers a range of signals essential for the control of feedwater in a steam-water cycle in a power plant. The setpoints provided are typical values for a given operation and can be adjusted according to specific process requirements.\n```\n",
        "description": "Markdown file from IO List Steam Water Cycle.md",
        "path": "Reference Solutions/Various Engineering Inputs/IO List Steam Water Cycle.md"
    },
    {
        "filename": "P-ID Steam Water Cycle.md",
        "content": "```\n+------------------------+\n| Boiler (BOILER_001)    |\n|                        |\n| +----------------------+ |\n| | Water Level (WLEV)   | |\n| | Pressure (BPRES)     | |\n| +----------------------+ |\n|                        |\n| Feedwater In (FWIN)    |\n| Steam Out (STEAMOUT)   |\n+------------------------+\n\n+---------------------+\n| Feedwater Heater    |\n| (FEEDHEAT_001)      |\n|                    |\n| +------------------+ |\n| | Level (FLVL)      | |\n| | Temperature (FTMP)| |\n| +------------------+ |\n|                    |\n| Feedwater In (FWIN) |\n| Steam In (STEAMIN)  |\n| Feedwater Out (FWOUT)|\n+---------------------+\n\n+------------------+\n| Economizer       |\n| (ECONOMIZER_001) |\n|                 |\n| +---------------+ |\n| | Inlet Temp (ITMP)| |\n| | Outlet Temp (OTMP)| |\n| +---------------+ |\n|                 |\n| Feedwater In (FWIN)|\n| Feedwater Out (FWOUT)|\n+------------------+\n\n+------------------+\n| Deaerator        |\n| (DEAERATOR_001)  |\n|                 |\n| +---------------+ |\n| | Level (DLVL)   | |\n| | Pressure (DPRES)| |\n| +---------------+ |\n|                 |\n| Feedwater In (FWIN)|\n| Condensate In (CONDIN)|\n| Feedwater Out (FWOUT)|\n+------------------+\n\n+------------------+\n| Condenser        |\n| (CONDENSER_001)  |\n|                 |\n| +---------------+ |\n| | Level (CLVL)   | |\n| | Pressure (CPRES)| |\n| +---------------+ |\n|                 |\n| Steam In (STEAMIN)|\n| Condensate Out (CONDOUT)|\n+------------------+\n\n+------------------+\n| Feedwater Pump   |\n| (FWPUMP_001)     |\n|                 |\n| +---------------+ |\n| | Power (PW)     | |\n| +---------------+ |\n|                 |\n| Feedwater In (FWIN)|\n| Feedwater Out (FWOUT)|\n+------------------+\n\nControl Loops:\n\n1. Feedwater Flow Control Loop:\n   - Feedwater Flow Meter (FWFM_001)\n   - Feedwater Control Valve (FWCV_001)\n   - Setpoint (FWF_SETPOINT)\n   - PID Controller (FW_PID_001)\n\n   [FWFM_001] --> [FW_PID_001] --> [FWCV_001]\n\n2. Boiler Water Level Control Loop:\n   - Boiler Water Level Transmitter (WLEV_TRNS_001)\n   - Feedwater Control Valve (FWCV_001)\n   - Setpoint (WLEV_SETPOINT)\n   - PID Controller (WLEV_PID_001)\n\n   [WLEV_TRNS_001] --> [WLEV_PID_001] --> [FWCV_001]\n\n3. Boiler Pressure Control Loop:\n   - Boiler Pressure Transmitter (BPRES_TRNS_001)\n   - Boiler Pressure Control Valve (BPCV_001)\n   - Setpoint (BPRES_SETPOINT)\n   - PID Controller (BPRES_PID_001)\n\n   [BPRES_TRNS_001] --> [BPRES_PID_001] --> [BPCV_001]\n\n4. Feedwater Heater Level Control Loop:\n   - Feedwater Heater Level Transmitter (FLVL_TRNS_001)\n   - Feedwater Heater Control Valve (FLCV_001)\n   - Setpoint (FLVL_SETPOINT)\n   - PID Controller (FLVL_PID_001)\n\n   [FLVL_TRNS_001] --> [FLVL_PID_001] --> [FLCV_001]\n\n5. Feedwater Heater Temperature Control Loop:\n   - Feedwater Heater Temperature Transmitter (FTMP_TRNS_001)\n   - Steam Control Valve (SCV_001)\n   - Setpoint (FTMP_SETPOINT)\n   - PID Controller (FTMP_PID_001)\n\n   [FTMP_TRNS_001] --> [FTMP_PID_001] --> [SCV_001]\n\n6. Deaerator Level Control Loop:\n   - Deaerator Level Transmitter (DLVL_TRNS_001)\n   - Deaerator Control Valve (DCV_001)\n   - Setpoint (DLVL_SETPOINT)\n   - PID Controller (DLVL_PID_001)\n\n   [DLVL_TRNS_001] --> [DLVL_PID_001] --> [DCV_001]\n\n7. Condenser Level Control Loop:\n   - Condenser Level Transmitter (CLVL_TRNS_001)\n   - Condenser Control Valve (CCV_001)\n   - Setpoint (CLVL_SETPOINT)\n   - PID Controller (CLVL_PID_001)\n\n   [CLVL_TRNS_001] --> [CLVL_PID_001] --> [CCV_001]\n\n8. Economizer Temperature Control Loop:\n   - Economizer Inlet Temperature Transmitter (ITMP_TRNS_001)\n   - Economizer Outlet Temperature Transmitter (OTMP_TRNS_001)\n   - Economizer Control Valve (ECV_001)\n   - Setpoint (ITMP_SETPOINT)\n   - PID Controller (ITMP_PID_001)\n\n   [ITMP_TRNS_001] --> [ITMP_PID_001] --> [ECV_001]\n```\n",
        "description": "Markdown file from P-ID Steam Water Cycle.md",
        "path": "Reference Solutions/Various Engineering Inputs/P-ID Steam Water Cycle.md"
    },
    {
        "filename": "PFD Penicillin Fermentation.md",
        "content": "```\n+-----------------------+\n|   Penicillin Fermentor |\n|   (FERMENTOR_001)     |\n|                       |\n| +--------------------+ |\n| | Air Filter (AF)    | |\n| | pH Probe (PH_PROBE)| |\n| | Temperature (TEMP) | |\n| | Pressure (PRES)    | |\n| | Agitator (AGITATOR)| |\n| +--------------------+ |\n|                       |\n| Air In (AIRIN)        |\n| Sterile Air Out (SAIROUT)|\n| Penicillin Suspension Out (SUSPENSIONOUT)|\n+-----------------------+\n\n+---------------------+\n| Seed Tank           |\n| (SEEDTANK_001)      |\n|                     |\n| +------------------+ |\n| | Level (LEVEL)     | |\n| | Temperature (TEMP)| |\n| +------------------+ |\n|                     |\n| Seed Medium In (SEEDIN)|\n| Seed Medium Out (SEEDOUT)|\n+---------------------+\n\n+---------------------+\n| Sterilizer          |\n| (STERILIZER_001)   |\n|                     |\n| +------------------+ |\n| | Temperature (TEMP)| |\n| | Pressure (PRES)  | |\n| +------------------+ |\n|                     |\n| Medium In (MEDIUMIN)|\n| Medium Out (MEDIUMOUT)|\n+---------------------+\n\n+---------------------+\n| Harvest Tank        |\n| (HARVESTTANK_001)  |\n|                     |\n| +------------------+ |\n| | Level (LEVEL)     | |\n| | Temperature (TEMP)| |\n| +------------------+ |\n|                     |\n| Suspension In (SUSPENSIONIN)|\n| Suspension Out (SUSPENSIONOUT)|\n+---------------------+\n\n+---------------------+\n| Storage Tank        |\n| (STORAGE_001)      |\n|                     |\n| +------------------+ |\n| | Level (LEVEL)     | |\n| | Temperature (TEMP)| |\n| +------------------+ |\n|                     |\n| Medium In (MEDIUMIN)|\n| Medium Out (MEDIUMOUT)|\n+---------------------+\n\n+---------------------+\n| Coolant System      |\n| (COOLANTSYSTEM_001)|\n|                     |\n| +------------------+ |\n| | Temperature (TEMP)| |\n| +------------------+ |\n|                     |\n| Coolant In (COOLANTIN)|\n| Coolant Out (COOLANTOUT)|\n+---------------------+\n\nControl Philosophy:\n\n1. Temperature Control Loop:\n   - Temperature Sensor (TEMP)\n   - PID Controller (TEMP_PID)\n   - Coolant Valve (COOLANTVALVE)\n   - Setpoint (TEMP_SETPOINT)\n\n   [TEMP] --> [TEMP_PID] --> [COOLANTVALVE]\n\n2. Pressure Control Loop:\n   - Pressure Sensor (PRES)\n   - PID Controller (PRES_PID)\n   - Pressure Relief Valve (PRV)\n   - Setpoint (PRES_SETPOINT)\n\n   [PRES] --> [PRES_PID] --> [PRV]\n\n3. pH Control Loop:\n   - pH Probe (PH_PROBE)\n   - PID Controller (PH_PID)\n   - pH Adjustment Valve (PH_ADJUSTVALVE)\n   - Setpoint (PH_SETPOINT)\n\n   [PH_PROBE] --> [PH_PID] --> [PH_ADJUSTVALVE]\n\n4. Agitator Speed Control:\n   - Agitator (AGITATOR)\n   - Speed Control (AGIT_SPEED_CTRL)\n   - Setpoint (AGIT_SPEED_SETPOINT)\n\n   [AGIT_SPEED_CTRL] --> [AGITATOR]\n\n5. Sterilization Control Loop:\n   - Sterilizer Temperature (ST_TEMP)\n   - PID Controller (ST_TEMP_PID)\n   - Steam Valve (STEAMVALVE)\n   - Setpoint (ST_TEMP_SETPOINT)\n\n   [ST_TEMP] --> [ST_TEMP_PID] --> [STEAMVALVE]\n\n6. Seed Medium Transfer Control:\n   - Seed Tank Level (SEED_LEVEL)\n   - PID Controller (SEED_LVL_PID)\n   - Transfer Pump (TRANSFERPUMP)\n   - Setpoint (SEED_LVL_SETPOINT)\n\n   [SEED_LEVEL] --> [SEED_LVL_PID] --> [TRANSFERPUMP]\n\n7. Harvest Tank Level Control:\n   - Harvest Tank Level (HARVEST_LVL)\n   - PID Controller (HARVEST_LVL_PID)\n   - Harvest Pump (HARVESTPUMP)\n   - Setpoint (HARVEST_LVL_SETPOINT)\n\n   [HARVEST_LVL] --> [HARVEST_LVL_PID] --> [HARVESTPUMP]\n```\n",
        "description": "Markdown file from PFD Penicillin Fermentation.md",
        "path": "Reference Solutions/Various Engineering Inputs/PFD Penicillin Fermentation.md"
    },
    {
        "filename": "SCD LNG Vaporizer.md",
        "content": "```\n+------------------------------------------------------+\n| LNG Vaporizer System                                 |\n|                                                      |\n| +----------------------------------------------------+ |\n| | LNG Inlet (LNGIN_001)                             | |\n| | Vaporized NG Outlet (VNGOUT_001)                  | |\n| | LNG Level (LNG_LVL_001)                           | |\n| | LNG Temperature (LNG_TMP_001)                     | |\n| | LNG Pressure (LNG_PRS_001)                        | |\n| | Vaporized NG Temperature (VNG_TMP_001)            | |\n| | Vaporized NG Pressure (VNG_PRS_001)               | |\n| | Heating Medium Inlet (HEATIN_001)                 | |\n| | Heating Medium Outlet (HEATOUT_001)               | |\n| | Heating Medium Temperature (HEAT_TMP_001)         | |\n| | Heating Medium Pressure (HEAT_PRS_001)            | |\n| +----------------------------------------------------+ |\n|                                                      |\n| LNG In (LNGIN)                                       |\n| Heating Medium In (HEATIN)                           |\n| Vaporized NG Out (VNGOUT)                            |\n| Heating Medium Out (HEATOUT)                         |\n+------------------------------------------------------+\n\nControl Loops:\n\n1. LNG Level Control Loop:\n   - LNG Level Transmitter (LNG_LVL_001)\n   - PID Controller (LNG_LVL_CTL_001)\n   - LNG Level Control Valve (LNG_LVL_VLV_001)\n   - Setpoint (LNG_LVL_SP_001)\n\n   [LNG_LVL_001] --> [LNG_LVL_CTL_001] --> [LNG_LVL_VLV_001]\n\n2. LNG Temperature Control Loop:\n   - LNG Temperature Transmitter (LNG_TMP_001)\n   - PID Controller (LNG_TMP_CTL_001)\n   - Heating Medium Control Valve (HEAT_VLV_001)\n   - Setpoint (LNG_TMP_SP_001)\n\n   [LNG_TMP_001] --> [LNG_TMP_CTL_001] --> [HEAT_VLV_001]\n\n3. Vaporized NG Temperature Control Loop:\n   - Vaporized NG Temperature Transmitter (VNG_TMP_001)\n   - PID Controller (VNG_TMP_CTL_001)\n   - Heating Medium Control Valve (HEAT_VLV_001)\n   - Setpoint (VNG_TMP_SP_001)\n\n   [VNG_TMP_001] --> [VNG_TMP_CTL_001] --> [HEAT_VLV_001]\n\n4. Vaporized NG Pressure Control Loop:\n   - Vaporized NG Pressure Transmitter (VNG_PRS_001)\n   - PID Controller (VNG_PRS_CTL_001)\n   - Vaporized NG Pressure Control Valve (VNG_PRS_VLV_001)\n   - Setpoint (VNG_PRS_SP_001)\n\n   [VNG_PRS_001] --> [VNG_PRS_CTL_001] --> [VNG_PRS_VLV_001]\n\nInterlocks:\n\n1. LNG Level Low-Low Interlock:\n   - LNG Level Transmitter (LNG_LVL_001)\n   - Alarm (LNG_LVL_LL_001)\n   - LNG Inlet Valve (LNGIN_VLV_001)\n\n   [LNG_LVL_001] < [LNG_LVL_LL_SP_001] --> [LNGIN_VLV_001] CLOSE\n\n2. LNG Pressure High-High Interlock:\n   - LNG Pressure Transmitter (LNG_PRS_001)\n   - Alarm (LNG_PRS_HH_001)\n   - LNG Inlet Valve (LNGIN_VLV_001)\n\n   [LNG_PRS_001] > [LNG_PRS_HH_SP_001] --> [LNGIN_VLV_001] CLOSE\n\n3. Heating Medium Pressure Low-Low Interlock:\n   - Heating Medium Pressure Transmitter (HEAT_PRS_001)\n   - Alarm (HEAT_PRS_LL_001)\n   - Heating Medium Inlet Valve (HEATIN_VLV_001)\n\n   [HEAT_PRS_001] < [HEAT_PRS_LL_SP_001] --> [HEATIN_VLV_001] CLOSE\n\n4. Vaporized NG Temperature Low-Low Interlock:\n   - Vaporized NG Temperature Transmitter (VNG_TMP_001)\n   - Alarm (VNG_TMP_LL_001)\n   - Vaporized NG Outlet Valve (VNGOUT_VLV_001)\n\n   [VNG_TMP_001] < [VNG_TMP_LL_SP_001] --> [VNGOUT_VLV_001] CLOSE\n\n5. Vaporized NG Pressure High-High Interlock:\n   - Vaporized NG Pressure Transmitter (VNG_PRS_001)\n   - Alarm (VNG_PRS_HH_001)\n   - Vaporized NG Outlet Valve (VNGOUT_VLV_001)\n\n   [VNG_PRS_001] > [VNG_PRS_HH_SP_001] --> [VNGOUT_VLV_001] CLOSE\n\nPiping:\n\n- LNGIN_001: LNG Inlet Pipe\n- HEATIN_001: Heating Medium Inlet Pipe\n- VNGOUT_001: Vaporized NG Outlet Pipe\n- HEATOUT_001: Heating Medium Outlet Pipe\n```\n",
        "description": "Markdown file from SCD LNG Vaporizer.md",
        "path": "Reference Solutions/Various Engineering Inputs/SCD LNG Vaporizer.md"
    },
    {
        "filename": "SFC Traffic Light.md",
        "content": "```\n+------------------------------------+\n|  Traffic Light Control SFC         |\n+------------------------------------+\n|                                     |\n| +---------+       +---------+      |\n| | Step 1 |-------| Step 2  |      |\n| | RED ON |       | YELLOW  |      |\n| +--|-----+       +--|-----+      |\n|    ^  60s       ^  3s           |\n|    |            |               |\n|    +----+------+                |\n|         | RED/YELLOW OFF       |\n|         +---------------------+ |\n|                                     |\n| +---------+       +---------+      |\n| | Step 3 |-------| Step 4  |      |\n| | GREEN  |       | YELLOW  |      |\n| +--|-----+       +--|-----+      |\n|    ^  60s       ^  3s           |\n|    |            |               |\n|    +----+------+                |\n|         | RED/YELLOW OFF       |\n|         +---------------------+ |\n|                                     |\n| +---------+       +---------+      |\n| | Step 5 |-------| Step 1  |      |\n| | RED ON |       | RED ON  |      |\n| +---------+       +---------+      |\n|                                     |\n+------------------------------------+\n\nLegend:\n+---------+  : Step\n| Step #  |  : State description\n| Action  |  : What happens in the step\n+--|-----+  : Transition point\n^  #s    : Delay time in seconds before transition\n|         : Transition condition (in this case, the timer elapsing)\n+----+----+: Conditional branch (not used here but shown for completeness)\n\nStep Descriptions:\nStep 1 (RED ON): The red light is on, indicating stop for all traffic.\nStep 2 (YELLOW): The yellow light turns on to warn drivers that the green light is about to turn red.\nStep 3 (GREEN): The green light turns on, allowing traffic to proceed.\nStep 4 (YELLOW): The yellow light turns on again to warn drivers that the green light is about to turn red.\n\nTransitions:\n- From Step 1 to Step 2: After 60 seconds (delay for red light), the yellow light comes on.\n- From Step 2 to Step 3: After 3 seconds (delay for yellow light), the green light comes on.\n- From Step 3 to Step 4: After 60 seconds (delay for green light), the yellow light comes on.\n- From Step 4 to Step 1: After 3 seconds (delay for yellow light), the red light comes on again.\n\nThis SFC ensures that the traffic light cycles through its states in a predetermined sequence, with appropriate delays between state changes.\n```\n",
        "description": "Markdown file from SFC Traffic Light.md",
        "path": "Reference Solutions/Various Engineering Inputs/SFC Traffic Light.md"
    }
]